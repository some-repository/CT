<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Глава 7</TITLE>
</HEAD>
<body lang=RU class="Normal" bgcolor="#FFFFFF">

<p align="center"><b><font face="Times New Roman,sans-serif,Courier,mono" size="4">Глава 7. Тупики</font></b></p>
<P align="center"><a href="../06/ch6.htm"> Предыдущая глава</a> | <a href="../os.html">Программа курса</a> | 
<a href="../08/ch8.htm"> Следующая глава</a></P>


<p align="justify"><a name="l0701"></a><b>7.1  Введение </b></p>
<p align="justify">В предыдущих главах рассмотрены
  способы синхронизации процессов, которые позволяют процессам успешно кооперироваться.
  Однако  если средствами синхронизации пользоваться неосторожно, то могут возникнуть
  непредвиденные затруднения. Предположим, что несколько процессов конкурируют
  за обладание конечным числом ресурсов. Если запрашиваемый процессом ресурс недоступен,
  процесс переходит в состояние ожидания. В случае если  требуемый ресурс удерживается
  другим ожидающим процессом, то  первый процесс не сможет сменить свое состояние.
  Такая ситуация называется тупиком.  Говорят, что в мультипрограммной системе
  процесс находится в состоянии тупика, дедлока (<font face="Times New Roman,sans-serif,Courier,mono"size="3">deadlock</font>) или клинча, если он ожидает события, которое никогда
  не произойдет.  Системная тупиковая ситуация или зависание системы является
  следствием того, что один или более процессов находятся в состоянии тупика.</p>
<p align="justify">Рассмотрим пример.  Предположим,
  что два процесса осуществляют вывод с ленты на принтер. Один из них успел монополизировать
  ленту и претендует на принтер, а другой наоборот.  После этого оба процесса
  оказываются заблокированными в ожидании второго ресурса (см. рис. 7.1)</p>
<p align="justify">
  <img border="0" src="images/image001.gif" width="575" height="214"></p>
<p align="justify">
  <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  Рис. 7.1. Пример тупиковой ситуации.</font></p>
<p align="justify">Тупики также могут иметь место в ситуациях, не  требующих выделенных 
  ресурсов.  Например, в системах  управления базами данных процессы могут локализовывать 
  записи, чтобы избежать гонок (см. главу &quot;Синхронизация процессов&quot;). 
  В этом случае  может получиться так, что один из процессов заблокировал записи, 
  требуемые другому процессу и наоборот. Т.о. тупики могут иметь место, как на 
  аппаратных, так и на программных ресурсах.<font face="Times New Roman,sans-serif,Courier,mono"size="3"></font></p>
<p align="justify">Другой пример  возникновение
  тупика в системах спулинга. Режим спулинга  ввод-вывод с буферизацией информации,
  предназначенной для печати, на диске и организации очереди на печать  часто
  применяется для повышения производительности системы. Программа, осуществляющая
  вывод на печать должна полностью сформировать свои выходные данные в промежуточном
  файле, после чего начинается реальная распечатка. В итоге, несколько заданий
  может оказаться в тупиковой  ситуации, если предусмотренная емкость буфера для
  промежуточных файлов будет заполнена до того, как одно из заданий закончит свою
  работу. Возможные решения: увеличить размер буфера, или не принимать дополнительные
  задания, если файл спулинга близок к какому то порогу насыщения, например, заполнен
  на 75%.</p>
<p align="justify"><i><font face="Times New Roman,sans-serif,Courier,mono" size="3">Определение</font></i><font face="Times New Roman,sans-serif,Courier,mono" size="3">.
  Множество процессов находится в тупиковой ситуации, если каждый процесс из множества
  ожидает события, которое только другой процесс данного множества может вызвать.
  Так как все процессы чего-то ожидают, то ни один из них не сможет инициировать
  событие, которое разбудило бы другого члена множества и, следовательно, все
  процессы будут спать вместе. Обычно событие, которого ждет процесс в тупиковой
  ситуации - освобождение ресурса.</font></p>
<p align="justify">Далее в тексте данной главы будут
  обсуждаться вопросы, обнаружения, предотвращения, обхода тупиков и восстановления
  после тупиков.  Рассматривается также тесно связанная проблема бесконечного
  откладывания, которое может происходить из-за дискриминационной политики планировщика
  ресурсов. Во многих случаях цена борьбы с тупиками, которую приходится платить
  высока.  Тем не менее,  для ряда систем, например для систем реального времени,
  нет иного выхода.</p>
<p align="justify"><a name="l0702"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono" size="3">7.2 Концепция ресурса </font></b></p>
<p align="justify">Уже говорилось, что одна из основных
  функций ОС  осуществлять распределение ресурсов между процессами, то есть быть
  менеджером ресурсов.  </p>
<p align="justify">Как <i>устройства, </i>так и<i>
  данные </i>могут являться ресурсами.</p>
<p align="justify">Некоторые виды ресурсов  допускают разделение между процессами, 
  то есть являются <i>разделяемыми</i> устройствами. Например,  память, процессор, 
  диски  коллективно используются процессами.  Другие - нет, то есть являются 
  <i>выделенными</i><b>, </b> например, лентопротяжное устройство.<b>  </b>Чаще 
  всего тупики связаны с выделенными ресурсами, то есть тупики возникают, когда 
  процессу дается эксклюзивный доступ к устройствам, файлам и другим ресурсам. 
</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">Последовательность
  событий, требуемых для использования ресурса такова:</font></p>
<ol>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">&nbsp;</font><font face="Times New Roman,sans-serif,Courier,mono"size="3">запросить (</font><font face="Times New Roman,sans-serif,Courier,mono"size="3">request</font><font face="Times New Roman,sans-serif,Courier,mono"size="3">) ресурс,</font></li>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">использовать (</font><font face="Times New Roman,sans-serif,Courier,mono"size="3">use</font><font face="Times New Roman,sans-serif,Courier,mono"size="3">)
  ресурс,</font></li>
  <li>
    <p align="justify">освободить  (<font face="Times New Roman,sans-serif,Courier,mono"size="3">release</font><font face="Times New Roman,sans-serif,Courier,mono"size="3">) ресурс.</font></li>
</ol>
<p align="justify">Если ресурса нет в наличии, когда
  он требуется, то процесс вынужден ждать. В некоторых  ОС процесс автоматически
  блокируется, когда получает отказ на запрос к ресурсу и просыпается, когда ресурс
  оказывается в наличии. В других  системах  отказ сопровождается  возвратом ошибки
  и уже задача вызывающего процесса  решить: подождать немного и попытаться осуществить
  запрос вновь.</p>
<p align="justify">В наших дальнейших рассуждениях
  мы будем предполагать, что когда запрос отклонен, процесс переходит в состояние
  ожидания.</p>
<p align="justify">Природа запроса сильно зависит
  от ОС. В некоторых системах имеется системный  вызов <font face="Times New Roman,sans-serif,Courier,mono"size="3">request</font>
  для прямого запроса на ресурс. В других - единственные ресурсы, о которых ОС
  знает - специальные файлы,  которые только один процесс имеет право открывать
  за раз. Это делается обычным  вызовом open. Если файл уже используется,  вызывающий
  процесс блокируется, пока  ресурс не освободится.</p>
<p align="justify"><a name="l0703"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono" size="3">7.3 Условия возникновения тупиков</font></b></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">В 
  1971 г. Коффман, Элфик и Шошани сформулировали следующие четыре условия для 
  возникновения тупиков.</font></p>
<p align="justify">1.   Условие взаимоисключения (<font face="Times New Roman,sans-serif,Courier,mono"size="3">Mutual</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">exclusion</font>).  Каждый ресурс выделен
  в точности одному процессу или доступен. Процессы требуют предоставления им
  монопольного управления ресурсами, которые им выделяются.</p>
<p align="justify">2.   Условие ожидания ресурсов (<font face="Times New Roman,sans-serif,Courier,mono"size="3">Hold</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">and</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">wait</font>). Процессы удерживают за собой
  ресурсы, уже выделенные им, ожидая в то же время выделения дополнительных  ресурсов
  (которые при этом  обычно удерживаются другими процессами).</p>
<p align="justify">3.   Условие неперераспределяемости
  (<font face="Times New Roman,sans-serif,Courier,mono"size="3">No</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">preemtion</font>). Ресурс, данный ранее, не
  может быть принудительно забран у процесса. Освобождены они могут быть только
  процессом, который их удерживает.</p>
<p align="justify"> 4.  Условие кругового ожидания (<font face="Times New Roman,sans-serif,Courier,mono"size="3">Circular</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">wait</font>).  Существует кольцевая цепь процессов,
  в которой каждый процесс удерживает за собой один или более ресурсов, требующихся
  другим процессам цепи.</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Для
  тупика необходимо выполнение <b>всех четырех </b>условий.</font></p>
<p align="justify">Обычно тупик моделируется прямым графом, наподобие того, что 
  изображен на рис. 7.1, состоящим из узлов двух видов: прямоугольников процессов 
  и  эллипсов ресурсов. Стрелки, направленные от ресурса к процессу, показывают, 
  что ресурс выделен данному процессу.</p>
<p align="justify"><a name="l0704"></a>
<b>7.4  Основные направления борьбы с тупиками.</b></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">В
  связи с проблемой тупиков были выполнено много интересных исследований в области
  информатики и операционных систем. </font></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Основные
  направления борьбы с тупиками:</font></p>
<ol>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Игнорировать
    данную проблему</font></li>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Обнаружение тупиков</font></li>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Восстановление после
  тупиков</font></li>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Предотвращение тупиков
  за счет тщательного выделения ресурсов или нарушения одного из условий возникновения
  тупиков.</font></li>
</ol>
<p align="justify"><a name="l0705"></a>
<b>7.5  Алгоритм страуса</b></p>
<p align="justify">Простейший  подход -  игнорировать проблему тупиков.  Различные 
  люди реагируют на подобную стратегию по-разному. Математики находят ее неприемлемой 
  и утверждают, что тупики должны быть предотвращены любой ценой. Инженеры задают 
  вопрос:  как часто возникает данная проблема и как часто система виснет по другим 
  причинам?  Если тупик встречается раз в пять лет, но аварийный останов системы 
  из-за отказов оборудования, ошибок компиляторов или ОС происходит раз в месяц, 
  большинство инженеров не пожелают пожертвовать производительностью или удобством, 
  чтобы ликвидировать тупик.</p>
<p align="justify">Например, ОС U<font face="Times New Roman,sans-serif,Courier,mono"size="3">nix</font>,
  имеющая в ядре ряд  массивов  фиксированной размерности, потенциально страдает
  от тупиков,  даже если они не обнаружены.  Например, суммарное число процессов
  в системе определяется  размерностью таблицы процессов. Если таблица заполнена,
  вероятность этого ничтожна, но такое может произойти, то для программы, которая
  делает вызов fork,  резонно подождать некоторое время и попытаться осуществить
  этот вызов вновь. Следует ли отказываться от вызова <font face="Times New Roman,sans-serif,Courier,mono"size="3">fork</font>,
  чтобы решить эту проблему?</p>
<p align="justify">Максимальное  число открытых файлов
  аналогичным образом ограничено размером таблицы индексных узлов. С ними может
  произойти аналогичная ситуация. Пространство  выгрузки на диске - другой лимитируемый
  ресурс. Фактически любая таблица в ОС - конечный ресурс. </p>
<p align="justify">Подход U<font face="Times New Roman,sans-serif,Courier,mono"size="3">nix</font>
  состоит в том, чтобы игнорировать  данную проблему в предположении, что большинство
  пользователей предпочтут случайный тупик  нелепым правилам  заставляющих их
  иметь один процесс, один открытый файл и т.п. ... Таким образом,  мы сталкиваемся
  с нежелательным выбором между  строгостью и удобством.  Трудно найти общее,
  устраивающее всех решение.</p>
<p align="justify"><a name="l0706"></a>
<b>7.6  Обнаружение тупиков </b></p>
<p style='text-align:justify'>Обнаружение тупика  это  установление факта, что
  возникла тупиковая ситуация и определение процессов и ресурсов,  вовлеченных
  в эту ситуацию. Как правило, алгоритмы обнаружения применяются, когда  выполнены
  первые три необходимых условия возникновения тупиковой ситуации. Затем  проверяется
  наличие режима кругового ожидания. При этом активно используются уже упоминавшиеся
  графы распределения ресурсов.</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Рассмотрим 
  модельную ситуацию <a href="../literature/literature.htm">[12]</a>:</font></p>
<ul type=disc>
  <li style='text-align:justify;     '>Процесс <font face="Times New Roman,sans-serif,Courier,mono"size="3">A</font> удерживает
    ресурс  <font face="Times New Roman,sans-serif,Courier,mono"size="3">R</font> и ожидает ресурс <font face="Times New Roman,sans-serif,Courier,mono"size="3">S</font>.</li>
  <li style='text-align:justify;     '>Процесс <font face="Times New Roman,sans-serif,Courier,mono"size="3">B</font> претендует
    на ресурс <font face="Times New Roman,sans-serif,Courier,mono"size="3">T</font>.</li>
  <li style='text-align:justify;     '>Процесс <font face="Times New Roman,sans-serif,Courier,mono"size="3">C</font> претендует
    на ресурс <font face="Times New Roman,sans-serif,Courier,mono"size="3">S</font>.</li>
  <li style='text-align:justify;     '>Процесс <font face="Times New Roman,sans-serif,Courier,mono"size="3">D</font> удерживает
    ресурс  <font face="Times New Roman,sans-serif,Courier,mono"size="3">U</font> и ожидает ресурсы <font face="Times New Roman,sans-serif,Courier,mono"size="3">S</font> и <font face="Times New Roman,sans-serif,Courier,mono"size="3">T</font>.</li>
  <li style='text-align:justify;     '>Процесс <font face="Times New Roman,sans-serif,Courier,mono"size="3">E</font> удерживает
    ресурс  <font face="Times New Roman,sans-serif,Courier,mono"size="3">T</font> и ожидает ресурс <font face="Times New Roman,sans-serif,Courier,mono"size="3">V</font>.</li>
  <li style='text-align:justify;     '>Процесс <font face="Times New Roman,sans-serif,Courier,mono"size="3">F</font> удерживает
    ресурс  <font face="Times New Roman,sans-serif,Courier,mono"size="3">W</font> и ожидает ресурс <font face="Times New Roman,sans-serif,Courier,mono"size="3">S</font>.</li>
  <li style='text-align:justify;     '>Процесс <font face="Times New Roman,sans-serif,Courier,mono"size="3">G</font> удерживает
    ресурс  <font face="Times New Roman,sans-serif,Courier,mono"size="3">V</font> и ожидает ресурс <font face="Times New Roman,sans-serif,Courier,mono"size="3">U</font>.</li>
</ul>
<p style='text-align:justify'>Вопрос состоит в том, является ли данная ситуация
  тупиковой, и если да, то какие процессы в ней участвуют.</p>
<p align="justify"><img border="0" src="images/image002.gif" width="655" height="321"></p>
<p align="justify"><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Рис. 7.2  (а) Граф ресурсов.
  (б)  Цикл, извлеченный из графа (<font face="Times New Roman,sans-serif,Courier,mono"size="3">a).</font></font></p>
<p align="justify">Для ответа на этот вопрос можно
  сконструировать граф ресурсов, как показано на рис. 7.2. Из рисунка  видно,
  что имеется цикл, моделирующий условие кругового ожидания, и процессы D,E,G
  в тупиковой ситуации</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Визуально
  легко обнаружить наличие тупика, но нужны также формальные алгоритмы, реализуемые
  на компьютере. </font></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Один 
  из таких алгоритмов описан в <a href="../literature/literature.htm">[12]</a>, 
  там же можно найти ссылки на другие алгоритмы.</font></p>
<p align="justify">Существуют и другие способы обнаружения тупиков, применимые  
  также в ситуациях, когда имеется несколько ресурсов каждого типа. Так в <a href="../literature/literature.htm">[22]</a> 
  описан способ, называемый редукцией графа распределения ресурсов, а в <a href="../literature/literature.htm">[12]</a> 
  матричный алгоритм. </p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3"> </font></p>
<p align="justify"><a name="l0707"></a>
<b>7.7  Восстановление после тупиков </b></p>
<p align="justify">Предположим, что алгоритм обнаружения
  справился со своей задачей и обнаружил тупик. Что дальше. Один из путей - восстановиться
  и заставить систему работать дальше. В данной секции мы обсудим различные способы
  восстановления после тупиков. </p>
<p align="justify">Систему, оказавшуюся в тупике,
  можно вывести из него, нарушив одно из условий его существования. При этом
  возможно несколько процессов частично или полностью потеряют результаты проделанной
  работы.</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Сложность
  восстановления обусловлена рядом факторов.</font></p>
<ul>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">в 
      большинстве систем нет достаточно эффективных средств для приостановки процесса, 
      вывода его из системы и возобновления впоследствии;</font>
  </li>
  <li>
    <p align="justify">если даже такие средства есть, то их использование требует  
      затрат и внимания оператора;
  </li>
  <li>
    <p align="justify">восстановление  после серьезного тупика может потребовать 
      много работы.
  </li>
</ul>
<p align="justify"><a name="l070701"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono" size="3">7.7.1 Восстановление при помощи перераспределения ресурсов</font></b></p>
<p style='text-align:justify'>Один из способов восстановления - принудительный
  вывод некоторого процесса из системы для  последующего использования его ресурсов.
  Для определения того, какой процесс выводить из системы зачастую требуются усилия
  оператора. В некоторых случаях может оказаться возможным временно забрать ресурс
  у его текущего владельца и передать его другому процессу. </p>
<p align="justify">Например, чтобы отобрать лазерный принтер у  процесса, который 
  осуществляет вывод на него, оператор может собрать уже напечатанные бумаги и 
  сложить их в стопку. Затем процесс может быть приостановлен и принтер передан 
  другому процессу. После окончания  его работы  бумага может быть возвращена  
  в принтер и первый процесс  возобновляется.  Возможность забрать ресурс у процесса, 
  дать его другому процессу и затем вернуть его назад без нанесения ущерба сильно 
  зависит от природы ресурса. Подобное  восстановление часто трудно, если не невозможно.</p>
<p style='text-align:justify;'> <a name="l070702"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">7.7.2<font face="Times New Roman,sans-serif,Courier,mono"size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </font></font></b> <b><font face="Times New Roman,sans-serif,Courier,mono"size="3">Восстановление через откат назад</font></b></p>
<p style='text-align:justify'>Это,  по всей вероятности, самый эффективный способ
  приостановки и возобновления.</p>
<p align="justify">В ряде систем реализованы средства
  рестарта с <i>контрольной точки</i> (сохранение состояния системы в какой-то
  момент времени). Там где эти средства не предусмотрены, их должны организовать
  разработчики прикладных программ.  Если проектировщики системы знают, что тупик
  вероятен, они могут периодически организовывать для процессов контрольные точки.</p>
<p align="justify">Когда тупик обнаружен, видно какие
  ресурсы вовлечены в цикл кругового ожидания. Чтобы  осуществить восстановление,
  процесс, который владеет таким ресурсам, должен быть отброшен к моменту времени,
  предшествующему его запросу на этот ресурс. </p>
<p align="justify"><a name="l070703"></a>
<b>7.7.3  Восстановление через ликвидацию одного из процессов</b></p>
<p align="justify">Грубый, но простейший способ устранить
  тупик - убить один или более процессов.  Например, убить процесс, который в
  цикле. Тогда при удаче остальные  процессы смогут выполняться. Если это не помогает,
  то можно ликвидировать еще один процесс. </p>
<p align="justify">По возможности лучше убить тот
  процесс, который может быть без ущерба возвращен к началу (такие процессы называются
  <i>идемпотентными</i>), например, компиляция. С другой стороны процесс, который
  изменяет  содержимое базы данных, не всегда может быть корректно запущен повторно.</p>
<p style='text-align:justify'><a name="l0708"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">7.8 Способы предотвращения тупиков путем тщательного распределения ресурсов.</font></b></p>
<p align="justify">При предотвращении тупиков целью
  является обеспечение условий, исключающих возможность возникновения тупиковых
  ситуаций.</p>
<p align="justify">Система, предоставляя ресурс в
  распоряжение процесса,  должна принять решение, безопасно это или нет. Возникает
  вопрос: есть ли такой алгоритм, который  помогает всегда избегать тупиков и
  делать правильный выбор. Ответ - да, мы можем избегать тупиков, но только, если
  определенная информация известна заранее. В данной секции мы рассмотрим пути
  предотвращения тупиков за счет тщательного распределения ресурсов.</p>
<p align="justify">Один из алгоритмов предотвращения
  тупиков базируется на концепции безопасных состояний. </p>
<p align="justify"><a name="l070801"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">7.8.1 Предотвращение тупиков и алгоритм банкира.
  </font></b></p>
<p style='text-align:justify'>Можно избежать тупиковой ситуации, если рациональным
  образом использовать ресурсы, придерживаясь</p>
<p style='text-align:justify'>определенных правил. Наиболее известен среди алгоритмов 
  такого рода - алгоритм банкира, предложенный Дейкстрой. Он, как бы имитирует 
  действия банкира, который, располагая определенным источником капитала, принимает 
  ссуды и выдает платежи.</p>
<p align="justify"> <font face="Times New Roman,sans-serif,Courier,mono"size="3">Предположим, что
  у системы в наличии n устройств, например лент.
Суть
  алгоритма состоит в следующем.</font></p>
<ul>
  <li>
    <p align="justify"> <font face="Times New Roman,sans-serif,Courier,mono"size="3">ОС принимает запрос
  от пользовательского процесса, если его максимальная потребность не превышает
    n.</font></li>
  <li>
    <p align="justify"> <font face="Times New Roman,sans-serif,Courier,mono"size="3">Пользователь гарантирует,
  что если ОС в состоянии удовлетворить его запрос, то все устройства будут возвращены
  системе в течение конечного времени.</font></li>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">Текущее состояние
  системы называется <i>надежным</i>, если ОС может обеспечить всем процессам
  их выполнение в течение конечного времени.</font></li>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">В соответствии с
  алгоритмом банкира выделение устройств возможно, только если состояние системы
  остается надежным.</font></li>
</ul>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Рассмотрим
  пример надежного состояния для системы с тремя пользователями и 12-ю устройствами,
  где 10 устройств задействовано, а 2 имеется в наличии. Пусть текущая ситуация
  такова:</font></p>
<table border=1 cellspacing=0 cellpadding=0>
  <tr>
    <td width=174 valign=top class="Normal">&nbsp; </td>
    <td width=136 valign=top class="Normal">
      <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Текущее количество</font></p>
    </td>
    <td width=180 valign=top class="Normal">
      <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">Максимальная потребность</font></p>
    </td>
  </tr>
  <tr>
    <td width=174 valign=top class="Normal">
      <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">Первый пользователь</font></p>
    </td>
    <td width=136 valign=top class="Normal">
      <p align="center"><font face="Times New Roman,sans-serif,Courier,mono" size="3">1</font></p>
    </td>
    <td width=180 valign=top class="Normal" align="center">
      <p align="center"><font face="Times New Roman,sans-serif,Courier,mono"size="3">4</font></p>
    </td>
  </tr>
  <tr>
    <td width=174 valign=top class="Normal">
      <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Второй пользователь</font></p>
    </td>
    <td width=136 valign=top class="Normal">
      <p align="center"><font face="Times New Roman,sans-serif,Courier,mono" size="3">4</font></p>
    </td>
    <td width=180 valign=top class="Normal" align="center">
      <p align="center"><font face="Times New Roman,sans-serif,Courier,mono"size="3">6</font></p>
    </td>
  </tr>
  <tr>
    <td width=174 valign=top class="Normal">
      <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Третий пользователь</font></p>
    </td>
    <td width=136 valign=top class="Normal">
      <p align="center"><font face="Times New Roman,sans-serif,Courier,mono" size="3">5</font></p>
    </td>
    <td width=180 valign=top class="Normal" align="center">
      <p align="center"><font face="Times New Roman,sans-serif,Courier,mono"size="3">8</font></p>
    </td>
  </tr>
</table>
<p align="justify">Данное состояние надежно. Последующие
  действия системы могут быть таковы.  Вначале удовлетворить запросы второго пользователя,
  затем дождаться, когда он выполнит свою работу и освободит свои 6 устройств.
  Затем можно обслужить остальных пользователей. То есть, система удовлетворяет
  только те запросы,  которые оставляют ее в надежном состоянии и отклоняет остальные.
</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Термин
  <i>ненадежное</i> состояние не предполагает, что обязательно возникнут тупики.
  Он лишь говорит о том, что в случае неблагоприятной последовательности событий
  система может зайти в тупик.</font></p>
<p align="justify"><a name="l070802"></a> <b>7.8.2  Недостатки алгоритма банкира 
  </b></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">У
  алгоритма банкира имеются серьезные недостатки, из-за которых разработчик может
  выбрать другой подход для</font> <font face="Times New Roman,sans-serif,Courier,mono" size="3">решения
  проблемы тупиков:</font></p>
<ul>
  <li>
    <p align="justify">Алгоритм  банкира исходит из фиксированного количества ресурсов.</li>
  <li>
    <p align="justify">Он требует, чтобы число работающих пользователей оставалось постоянным</li>
  <li>
    <p align="justify">Данный алгоритм требует, чтобы распределитель гарантированно
  удовлетворял запросы за конечный период времени. Очевидно, что для реальных
  систем нужны более конкретные гарантии.</li>
  <li>
    <p align="justify">Алгоритм требует, чтобы клиенты гарантированно возвращали ресурсы.
  Опять таки в реальных системах требуются, гораздо более конкретные гарантии.</li>
  <li>
    <p align="justify">Требуется, чтобы пользователи заранее указали свои максимальные
  потребности в ресурсах. При динамическом распределении ресурсов трудно оценить
  максимальные потребности пользователей.</li>
</ul>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">В
  следующей секции рассмотрены другие способы предотвращения тупиков.</font></p>
<p align="justify"><a name="l0709"></a>
<b>7.9  Предотвращение тупиков за счет нарушения условий возникновения тупиков.</b></p>
<p align="justify">Как же может реальная система
  избежать тупиков, если отсутствует информация о будущих запросах?  Для ответа
  на этот вопрос вернемся к четырем условиям раздела 7.3. Если мы сможем организовать
  работу системы так, что, по крайней мере, одно из этих условий не удовлетворено,
  тупик не возможен.</p>
<p align="justify"><a name="l070901"></a><b> <font face="Times New Roman,sans-serif,Courier,mono" size="3">7.9.1 
  Нарушение условия взаимоисключения</font></b></p>
<p align="justify">Если в системе отсутствуют выделенные
  ресурсы,  тупиков не будет. Тем не менее, ясно, что обобществление, например,
  принтера, то есть, разрешение двум процессам писать на один принтер в одно и
  то же время приведет к хаосу. За счет организации спулинга одновременная печать
  для нескольких процессов становится возможной. В этой модели единственный процесс,
  реально взаимодействующий с принтером - демон принтера.  Таким образом, тупик
  для принтера устранен.</p>
<p align="justify">К сожалению, не для всех устройств
  может быть организован спулинг (таблица процессов плохо поддается спулингу).
  Неприятным побочным следствием  может быть потенциальная тупиковая ситуация
  из-за конкуренции за дисковое пространство для  спул-буфера.  Тем не менее,
  в той или иной форме эта идея применяется часто. </p>
<p align="justify"><a name="l070902"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">7.9.2 Hарушение условия ожидания дополнительных ресурсов</font></b></p>
<p align="justify">Хавендер в 1968  г. предложил
  следующую стратегию.  </p>
<ul>
  <li>
    <p align="justify">Каждый процесс должен запрашивать все требуемые ему ресурсы сразу,
  причем не может начать выполняться до тех пор, пока все они не будут ему предоставлены.</li>
  <li>
    <p align="justify">Если же процесс, удерживает определенные ресурсы и получает отказ
  в выделении ему дополнительных ресурсов, то он должен освободить свои первоначальные
  ресурсы и, при необходимости, запросить их снова вместе с дополнительными.</li>
</ul>
<p align="justify">Таким образом, один из способов
  - заставить все процессы затребовать все свои ресурсы перед выполнением (все
  или ничего). Если система в состоянии выделить процессу все необходимое, он
  может работать до завершения. Если хотя бы один из ресурсов занят, процесс будет
  ждать.</p>
<p align="justify">Подобный подход не слишком привлекателен и приводит к снижению 
  эффективности работы компьютера. Редко бывает, что все запрашиваемые устройства 
  необходимы программе одновременно. Можно, конечно, разделить программу на несколько 
  шагов и выделять ресурсы отдельно для каждого шага программы, но основная проблема 
  как раз в том, что  многие процессы не знают, сколько ресурсов им понадобится 
  до начала вычислений. Если такая информация есть, то можно воспользоваться алгоритмом 
  банкира. Тем не менее, некоторые пакетные мэйнфреймы требуют от пользователей 
  перечислить все необходимые его программе ресурсы. </p>
<p align="justify"><a name="l070903"></a><b> <font face="Times New Roman,sans-serif,Courier,mono"size="3">7.9.3 
  Нарушение принципа неперераспределяемости. </font></b></p>
<p align="justify">В соответствии со вторым принципом
  Хавендера можно отбирать ресурсы у удерживающих их процессов до завершения этих
  процессов. Если бы это было всегда возможно, то можно было бы добиться невыполнения
  третьего условия возникновения тупиков.  С проблемой отнятия ресурсов у удерживающих
  их процессов мы сталкивались в 7.7.1.  Если процесс в течение некоторого времени
  использует определенные ресурсы, а затем освобождает эти ресурсы, он теряет
  всю работу, проделанную до настоящего момента. Весь вопрос в цене данного решения,
  которая может быть слишком высокой, если подобная ситуация возникает часто.
</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">Другим
  недостатком данной схемы может быть дискриминация отдельных процессов, у которых
  постоянно отбирают ресурсы.</font></p>
<p align="justify"><a name="l070904"></a> <b>7.9.4  Нарушение условия кругового 
  ожидания</b></p>
<p align="justify">Осталось одно условие. Циклического
  ожидания можно избежать несколькими путями. </p>
<p align="justify">Один из них  действовать в соответствии
  с правилом,  согласно которому каждый процесс может иметь только один ресурс
  в каждый момент времени. Если нужен второй ресурс - освободи первый. Очевидно,
  что для многих процессов это не приемлемо, например, для тех,  которые распечатывают
  большие файлы с ленты на принтер.</p>
<p align="justify">Другой способ -  присвоить всем
  ресурсам  уникальные  номера и потребовать, чтобы процессы запрашивали ресурсы
  в порядке возрастания номеров. Тогда  круговое ожидание возникнуть не может.</p>
<p align="justify">Небольшой вариацией этого алгоритма будет  нумерация в возрастающем 
  порядке  не ресурсов, а запросов процесса. После последнего запроса и освобождения 
  всех ресурсов можно разрешить процессу опять осуществит первый запрос.</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">Очевидно,
  что невозможно найти порядок, который удовлетворит всех.</font></p>
<p align="justify"><a name="l0710"></a>
<b>7.10  Родственные проблемы</b></p>
<p align="justify"><a name="l071001"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">7.10.1 Двухфазная локализация</font></b></p>
<p align="justify">Хотя  в общем случае рассмотренные способы  предотвращения  
  тупиков не кажутся перспективными, для  отдельных специфичных приложений подобные 
  алгоритмы широко используются. Например, во многих СУБД часто требуется локализация 
  нескольких записей, и затем изменение всех локализованных записей. Когда несколько 
  процессов работают с базой данных,  есть реальная опасность тупика.  Типичный 
  в подобных ситуациях  подход - двухфазная локализация. В первой фазе процесс 
  пытается локализовать все записи, которые ему нужны за один раз. Если это ему 
  удалось,  то он переходит ко второй фазе, выполняя изменения и освобождая записи. 
  В первой фазе не делается реальной работы.</p>
<p align="justify">Если в первой фазе некоторые записи,
  которые ему нужны, уже локализованы, процесс освобождает все, что он локализовал
  и пытается повторить первую фазу. В известном смысле этот подход напоминает
  требование захвата всех ресурсов заранее.  Естественно, что это срабатывает
  только в тщательно  организованных программах, которые могут быть приостановлены
  в течение первой фазы и рестартованы впоследствии. Далеко не все программы укладываются
  в эту схему.</p>
<p align="justify"><a name="l071002"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">7.10.2 Тупики не ресурсного типа</font></b></p>
<p align="justify">До сих пор все наше внимание было
  сконцентрировано на ресурсных тупиках.  Есть и другие тупиковые ситуации, например,
  когда  один из процессов ждет чего-то от другого. Это часто случается при некорректном
  использовании семафоров, когда один из процессов забывает открыть семафор
  для другого процесса.</p>
<p align="justify"><a name="l071003"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">7.10</font></b><b>.3
  Голод (</b><b><font face="Times New Roman,sans-serif,Courier,mono"size="3">s</font></b><b><font face="Times New Roman,sans-serif,Courier,mono"size="3">tarvation)</font></b><b><font face="Times New Roman,sans-serif,Courier,mono"size="3"></font></b></p>
<p align="justify">Близкая к тупикам проблема - голод.
  В динамических  системах постоянно происходят запросы процессов к ресурсам.
  Естественно, что должна быть реализована некоторая политика для принятия решения
  относительно того, кто получит  ресурсы и когда. Эта политика может быть дискриминационной
  по отношению к некоторым процессам, хотя формально они и не в тупике.</p>
<p align="justify">Например, несколько процессов конкурируют за принтер, и система 
  выделяет его по принципу - первым печатать файл наименьшего размера. Этот подход 
  увеличивает  число счастливых пользователей принтера и кажется удовлетворительным. 
  Однако пользователь с большим файлом оказывается в состоянии бесконечного ожидания 
  (тупике).  В данном случае голода можно избежать путем применения  иной политики, 
  например, <font face="Times New Roman,sans-serif,Courier,mono"size="3">FCFS</font> 
  (первый пришедший обслуживается первым).</p>
<p align="justify"><a name="l0711"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">7.11 Заключение.</font></b></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">Возникновение тупиков является потенциальной проблемой любой операционной системы.
  Они возникают, когда имеется группа процессов, каждый из которых пытается иметь
  эксклюзивный доступ к некоторым ресурсам и претендует на ресурсы, принадлежащие
  другому процессу. В итоге все они оказываются в состоянии бесконечного ожидания.</font></p>
<p align="justify">С тупиками можно бороться, можно
  их обнаруживать, избегать и восстанавливать систему после тупиков. Однако цена
  подобных  действий высока и соответствующие усилия должны предприниматься только
  в системах, где игнорирование тупиковых ситуаций приводит к катастрофическим
  последствиям. </p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">Считается, что </font>в будущих системах тупики станут более критичным фактором,
  так как  системы будущего:</p>
<ul>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">будут в большей степени
  ориентированы на параллельную работу</font></li>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">будет преимущественно
  реализовываться динамическое распределение ресурсов</font></li>
  <li>
    <p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">растет тенденция
  рассматривать данные как ресурс, в связи с чем количество ресурсов возрастет.</font></li>
</ul>
<p style='text-align:justify'>Более подробно данная тема рассмотрена в <a href="../literature/literature.htm">[9,12,22 
  и др.]</a></p>

<p align="center"><a href="../06/ch6.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../08/ch8.htm"> Следующая глава</a></P>

</body>
</html>
