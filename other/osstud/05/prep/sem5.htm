<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Семинар 5</TITLE>
</HEAD>
  <BODY bgcolor="#FFFFFF">
 <basefont face="Times New Roman" size="3">
 
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman" SIZE = 6>Семинар 5. Организация 
  взаимодействия процессов через pipe и FIFO в UNIX.</FONT></B></P>
<P ALIGN="CENTER">(Основывается на <a href="../../04/l4.htm">лекции 4</a>) </P>
<P align="center"><a href="../../03/prep/sem3-4.htm"> Предыдущий семинар</a> | <a href="../../os.html">Программа курса</a> | 
 <a href="../../06/prep/sem6-7.htm"> Следующий семинар</a></P>
<P ALIGN="CENTER"><B><font face="Times New Roman, Times, serif" size="4">Программа 
  семинара</font></B></P>
 
<ol>
  <li><a href="#s0501"><font face="Times New Roman, Times, serif" size="3">Понятие 
    о потоке ввода-вывода</font></a></li>
  <li><a href="#s0502"><font face="Times New Roman, Times, serif" size="3">Понятие 
    о работе с файлами через системные вызовы и стандартную библиотеку ввода-вывода.</font></a></li>
  <li><a href="#s0503"><font face="Times New Roman, Times, serif" size="3">Понятие 
    о файловом дескрипторе.</font></a></li>
  <li><a href="#s0504"><font face="Times New Roman" size=3>Открытие файла. Системный вызов open().</font></a></li>
  <li><a href="#s0505"><font face="Times New Roman" size=3>Системные вызовы close(), 
    read(), write().</font></a></li>
  <li><font face="Times New Roman" size=3><a href="#s0508">Понятие о pipe. Системный 
    вызов pipe().</a></font></li>
  <li><font face="Times New Roman" size=3><a href="#s0510">Организация связи через 
    pipe между процессом-родителем и процессом-потомком. Наследование файловых 
    дескрипторов при вызовах fork() и exec().</a></font></li>
  <li><font face="Times New Roman" size=3> <a href="#s0513">Особенности поведения 
    вызовов read() и write() для pip’а.</a></font> </li>
  <li><font face="Times New Roman" size=3><a href="#s0514">Понятие о FIFO. Использование 
    системного вызова mknod для создания FIFO. Функция mkfifo.</a></font></li>
  <li><font face="Times New Roman" size="3"><a href="#s0515">Особенности поведения 
    вызова open() при открытии FIFO.</a></font></li>
</ol>
<P ALIGN="CENTER"><font face="Times New Roman, Times, serif" size="3"><B><font size="4">Цели 
  занятия</font></B></font></P>
<OL>
  <li><font face="Times New Roman" size="3">Дать понятие о потоке данных в UNIX.</font></li>
  <li><font face="Times New Roman" size="3">Научить использовать системные вызовы 
    open(), read(), write(), close() при 
    работе с файлами.</font></li>
  <li> <font face="Times New Roman" size="3">Научить создавать pipe 
    и использовать его для связи  между родственными процессами.</font></li>
  <li> <font face="Times New Roman" size="3">Научить создавать FIFO и использовать 
    его для связи между неродственными процессами.</font></li>
  <LI><font face="Times New Roman, Times, serif" size="3">Студент должен четко 
    осознать, что содержимое FIFO хранится в оперативной памяти, а не на диске.</font></LI>
</OL>
<P ALIGN="CENTER"><font face="Times New Roman, Times, serif" size="3"><B><font size="4">Практические 
  работы</font></B></font></P>
<OL>
  <LI><font face="Times New Roman" size="3"><a href="#s0506">Прогон 
    программы для записи в файл, используя вызовы open(), write(), close()</a>. 
    </font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0507">Написание, компиляция 
    и запуск программы для чтения из файла, используя вызовы open(), read(), close()</a></font></LI>
  <LI><font face="Times New Roman" size="3"><a href="#s0509">Прогон программы для pipe в одном 
    процессе.</a></font></LI>
  <LI><font face="Times New Roman" size="3"><a href="#s0511">Прогон программы для организации однонаправленной 
    связи между родственными процессами через pipe.</a></font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0512">Написание, компиляция 
    и запуск программы для организации двунаправленной связи между родственными 
    процессами через pipe.</a></font></LI>
  <LI><font face="Times New Roman" size="3"><a href="#s0516">Прогон программы c FIFO в родственных 
    процессах.</a></font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0517">Написание, компиляция 
    и запуск программы с FIFO в неродственных процессах.</a></font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0518">Неработающий пример 
    для связи процессов на различных
    компьютерах.</a></font></LI>
</OL>
<P ALIGN="CENTER"><B><font face="Times New Roman, Times, serif" size="4">План
занятия</font></B></P>
<ol>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0501"></a>Понятие 
      о потоке ввода-вывода.</b></font> <br>
      <br>
    <font face="Times New Roman, Times, serif" size="3"> 
    <p align="JUSTIFY"><a href="../../04/ch4.htm#l0402"> <img border="0" src="../../images/bookopen.gif" align="right" vspace="5" alt="Категории средств связи в лекции" hspace="10"> 
      </a>Как уже упоминалось на лекции, среди всех категорий средств коммуникации 
      наиболее употребительными являются каналы связи, обеспечивающие достаточно 
      безопасное и достаточно информативное общение процессов. 
    </font> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><FONT face="Times New Roman" size=3><a href="../../04/ch4.htm#l04030302"> 
      <img border="0" src="../../images/bookopen.gif" align="right" vspace="5" alt="Понятие потока ввода-вывода в лекции" hspace="10"></a> 
      Существует две модели передачи данных по каналам связи — поток ввода-вывода 
      и сообщения. Из них более простой идеологически является потоковая модель, 
      в которой операции передачи/приема информации вообще не интересуются содержимым 
      того, что передается или принимается. Вся информация в канале связи рассматривается 
      как непрерывный поток байт, не обладающий никакой внутренней структурой.</FONT></font><font face="Times New Roman" size="3"> 
      Изучению механизмов, обеспечивающих потоковую передачу данных в операционной 
      системе UNIX, и будет посвящен этот семинар.<br>
      </font> &nbsp; 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0502"></a>Понятие 
      о работе с файлами через системные вызовы и стандартную библиотеку ввода-вывода 
      для языка C. </b></font> <font face="Times New Roman, Times, serif" size="3"><br>
      <br>
      Потоковая передача информации может осуществляться не только между процессами, 
      но и между процессом и устройством ввода-вывода, например между процессом 
      и диском, на котором данные представляются в виде файла. Поскольку понятие 
      файла должно быть знакомо изучающим этот курс, а системные вызовы, использующиеся 
      для потоковой работы с файлом во многом соответствуют системным вызовам, 
      применяемым для потокового общения процессов, мы начнем наше рассмотрение 
      именно с механизма потокового обмена между процессом и файлом.<br>
      <br>
      Из курса программирования на языке C вам должны быть известны, как мы надеемся, 
      функции работы с файлами из стандартной библиотеки ввода-вывода такие, как 
      fopen(), fread(), fwrite(), fprintf(), fscanf(), fgets() и т.д. Эти функции 
      входят как неотъемлемая часть в стандарт ANSI на язык C и позволяют программисту 
      получать информацию из файла или записывать ее в файл при условии, что программист 
      обладает определенными знаниями о содержимом передаваемых данных. Так, например, 
      функция fgets() используется для ввода из файла последовательности символов, 
      заканчивающейся символом '\n' - перевод каретки; функция fscanf() производит 
      ввод информации, соответствующей заданному формату, и т.&nbsp;д. С точки 
      зрения потоковой модели операции, определяемые функциями стандартной библиотеки 
      ввода-вывода, не являются потоковыми операциями, так как каждая из них требует 
      наличия некоторой структуры передаваемых данных.<br>
      <br>
      В операционной системе UNIX эти функции представляют собой надстройку - 
      сервисный интерфейс - над системными вызовами, осуществляющими прямые потоковые 
      операции обмена информацией между процессом и файлом и не требуюшими никаких 
      априорных знаний о том, что она содержит. Чуть позже мы кратко познакомимся 
      с системными вызовами open(), read(), write() и close(), которые применяются 
      для такого обмена, но сначала нам нужно ввести еще одно понятие - понятие 
      <i>файлового дескриптора</i>.<br>
      &nbsp; </font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><a name="s0503"></a><b>Файловый 
      дескриптор.</b></font><br>
      <br>
      <font face="Times New Roman, Times, serif" size="3"> <a href="../../02/ch2.htm#l020302"><img border="0" src="../../images/bookopen.gif" alt="PCB и контекст процесса в лекции" align="right" hspace="10" vspace="1"> 
      </a> На лекции мы говорили, что информация о файлах, используемых процессом, 
      входит в соcтав его системного контекста и хранится в его блоке управления 
      - PCB. В операционной системе UNIX можно упрощенно полагать, что информация 
      о файлах, с которыми процесс осуществляет операции потокового обмена, наряду 
      с информацией о потоковых линиях связи, соединяющих процесс с другими процессами 
      и устройствами ввода-вывода, хранится в некотором массиве, получившем название 
      таблицы открытых файлов или таблицы файловых дескрипторов. Индекс элемента 
      этого массива, соответствующий определенному потоку ввода-вывода, получил 
      название файлового дескриптора для этого потока. Таким образом, файловый 
      дескриптор представляет собой небольшое целое неотрицательное число, которое 
      для текущего процесса в текущий момент времени однозначно определяет некоторый 
      действующий канал ввода-вывода. Некоторые файловые дескрипторы на этапе 
      старта любой программы ассоциируются со стандартными потоками ввода-вывода. 
      Так, например, файловый дескриптор 0 соответсвует стандартному потоку ввода, 
      файловый дескриптор 1 - стандартному потоку вывода, файловый дескриптор 
      2 - стандартному потоку для вывода ошибок. В нормальном интерактивном режиме 
      работы стандартный поток ввода связывает процесс с клавиатурой, а стандартные 
      потоки вывода и вывода ошибок - с текущим терминалом.<br>
      <br>
      Более детально строение структур данных, содержащих информацию о потоках 
      ввода-вывода, ассоциированных с процессом, мы будем рассматривать позже, 
      при изучении <a href = ../../11/prep/sem11-12.htm>организации файловых систем 
      в UNIX.</a><br>
      </font> &nbsp; <font face="Times New Roman, Times, serif" size="3"></font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a name="s0504"></a><font color="#FF0000"><b>Открытие 
      файла. Системный вызов open().</b></font><br>
      <br>
      Файловый дескриптор используется в качестве параметра, описывающего поток 
      ввода-вывода, для системных вызовов, выполняющих операции над этим потоком. 
      Поэтому, прежде чем совершать операции чтения данных из файла и записи их 
      в файл, мы должны поместить информацию о файле в таблицу открытых файлов 
      и определить соответствующий файловый дескриптор. Для этого применяется 
      процедура открытия файла, осуществляемая системным вызовом <a href="../../man/open.htm">open()</a>. 
      <br>
      <br>
      Системный вызов <a href="../../man/open.htm">open()</a> использует набор 
      флагов для того, чтобы специфицировать операции, которые предполагается 
      применять к файлу в дальнейшем или которые должны быть выполнены непосредственно 
      в момент открытия файла. Из всего возможного набора флагов на текущем уровне 
      знаний нас будут интересовать только флаги <font color="#008000"><b>O_RDONLY</b></font>, 
      <b><font color="#008000">O_WRONLY</font></b>, <b> <font color="#008000">O_RDWR, 
      </font></b><font color="#008000"><b>O_CREAT </b></font> и <b><font color="#008000">O_EXCL</font></b>. 
      Первые три флага являются взаимоисключающими: хотя бы один из них должен 
      быть употреблен и наличие одного из них не допускает наличия двух других. 
      Эти флаги описывают набор операций, которые, при успешном открытии файла, 
      будут разрешены над файлом в последующем: только чтение, только запись, 
      чтение и запись. Как вам известно из материалов первого семинара, у каждого 
      файла существуют атрибуты прав доступа для различных категорий пользователей. 
      Если файл с заданным именем существует на диске, и права доступа к нему 
      для пользователя, от имени которого работает текущий процесс, не противоречат 
      запрошенному набору операций, то операционная система сканирует таблицу 
      открытых файлов от ее начала к концу в поисках первого свободного элемента, 
      заполняет его и возвращает индекс этого элемента в качестве файлового дескриптора 
      открытого файла. Если файла на диске нет, не хватает прав или отсутствует 
      свободное место в таблице открытых файлов, то констатируется возникновение 
      ошибки. <br>
      <br>
      В случае, когда мы<b> <u>допускаем</u>,</b> что файл на диске может отсутствовать, 
      и хотим, чтобы он тогда был создан, флаг для набора операций должен использоваться 
      в комбинации с флагом <b><font color="#008000">O_CREAT</font></b>. Если 
      файл существует, то все происходит по рассмотренному выше сценарию. Если 
      файла нет - то сначала выполняется создание файла с <a href="../../man/open.htm#open1">набором 
      прав, указанном в параметрах системного вызова</a>. Проверка соответствия 
      набора операций объявленным правам доступа может и не производиться (как, 
      например, в Linux).<br>
      <br>
      </font><font face="Times New Roman, Times, serif" size="3">В случае, когда 
      мы <u><b>требуем</b></u>, чтобы файл на диске отсутствовал и был создан 
      в момент открытия, флаг для набора операций должен использоваться в комбинации 
      с флагами <b><font color="#008000">O_CREAT</font></b> и <b><font color="#008000">O_EXCL</font></b>. 
      <br>
      <br>
      Детальнее об операции открытия файла и ее месте среди набора всех файловых 
      операций будет рассказываться на <a href="../../11/ch11.htm">лекции &quot;Файловая 
      система с точки зрения пользователя&quot;</a>. Работу системного вызова 
      <a href="../../man/open.htm">open()</a> с флагами <font color="#008000"><b>O_APPEND</b></font> 
      и <b><font color="#008000">O_TRUNC</font></b> мы разберем на семинаре, посвященном 
      <a href = ../../11/prep/sem11-12.htm>организации файловых систем в UNIX.</a><br>
      <br>
      &nbsp; </font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a name="s0505"></a><font color="#FF0000"><b>Системные 
      вызовы read(), write(), close().</b></font><br>
      <br>
      Для совершения потоковых операций чтения информации из файла и ее записи 
      в файл применяются системные вызовы <a href="../../man/read.htm">read() 
      и write()</a>. Мы сейчас не акцентируем внимание на понятии указателя текущей 
      позиции в файле и взаимном влиянии значения этого указателя и поведения 
      системных вызовов. Этот вопрос будет обсуждаться в <a href = ../../11/prep/sem11-12.htm>дальнейшем</a>.<br>
      <br>
      <a name="s0505a"></a>После завершения потоковых операций, процесс должен 
      выполнить операцию закрытия потока ввода-вывода, во время которой произойдет 
      окончательный досброс буферов на линии связи, освободятся выделенные ресурсы 
      операционной системы, и элемент таблицы открытых файлов, соответствующий 
      файловому дескриптору, будет отмечен как свободный. За эти действия отвечает 
      системный вызов <a href="../../man/close.htm">close()</a>. Надо отметить, 
      что при <a href="../../03/prep/sem3-4.htm#s0310">завершении работы процесса</a> 
      с помощью явного или неявного вызова функции <a href="../../man/exit.htm">exit&nbsp;()</a> 
      происходит автоматическое закрытие всех открытых потоков ввода-вывода. <br>
      &nbsp;</font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a name="s0506"></a><font color="#FF0000"><b>Прогон 
      программы для записи информации в файл.</b></font></font><font face="Times New Roman, Times, serif" size="3"><br>
      <br>
      Для иллюстрации вышесказанного давайте рассмотрим <a href="../stud/05-1c.htm">программу</a>, 
      находящуюся в файле /ftp/pub/sem5/stud/05-1.c, откомпилируем ее и запустим 
      на исполнение. Обратите внимание на использование системного вызова <a href="../../man/umask2.htm">umask()</a> 
      с параметром 0 для того, чтобы права доступа к созданному файлу точно соответствовали 
      указанным в системном вызове <a href="../../man/open.htm">open()</a>.<br>
      &nbsp;</font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3" color="#FF0000"><a name="s0507"></a></font><font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b>Написание, 
      компиляция и запуск программы для чтения информации из файла.</b><br>
      </font> <br>
      <font face="Times New Roman, Times, serif" size="3">Измените предыдущую 
      <a href="../stud/05-1c.htm"> программу</a> так, чтобы она читала записанную 
      ранее в файл информацию и печатала ее на экране. Желательно удалить все 
      лишние операторы.</font><br>
      &nbsp; 
  </LI>
  <LI> <a name="s0508"></a><font color="#FF0000" size="3" face="Times New Roman, Times, serif"><b>Понятие 
    о pipe. Системный вызов pipe().<br>
    </b></font> <br>
    <font face="Times New Roman, Times, serif" size="3"> 
    <p align="JUSTIFY"><a href="../../04/ch4.htm#l04030302a"> <img border="0" src="../../images/bookopen.gif" align="right" vspace="2" alt="Понятие pipe в лекции" hspace="10"></a>Наиболее 
      простым способом для передачи информации с помощью потоковой модели между 
      различными процессами или даже внутри одного процесса в операционной сиcтеме 
      UNIX является pipe (канал, труба, конвейер).<b> <img border="0" src="../../images/znak.gif" align="left" vspace="8" alt="Nota bene" hspace="10"> 
      Важным отличием pip'а от файла является то, что прочитанная информация немедленно 
      удаляется из него и не может быть прочитана повторно.</b> О pip'е можно 
      думать, как о трубе ограниченной емкости, расположенной внутри адресного 
      пространства операционной системы, доступ к входному и выходному отверстию 
      которой осуществляется с помощью системных вызовов. В действительности pipe 
      представляет собой область памяти, недоступную пользовательским процессам 
      напрямую, зачастую организованную в виде кольцевого буфера (хотя существуют 
      и многочисленные другие виды организации). По буферу при операциях чтения 
      и записи перемещаются два указателя, соответствующие входному и выходному 
      потокам. При этом выходной указатель никогда не может перегнать входной 
      и наоборот. Для создания нового экземпляра такого кольцевого буфера внутри 
      операционной системы используется системный вызов <a href="../../man/pipe.htm">pipe()</a>. 
      При своей работе он организует выделение области памяти под буфер и указатели 
      и заносит информацию, соответствующую входному и выходному потокам данных 
      в два элемента таблицы открытых файлов, связывая тем самым с каждым pipe'ом 
      два файловых дескриптора. Для одного из них разрешена только операция чтения 
      из pip'a, а для другого - только операция записи в pipe. Для выполнения 
      этих операций мы можем использовать те же самые системные вызовы <a href="../../man/read.htm">read() 
      и write()</a>, что и при работе с файлами. Естественно, что по окончании 
      необходимости использования входного или/и выходного потока данных, нам 
      необходимо закрыть соответствующий поток с помощью системного вызова <a href="../../man/close.htm">close()</a> 
      для освобождения системных ресурсов. Необходимо отметить, что, когда все процессы, использующие pip'e, закрывают 
    все ассоциированные с ним файловые дескрипторы, операционная система ликвидирует 
    pipe. Таким образом, время существования pip'а в системе не может превышать 
    время жизни процессов, работающих с ним.
    <br>
      &nbsp; 
    </font></LI>
  <LI> 
    <p align="JUSTIFY"><a name="s0509"></a><b> <font face="Times New Roman, Times, serif" size="3" color="#FF0000">Прогон 
      программы для pipe в одном процессе.<br>
      <br>
      </font></b><font face="Times New Roman, Times, serif" size="3"> Достаточно 
      понятной иллюстрацией действий по созданию pip'a, записи в него данных, 
      чтению из него и освобождению выделенных ресурсов может служить <a href="../stud/05-2c.htm">программа</a>, 
      организующая работу с pip'ом в рамках одного процесса. Ее исходный текст 
      расположен в файле /ftp/pub/sem5/stud/05-2.c. Откомпилируйте ее и запустите 
      на исполнение.</font><br>
      &nbsp; 
  </LI>
  <LI> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0510"></a>Организация 
      связи через pipe между процессом-родителем и процессом-потомком. Наследование 
      файловых дескрипторов при вызовах fork() и exec().</b></font><font face="Times New Roman, Times, serif" size="3"><br>
      <br>
      </font> <font face="Times New Roman, Times, serif" size="3">Понятно, что 
      если бы все достойнство pip'ов сводилось к замене функции копирования из 
      памяти в память внутри одного процесса на пересылку информации через операционную 
      систему, то овчинка не стоила бы выделки. Однако таблица открытых файлов 
      наследуется процессом-ребенком при порождении нового процесса системным 
      вызовом <a href="../../man/fork.htm">fork()</a> и входит в состав неизменяемой 
      части системного контекста процесса при системном вызове <a href="../../man/exec.htm">exec()</a></font><font face="Times New Roman, Times, serif" size="3"> 
      (за исключением тех потоков данных, для файловых дескрипторов которых был 
      специальными средствами выставлен признак, побуждающий операционную систему 
      закрыть их при выполнении <a href="../../man/exec.htm">exec()</a>; однако 
      их рассмотрение выходит за рамки нашего курса). Это обстоятельство позволяет 
      организовать передачу информации через pipe между родственными процессами, 
      имеющеми общего прародителя, создавшего pipe. <br>
      &nbsp; </font> 
  </LI>
  <LI> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0511"></a>Прогон 
    программы для организации однонаправленной связи между родственными процессами 
    через pipe. </b></font> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Давайте 
      рассмотрим <a href="../stud/05-3c.htm">программу</a>, осуществляющую однонаправленную 
      связь между процессом-родителем и процессом-ребенком, находящуюся в файле 
      /ftp/pub/sem5/stud/05-3.c, откомпилируем ее и запустим на исполнение.<br>
      <br>
      </font><font face="Times New Roman, Times, serif" size="2"><b><u>Задача 
      повышенной сложности:</u></b> модифицируйте этот пример для связи между 
      собой двух родственных процессов, исполняющих разные программы. <br>
      &nbsp;<br>
      </font> 
  </LI>
  <LI><a name="s0512"></a><font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b>Написание, 
    компиляция и запуск программы для организации двунаправленной связи между 
    родственными процессами через pipe.</b></font>.<br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"><a href="../../04/ch4.htm#l040302"> 
      <img border="0" src="../../images/bookopen.gif" align="right" vspace="2" alt="Направленность связи в лекции" hspace="10"></a>Pipe 
      принципиально служит для организации однонаправленной или симплексной связи. 
      Если бы в <a href="../stud/05-3c.htm">предыдущем примере</a> мы попытались 
      организовать через pipe двустороннюю связь, когда процесс-родитель пишет 
      информацию в pipe, предполагая, что ее получит процесс-ребенок, а затем 
      читает информацию из pip'а, предполагая, что ее записал порожденный процесс, 
      то могла бы возникнуть ситуация, в которой процесс-родитель прочитал бы 
      собственную информацию, а процесс-ребенок не получил бы ничего.</font><font face="Times New Roman, Times, serif" size="3"><font face="Times New Roman, Times, serif" size="3"> 
      Для использования одного pip'a в двух направлениях, необходимы специальные 
      средства синхронизации процессов, о которых речь пойдет на лекциях <a href="../../05/l5.htm">&quot;Алгоритмы 
      синхронизации&quot;</a> и <a href="../../06/l6.htm">&quot;Механизмы синхронизации&quot;</a>. 
      Более простой способ организации двунаправленной связи между родственными 
      процессами заключается в использовании двух pip'ов. Модифицируйте <a href="../stud/05-3c.htm">программу 
      из предыдущего примера</a> для организации такой двусторонней связи, откомпилируйте 
      ее и запустите на исполнение.<br>
      </font></font> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="2"> Необходимо 
      отметить, что в некоторых UNIX-подобных системах (например, в Solaris2) 
      реализованы полностью дуплексные pip'ы <a href="../../literature/literature.htm">[11]</a>. 
      В таких системах для обоих файловых дескрипторов, ассоциированных с pip'ом, 
      разрешены и операция чтения, и операция записи. Однако, такое поведение 
      не характерно для pip'ов и не является переносимым. </font></p>
  </LI>
  <LI> 
    <p align="JUSTIFY"><a name="s0513"></a> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b>Особенности 
      поведения вызовов read() и write() для pip’а.</b></font><font face="Times New Roman, Times, serif" size="3"><br>
      <br>
      Системные вызовы <a href="../../man/read.htm">read() и write()</a> имеют 
      определенные <a href="../../man/read.htm#read1"> особенности поведения</a> 
      при работе с pipe, связанные с его ограниченным размером, задержками в передаче 
      данных и возможностью блокирования обменивающихся информацией процессов. 
      Организация запрета блокирования этих вызовов для pipe выходит за рамки 
      нашего курса.<b><img border="0" src="../../images/znak.gif" align="left" vspace="8"
	   alt="Nota bene" hspace="10"> Будьте внимательны при написании программ, 
      обменивающихся большими объемами информации через pipe. Помните, что за 
      один раз&nbsp; из pip'а может прочитаться меньше информации, чем вы запрашивали, 
      и за один раз в pipe может записаться меньше информации, чем вам хотелось 
      бы. Проверяйте значения, возвращаемые вызовами!</b><br>
      <br>
      <font face="Times New Roman, Times, serif" size="3"> <img border="0" src="../../images/znak.gif" align="left" vspace="8"
	   alt="Nota bene" hspace="10">Одна из особенностей поведения </font>блокирующегося 
      системного вызова <a href="../../man/read.htm">read()</a> связана с попыткой 
      чтения из пустого pip'а. Если есть процессы, у которых этот pipe открыт 
      для записи, то системный вызов блокируется и ждет появления информации. 
      Если таких процессов нет, он вернет значение 0 без блокировки процесса. 
      Эта особенность приводит к <b><u>необходимости закрытия файлового дескриптора, 
      ассоциированного с входным концом pip'a, в процессе, который будет использовать 
      pipe для чтения</u></b> (<b><font color="#008000">close(fd[1]</font></b>) 
      в процессе-ребенке в <a href="../stud/05-3c.htm">программе</a> /ftp/pub/sem5/stud/05-2.c). 
      Аналогичной особенностью поведения при отсутствии процессов, у которых pipe 
      открыт для чтения, обладает и системный вызов <a href="../../man/read.htm">write()</a>, 
      с чем связана<u><b> необходимость закрытия файлового дескриптора, ассоциированного 
      с выходным концом pip'a, в процессе, который будет использовать pipe для 
      записи</b></u> (<b><font color="#008000">close(fd[0])</font></b> в процессе-родителе 
      в той же <a href="../stud/05-3c.htm">программе</a>).<br>
      <br>
      <font face="Times New Roman, Times, serif" size="2"><b><u>Задача повышенной 
      сложности:</u></b> определите размер pipe для вашей операционной системы. 
      </font> <br>
      &nbsp;<br>
      </font> 
  </LI>
  <LI> 
    <P align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0514"></a>Понятие 
      о FIFO. Использование системного вызова mknod для создания FIFO. Функция 
      mkfifo.<br>
      </b></font><br>
      <font face="Times New Roman, Times, serif" size="3"><a name="s0514a"></a> 
      Как мы выяснили, доступ к информации о расположении pip'а в операционной 
      системе и его состоянии может быть осуществлен только через таблицу открытых 
      файлов процесса, создавшего pipe, и через унаследованные от него таблицы 
      открытых файлов процессов-потомков. Поэтому, изложенный выше механизм обмена 
      информацией через pipe справедлив лишь для родственных процессов, имеющих 
      общего прародителя, инициировавшего системный вызов <a href="../../man/pipe.htm">pipe()</a>, 
      или для таких процессов и самого прародителя и не может использоваться для 
      потокового общения с другими процессами. Откровенно говоря, в операционной 
      системе UNIX существует возможность&nbsp;использования pip'а для взаимодействия 
      других процессов, но ее реализация достаточно сложна и лежит далеко за пределами 
      наших занятий.<br>
      <br>
      <a href="../../04/ch4.htm#l04030302b"><img border="0" src="../../images/bookopen.gif" 
    alt="Понятие FIFO в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a>Для 
      организации потокового взаимодействия любых процессов в операционной системе 
      UNIX применяется средство связи, получившее название FIFO (от First Input 
      First Output) или именованный pipe.&nbsp;FIFO во всем подобен pip'у, за 
      одним исключением: данные о&nbsp; расположении FIFO&nbsp; в адресном пространстве 
      ядра и его состоянии процессы могут получать не через родственные связи, 
      а через файловую систему. Для этого при создании именованного pip'a на диске 
      заводится файл специального типа, обращаясь к которому процессы могут узнать 
      интересующую их информацию. Для создания FIFO применяется системный вызов 
      <a href="../../man/mknod.htm">mknod()</a> или существующая в некоторых версиях 
      UNIX функция&nbsp;<a href="../../man/mkfifo.htm">mkfifo()</a>. <img border="0" src="../../images/znak.gif" align="left" vspace="8"
	   alt="Nota bene" hspace="10"><b><u>Следует отметить, что при их работе не 
      происходит действительного выделения области адресного пространства операционной 
      системы под именованный pipe, а только заводится файл-метка, существование 
      которого позволяет осуществить реальную организацию FIFO в памяти при его 
      открытии&nbsp; с помощью уже известного нам ситемного вызова</u> <a href="../../man/open.htm">open()</a></b>. 
      После открытия именованный pipe ведет себя точно так же, как и неименованный. 
      Для дальнейшей работы с ним применяются системные вызовы<a href="../../man/read.htm"> 
      read()</a>, <a href="../../man/read.htm">write()</a> и <a href="../../man/close.htm">close()</a>.&nbsp;
	  Время существования FIFO в адресном пространстве ядра операционной системы, 
      как и в случае pip'а, не может превышать времени жизни последнего из использующих 
      его процессов. Когда все процессы, работающие с FIFO, закрывают все файловые 
      дескрипторы, ассоциированные с ним, система освобождает ресурсы, выделенные 
      под FIFO. Вся непрочитанная информация теряется. В то же время файл-метка 
      остается жить на диске, и он может быть использован для новой реальной организации 
      FIFO в дальнейшем.<br>
      <br>
      Важно понимать, что файл типа FIFO не служит для размещения на диске информации, 
      которая записывается в именованный pipe. <b><img border="0" src="../../images/znak.gif" align="left"
	   vspace="8" alt="Nota bene" hspace="10"></b>Эта информация располагается 
      внутри адресного пространства операционной системы, а файл является только 
      меткой, создающей предпосылки для ее размещения. <b>Не пытайтесь просмотреть 
      содержимое этого файла с помощью Midnight Commander (mc) !!! Это приведет 
      к его глубокому зависанию!</b> <br>
      <br>
      </font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"><b><font face="Times New Roman, Times, serif" size="3" color="#FF0000"><a name="s0515"></a>Особенности 
      поведения вызова open() при открытии FIFO.<br>
      <br>
      </font></b> <font face="Times New Roman, Times, serif" size="3"> Системные 
      вызовы <a href="../../man/read.htm">read() и write()</a> при работе с FIFO 
      имеют такие же <a href="../../man/read.htm#read1">особенности поведения,</a> 
      как и при работе с pip'ом. Системный вызов <a href="../../man/open.htm">open()</a> 
      при открытии FIFO также ведет себя несколько иначе, чем при открытии других 
      типов файлов, что связано с возможностью блокирования выполняющих его процессов. 
      Если FIFO открывается только для чтения, и не задан флаг <font color="#008000"><b>O_NDELAY</b></font>, 
      то процесс, осуществивший системный вызов, блокируется до тех пор, пока 
      какой-либо другой процесс не откроет FIFO на запись. Если флаг <b><font color="#008000">O_NDELAY</font></b> 
      задан, то возвращается значение файлового дескриптора, ассоциированного 
      с FIFO. Если FIFO открывается только для записи, и не задан флаг <font color="#008000"><b>O_NDELAY</b></font>, 
      то процесс, осуществивший системный вызов, блокируется до тех пор, пока 
      какой-либо другой процесс не откроет FIFO на чтение. Если флаг <font color="#008000"><b>O_NDELAY</b></font> 
      задан, то констатируется возникновение ошибки и возвращается значение -1. 
      Задание флага&nbsp;<font color="#008000"><b>O_NDELAY</b></font> в параметрах 
      системного вызова <a href="../../man/open.htm">open()</a> приводит и к тому, 
      что процессу, открывшему FIFO,&nbsp; запрещается блокировка при выполнении 
      последующих операций чтения из этого потока данных и записи в него. <br>
      &nbsp;<br>
      </font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"><b><font face="Times New Roman, Times, serif" size="3" color="#FF0000"><a name="s0516"></a>Прогон 
      программы c FIFO в родственных процессах.<br>
      <br>
      </font></b> <font face="Times New Roman, Times, serif" size="3">Для иллюстрации 
      взаимодействия процессов через FIFO давайте рассмотрим <a href="../stud/05-4c.htm">программу</a>, 
      находящуюся в файле /ftp/pub/sem5/stud/05-4.c, откомпилируем ее и запустим 
      на исполнение.&nbsp;В этой программе информацией между собой обмениваются 
      процесс-родитель и процесс-ребенок. Обратим внимание, что повторный запуск 
      этой программы приведет к ошибке при попытке создания FIFO, так как файл 
      с заданным именем уже существует. Здесь нужно либо удалять его перед каждым 
      прогоном программы с диска вручную , либо после первого запуска модифицировать 
      исходный текст, исключив из него все, связанное с ситемным вызовом <a href="../../man/mknod.htm">mknod()</a>. 
      С системным вызовом, предназначенным для удаления файла при работе процесса, 
      мы познакомимся <a href="../../11/prep/sem11-12.htm#s110810">позже при изучении 
      файловых систем</a>.<br>
      &nbsp;<br>
      </font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0517"></a>Написание, 
      компиляция и запуск программы с FIFO в неродственных процессах.<br>
      <br>
      </b></font><font face="Times New Roman, Times, serif" size="3">Для закрепления 
      полученных знаний напишите на базе предыдущего примера две программы, одна 
      из которых пишет информацию в FIFO, а вторая - читает из него, так чтобы 
      между ними не было ярко выраженных родственных связей (т.е. чтобы одна из 
      них не была потомком другой). <br>
      &nbsp; </font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0518"></a>Неработающий 
      пример для связи процессов на различных компьютерах.<br>
      <br>
      </b></font><font face="Times New Roman, Times, serif" size="3">Если у вас 
      есть возможность, найдите два компьютера, имеющих разделяемую файловую систему 
      (например, смонтированную с помощью NFS), и запустите на них программы из 
      предыдущего раздела так, чтобы каждая программа работала на своем компьютере, 
      а FIFO создавалось на разделяемой файловой системе. Хотя оба процесса видят 
      файл с типом FIFO, взаимодействия между ними не происходит, так как они 
      функционируют в физически разных адресных пространствах и пытаются открыть 
      FIFO внутри разных операционных систем.&nbsp; <br>
      </font> 
  </LI>
</ol>
<font face="Times New Roman" size="3"><font face="Times New Roman, Times, serif" size="3">
  
<P align="center"><a href="../../03/prep/sem3-4.htm"> Предыдущий семинар</a> | <a href="../../os.html">Программа курса</a> | 
 <a href="../../06/prep/sem6-7.htm"> Следующий семинар</a></P>
  </font>
</font></BODY>
</HTML>
