<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Лекция 6</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
<P ALIGN="CENTER"><B> </B></P>
<P ALIGN="CENTER"><B><font face="Times New Roman"  size=4>Глава 6. Механизмы синхронизации </FONT></B></p>
<B><FONT> </font></B>
<P align="center"><a href="../05/ch5.htm"> Предыдущая глава</a> | <a href="../os.html">Программа курса</a> | 
 <a href="../07/ch7.htm"> Следующая глава</a></P>

<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Рассмотренные в конце предыдущей 
  главы алгоритмы хотя и являются корректными, но достаточно громоздки и не обладают 
  элегантностью. Более того, процедура ожидания входа в критический участок включает 
  в себя достаточно длительное вращение процесса в пустом цикле, вхолостую пожирая 
  драгоценное время процессора. Существуют и другие серьезные недостатки у алгоритмов, 
  построенных средствами обычных языков программирования. Допустим, что в вычислительной 
  системе находятся два взаимодействующих процесса: один из них — <b><font color="#008000">H</font></b> 
  — с высоким приоритетом, другой —<b><font color="#008000"> L</font></b> — с 
  низким приоритетом. Пусть планировщик устроен так, что процесс с высоким приоритетом 
  вытесняет низкоприоритетный процесс всякий раз, когда он готов к исполнению, 
  и занимает процессор на все время своего CPU burst (если не появится процесс 
  с еще большим приоритетом). Тогда в случае, когда процесс <b><font color="#008000">L</font></b> 
  находится в своей критической секции, а процесс<b><font color="#008000"> H</font></b>, 
  получив процессор, подошел ко входу в критическую область, мы получаем тупиковую 
  ситуацию. Процесс <b><font color="#008000">H </font></b>не может войти в критическую 
  область, находясь в цикле, а процесс<b><font color="#008000"> L</font></b> не 
  получает управления, чтобы покинуть критический участок.</font> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Для того чтобы устранить 
  возникновение подобных проблем были разработаны различные механизмы синхронизации 
  более высокого уровня: семафоры, мониторы и сообщения, рассмотрению которых 
  и посвящена данная глава.</FONT></P>

  
 
  
<P ALIGN="CENTER"> <FONT FACE="Times New Roman" size=3> <B><a name="l0601"></a>6.1. 
  Семафоры</B></FONT> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Одним из первых механизмов, 
  предложенных для синхронизации поведения процессов, стали семафоры, концепцию 
  которых описал Дейкстра (Dijkstra) в 1965 году.</font></P>

   
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman" size=3> <a name="l060101"></a>6.1.1. 
  Концепция семафоров</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Семафор представляет собой 
  целую переменную, принимающую неотрицательные значения, доступ любого процесса 
  к которой, за исключением момента ее инициализации, может осуществляться только 
  через две атомарные операции: <i><b><font color="#008000">P</font></b></i> (от 
  датского слова proberen — проверять) и <i><b><font color="#008000">V</font></b></i> 
  (от verhogen — увеличивать). Классическое определение этих операций выглядит 
  следующим образом:</FONT></P>
  
<I><FONT FACE="Times New Roman" size=3> </font></i>
<table align ="center" width="40%" border="0" cellspacing="2" cellpadding="2">
  <tr> 
    <td valign="top" width="18%"><i><b><font face="Times New Roman" size="3" color="#008000">P(S):</font></b></i></td>
    <td width="82%"><i><b><font face="Times New Roman" size="3" color="#008000">пока 
      S &lt;= 0 процесс блокируется; <br>
      S = S – 1; </font></b></i></td>
  </tr>
  <tr> 
    <td width="18%"><i><b><font face="Times New Roman" size="3" color="#008000">V(S):</font></b></i></td>
    <td width="82%"><i><b><font face="Times New Roman" size="3" color="#008000">S 
      = S + 1; </font></b></i></td>
  </tr>
</table>
<I><FONT FACE="Times New Roman" size=3> </font></i> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3> Эта запись означает следующее: 
  при выполнении операции <i><b><font color="#008000">P</font></b></i> над семафором 
  <i> <b> <font color="#008000">S</font></b></i> сначала проверяется его значение. 
  Если оно больше <b><font color="#008000">0</font></b>, то из <b><font color="#008000"><i>S</i></font></b> 
  вычитается<b><font color="#008000"> 1</font></b>. Если оно меньше или равно<b><font color="#008000"> 
  0</font></b>, то процесс блокируется до тех пор, пока <b><font color="#008000"><i>S</i></font></b> 
  не станет больше <b><font color="#008000">0</font></b>, после чего из <i><b><font color="#008000">S</font></b></i> 
  вычитается <b><font color="#008000">1</font></b>. При выполнении операции <i><b><font color="#008000">V</font></b></i> 
  над семафором<i><b><font color="#008000"> S</font></b></i> к его значению просто 
  прибавляется <b><font color="#008000">1</font></b>.</font> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3><a href="../08/prep/sem8.htm#s0801">
<img border="0" src="../images/computer.gif" align="right" alt="Семафоры в UNIX" vspace="4" width="48" height="48">
</a> Подобные переменные-семафоры 
  могут быть с успехом применены для решения различных задач организации взаимодействия 
  процессов. В ряде языков программирования они были непосредственно введены в 
  синтаксис языка (например, в ALGOL-68), в других случаях применяются через использование 
  системных вызовов. Соответствующая целая переменная располагается внутри адресного 
  пространства ядра операционной системы. Операционная система обеспечивает атомарность 
  операций<i><b><font color="#008000"> P</font></b></i> и <i><b><font color="#008000">V</font></b></i>, 
  используя, например, метод запрета прерываний на время выполнения соответствующих 
  системных вызовов. Если при выполнении операции <i><b><font color="#008000">P</font></b></i> 
  заблокированными оказались несколько процессов, то порядок их разблокирования 
  может быть произвольным, например, FIFO.</FONT></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman" size=3><a name="l060102"></a>6.1.2. 
  Решение проблемы producer-consumer</FONT><FONT FACE="Times New Roman" size=3> 
  с помощью семафоров</font></B> <FONT size=3> </FONT> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Одной из типовых задач, 
  требующих организации взаимодействия процессов, является задача producer-consumer 
  (</FONT><FONT FACE="Times New Roman" size=3>производитель-потребитель). Пусть 
  два процесса обмениваются информацией через буфер ограниченного размера. Производитель 
  закладывает информацию в буфер, а потребитель извлекает ее оттуда. Грубо говоря, 
  на этом уровне деятельность потребителя и производителя можно описать следующим 
  образом.</font></P>
<table align="center" width="60%" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top"><i><b><font face="Times New Roman" size="3" color="#008000">Producer:</font></b></i></td>
    <td><font face="Times New Roman" size=3>
      <dir><i><b><font color="#008000">while(1) {</font> </b> </i> 
        <dir><i><b><font color="#008000"> produce_item; <br>
          put_item; </font></b></i></dir>
        <i><b><font color="#008000">} </font></b></i></dir>
      </font></td>
  </tr>
  <tr>
    <td valign="top"><i><b><font face="Times New Roman" size="3" color="#008000">Consumer:</font></b></i></td>
    <td>
      <p> 
      <font face="Times New Roman" size=3> 
      <dir><i><b><font color="#008000">while(1) { </font> </b> </i> 
        <dir><i><b><font color="#008000"> get_item; <br>
          consume_item; </font></b></i></dir>
        <i><b><font color="#008000">} </font></b></i></dir>
      </font></td>
  </tr>
</table>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Если буфер забит, то производитель 
  должен ждать, пока в нем появится место, чтобы положить туда новую порцию информации. 
  Если буфер пуст, то потребитель должен дожидаться нового сообщения. Как можно 
  реализовать эти условия с помощью семафоров? Возьмем три семафора <i><b><font color="#008000">empty</font></b></i>, 
  <i> <b> <font color="#008000">full</font></b></i> и <i><b><font color="#008000">mutex</font></b></i>. 
  Семафор<i><b><font color="#008000"> full</font></b></i> будем использовать для 
  гарантии того, что потребитель будет ждать, пока в буфере появится информация. 
  Семафор <i><b><font color="#008000">empty</font></b></i> будем использовать 
  для организации ожидания производителя при заполненном буфере, а семафор <i><b><font color="#008000">mutex</font></b></i> 
  - для организации взаимоисключения на критических участках, которыми являются 
  действия <i><b><font color="#008000">put_item</font></b></i> и <i><b><font color="#008000">get_item</font></b></i> 
  (операции положить информацию и взять информацию не могут пересекаться, так 
  как тогда возникнет опасность искажения информации). Тогда решение задачи выглядит 
  так:</FONT></p>
<FONT FACE="Times New Roman" size=3><DIR> 
  <DIR> 
    <dir><i><b><font color="#008000"> Semaphore mutex = 1;<br>
      Semaphore empty = N, где N – емкость буфера;<br>
      Semaphore full = 0; <br>
      <br>
      </font></b></i></DIR>
    <i><b><font color="#008000">Producer: <br>
    </font> </b>
    </i><dir><i><b><font color="#008000"> while(1) { <br>
      </font> </b>
      </i><dir><i><b><font color="#008000"> produce_item; <br>
        P(empty); <br>
        P(mutex); <br>
        put_item; <br>
        V(mutex); <br>
        V(full); <br>
        </font></b></i></dir>
      <i><b><font color="#008000">} <br>
      <br>
      </font></b></i></dir>
    <i><b><font color="#008000">Consumer: <br>
    </font> </b>
    </i><dir><i><b><font color="#008000"> while(1) { <br>
      </font> </b>
      </i><dir><i><b><font color="#008000"> P(full); <br>
        P(mutex); <br>
        put_item; <br>
        V(mutex); <br>
        V(empty); <br>
        consume_item; <br>
        </font></b></i></dir>
      <i><b><font color="#008000">} </font></b></i></dir>
  </dir>
   </dir></font>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Легко убедиться, что это 
  действительно корректное решение поставленной задачи. Попутно заметим, что семафоры 
  использовались здесь для достижения двух целей: организации взаимоисключения 
  на критическом участке и синхронизации скорости работы процессов.</FONT></P>

  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman" size=3><a name="l0602"></a>6.2. 
  Мониторы</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Хотя решение задачи producer-consumer 
  с помощью семафоров выглядит достаточно элегантно, программирование с их использованием 
  требует повышенной осторожности и внимания, чем, отчасти, напоминает программирование 
  на языке ассемблера. Допустим, что в рассмотренном примере мы случайно поменяли 
  местами операции<i><b><font color="#008000"> P</font></b></i>, сначала выполняя 
  ее для семафора <i><b><font color="#008000">mutex</font></b></i>, а уже затем 
  для семафоров <i><b><font color="#008000">full</font></b></i> и <i><b><font color="#008000">empty</font></b></i>. 
  Допустим теперь, что потребитель, войдя в свой критический участок (<i><b><font color="#008000">mutex</font></b></i> 
  сброшен), обнаруживает, что буфер пуст. Он блокируется и начинает ждать появления 
  сообщений. Но производитель не может войти в критический участок, для передачи 
  информации, так как тот заблокирован потребителем. Получаем тупиковую ситуацию.</font></P>

  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>В сложных программах произвести 
  анализ правильности использования семафоров с карандашом в руках становится 
  очень непростым занятием. В то же время обычные способы отладки программ зачастую 
  не дают результата, поскольку возникновение ошибок зависит от interleaving’а 
  атомарных операций, и ошибки могут быть трудно воспроизводимы. Для того чтобы 
  облегчить труд программистов, в 1974 году Хором (Hoare) был предложен механизм 
  еще более высокого уровня, чем семафоры, получивший название мониторов. Мы с 
  вами рассмотрим конструкцию, несколько отличающуюся от оригинальной. </font></P>

  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Мониторы представляют 
    собой тип данных, который может быть с успехом внедрен в объектно-ориентированные 
    языки программирования. Монитор обладает своими собственными переменными, 
    определяющими его состояние. Значения этих переменных извне монитора могут 
    быть изменены только с помощью вызова функций-методов, принадлежащих монитору. 
    В свою очередь,  эти 
    функции-методы могут использовать в своей работе только данные, находящиеся 
    внутри монитора и свои параметры. На абстрактном уровне можно описать структуру 
    монитора следующим образом:</font></P>
   
<P ALIGN="JUSTIFY">
<I><FONT FACE="Times New Roman" size=3>
<dir> 
  <dir> 
    <dir><b><font color="#008000"> monitor monitor_name { <br>
      <br>
      </font> </b>
      <dir><b><font color="#008000"> описание переменных ;<br>
        <br>
        void m<sub>1</sub>(...){...<br>
        }<br>
        void m<sub>2</sub>(...){...<br>
        }<br>
        ...<br>
        void m<sub>n</sub>(...){...<br>
        }<br>
        <br>
        {<br>
        </font> </b>
        <dir><b><font color="#008000">блок инициализации внутрениих переменных 
          ;<br>
          </font></b></dir>
        <b><font color="#008000">}<br>
        </font></b></dir>
      <b><font color="#008000">}</font></b><br>
</dir></dir></dir></font></i>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Здесь функции <i><b><font color="#008000">m<sub>1</sub>,..., 
  m<sub>n</sub></font></b></i> представляют собой функции-методы монитора, а блок 
  инициализации внутренних переменных содержит операции, которые выполняются только 
  один раз: при создании монитора или при самом первом вызове какой-либо функции-метода 
  до ее исполнения.</font></P>
  
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Важной особенностью мониторов 
  является то, что в любой момент времени только один процесс может быть активен, 
  т. е. находиться в состоянии <i><b>готовность</b></i> или<b> <i>исполнение</i></b>, 
  внутри данного монитора. Поскольку мониторы представляют собой особые конструкции 
  языка программирования, то компилятор может отличить вызов функции, принадлежащей 
  монитору, от вызовов других функций и обработать его специальным образом, добавив 
  к нему пролог и эпилог, реализующий взаимоисключение. Так как обязанность конструирования 
  механизма взаимоисключений возложена на компилятор, а не на программиста, работа 
  программиста при использовании мониторов существенно упрощается, а вероятность 
  появления ошибок становится меньше.</font> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Однако одних только взаимоисключений 
  не достаточно для того, чтобы в полном объеме реализовать решение задач, возникающих 
  при взаимодействии процессов. Нам нужны еще и средства организации очередности 
  процессов, подобно семафорам <I><font color="#008000"><b>full</b></font></I> 
  и<b><font color="#008000"> <I>empty</I></font></b> в предыдущем примере. Для 
  этого в мониторах было введено понятие <i>условных переменных (condition variables)</i>, 
  над которыми можно совершать две операции<b><font color="#008000"> <i>wait</i></font></b> 
  и<b><font color="#008000"> <i>signal</i></font></b>, до некоторой степени похожие 
  на операции <i><b><font color="#008000">P</font></b></i> и <i><b><font color="#008000">V 
  </font></b></i>над семафорами. </font></P>

  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Если функция монитора не 
  может выполняться дальше, пока не наступит некоторое событие, она выполняет 
  операцию <i><font color="#008000"><b>wait</b></font></i> над какой-либо условной 
  переменной. При этом процесс, выполнивший операцию <i><font color="#008000"><b>wait</b></font></i>, 
  блокируется, становится неактивным, и другой процесс получает возможность войти 
  в монитор.</font></P>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Когда ожидаемое событие 
  происходит, другой процесс внутри функции-метода совершает операцию <i><font color="#008000"><b>signal 
  </b></font></i>над той же самой условной переменной. Это приводит к пробуждению 
  ранее заблокированного процесса, и он становится активным. Если несколько процессов 
  дожидались операции <i><font color="#008000"><b>signal</b></font> </i>для этой 
  переменной, то активным становится только один из них. Что нам нужно предпринять 
  для того, чтобы у нас не оказалось двух процессов, разбудившего и пробужденного, 
  одновременно активных внутри монитора? Хор предложил, чтобы пробужденный процесс 
  подавлял исполнение разбудившего процесса, пока он сам не покинет монитор. Несколько 
  позже Хансен (Hansen) </FONT><FONT FACE="Times New Roman" size=3>предложил другой 
  механизм: разбудивший процесс покидает монитор немедленно после исполнения операции 
  <i> <b><font color="#008000">signal</font></b></I>. Мы будем придерживаться 
  подхода Хансена.</font></P>
   <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Давайте применим концепцию 
    мониторов к решению задачи производитель-потребитель .</font></P>
  
<P ALIGN="JUSTIFY">
<FONT FACE="Times New Roman" size=3><i>
<dir> 
  <dir> 
    <dir><b><font color="#008000"> monitor ProducerConsumer { <br>
      </font> </b>
      <dir><b><font color="#008000"> condition full, empty; <br>
        int count; <br>
        <br>
        void put() { <br>
        </font> </b>
        <dir><b><font color="#008000"> if(count == N) full.wait; <br>
          put_item; <br>
          count += 1; <br>
          if(count == 1) empty.signal; <br>
          </font></b></dir>
        <b><font color="#008000">} <br>
        <br>
        void get() { <br>
        </font> </b>
        <dir><b><font color="#008000"> if (count == 0) empty.wait; <br>
          get_item(); <br>
          count -= 1; <br>
          if(count == N-1) full.signal; <br>
          </font></b></dir>
        <b><font color="#008000">} <br>
        <br>
        { <br>
        </font> </b>
        <dir><b><font color="#008000"> count = 0; <br>
          </font></b></dir>
        <b><font color="#008000">} <br>
        </font></b></dir>
      <b><font color="#008000">} <br>
      <br>
      </font></b></dir>
    <b><font color="#008000">Producer: <br>
    </font> </b>
    <dir><b><font color="#008000"> while(1) { <br>
      </font> </b>
      <dir><b><font color="#008000"> produce_item; <br>
        ProducerConsumer.put(); <br>
        </font></b></dir>
      <b><font color="#008000">} <br>
      <br>
      </font></b></dir>
    <b><font color="#008000">Consumer: <br>
    </font> </b>
    <dir><b><font color="#008000"> while(1) { <br>
      </font> </b>
      <dir><b><font color="#008000"> ProducerConsumer.get(); <br>
        consume_item; <br>
        </font></b></dir>
      <b><font color="#008000">} </font></b><br>
</dir></dir></dir></i></font>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Легко убедиться, что 
    приведенный пример действительно решает поставленную задачу. </FONT></P>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Реализация мониторов требует 
  разработки специальных языков программирования и компиляторов для них. Мониторы 
  встречаются в таких языках как параллельный Евклид, параллельный Паскаль, Java 
  и т.д. Эмуляция мониторов с помощью системных вызовов для обычных широко используемых 
  языков программирования не так проста, как эмуляция семафоров. Поэтому можно 
  пользоваться еще одним механизмом со скрытыми взаимоисключеньями, механизмом, 
  о котором мы уже упоминали, — передачей сообщений.</FONT></P>
  
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman" size=3><a name="l0603"></a>6.3. 
  Сообщения</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3><a href="../09/prep/sem9.htm#s0902">
<img border="0" src="../images/computer.gif" align="right" alt="Сообщения в UNIX" vspace="4" width="48" height="48">
</a>Для прямой и непрямой адресации 
  достаточно двух примитивов, чтобы описать передачу сообщений по линии связи 
  — <i><font color="#008000"><b>send</b></font> </i>и <i><font color="#008000"><b>receive</b></font></i>. 
  В случае прямой адресации мы будем обозначать их так:</FONT></P>
<font face="Times New Roman" size=3>
<dir><i><b><font color="#008000">send(P, message)</font></b></i>—послать сообщение 
  message процессу <b><font color="#008000">P</font></b>;<br>
  <i><b><font color="#008000">receive(Q, message)</font></b></i> — получить сообщение 
  message от процесса <b><font color="#008000">Q</font></b>.</dir>
</font>
<P><FONT FACE="Times New Roman" size=3>В случае непрямой адресации мы будем 
    обозначать их так:</font></P>
   
<font face="Times New Roman" size=3>
<dir> <i><b><font color="#008000">send(A, message)</font></b></i> — послать сообщение 
  message в почтовый ящик<b><font color="#008000"> A</font></b>;<br>
  <i><b><font color="#008000">receive(A, message)</font></b></i> — получить сообщение 
  message из почтового ящика <b><font color="#008000">A</font></b>.</dir>
</font>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Примитивы <i><font color="#008000"><b>send</b></font> 
  </i>и <i><font color="#008000"><b>receive</b></font> </i>уже имеют скрытый от 
  наших глаз механизм взаимоисключения. Более того, в большинстве систем они уже 
  имеют и скрытый механизм блокировки при чтении из пустого буфера и при записи 
  в полностью заполненный буфер. Реализация решения задачи producer-consumer </FONT><FONT FACE="Times New Roman" size=3>для 
  таких примитивов становится неприлично тривиальной. Надо отметить, что, несмотря 
  на простоту использования, передача сообщений в пределах одного компьютера происходит 
  существенно медленнее, чем работа с семафорами и мониторами.</font></P>
  
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman" size=3><a name="l0604"></a>6.4. 
  Эквивалентность семафоров, мониторов и сообщений</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Мы рассмотрели три высокоуровневых механизма, 
  использующихся для организации взаимодействия процессов. Можно показать, что 
  в рамках одной вычислительной системы, когда процессы имеют возможность использовать 
  разделяемую память, все они эквивалентны между собой. Это означает, что любые 
  два из предложенных механизмов могут быть реализованы на базе третьего, оставшегося 
  механизма.</FONT></P>

  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman" size=3><a name="l060401"></a>6.4.1. 
  Реализация мониторов и передачи сообщений с помощью семафоров</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Рассмотрим сначала, как 
  реализовать мониторы с помощью семафоров. Для этого нам нужно уметь реализовывать 
  взаимоисключения при входе в монитор и условные переменные. Возьмем семафор 
  <i><font color="#008000"><b>mutex</b></font></i> с начальным значением <b><font color="#008000">1</font></b> 
  для реализации взаимоисключения при входе в монитор и по одному семафору <b><font color="#008000"><i>c<sub>i</sub></i></font></b></FONT><FONT FACE="Times New Roman" size=3> 
  для каждой условной переменной. Когда процесс входит в монитор, компилятор будет 
  генерировать вызов функции <i><font color="#008000"><b>monitor_enter</b></font></i>, 
  которая выполняет операцию <i><font color="#008000"><b>P </b></font></i>над 
  семафором<b><font color="#008000"> <i>mutex </i></font></b>для данного монитора. 
  При нормальном выходе из монитора (то есть при выходе без вызова операции <i><font color="#008000"><b>signal</b></font> 
  </i>для условной переменной) компилятор будет генерировать вызов функции <i><font color="#008000"><b>monitor_exit</b></font></i>, 
  которая выполняет операцию <i><font color="#008000"><b>V </b></font></i>над 
  этим семафором.</FONT></P>
<P>
<FONT FACE="Times New Roman" size=3><i>
<dir> 
  <dir> 
    <dir><b><font color="#008000"> Semaphore mutex = 1; <br>
      <br>
      void monitor_enter(){ <br>
      </font> </b>
      <dir><b><font color="#008000"> P(mutex); <br>
        </font></b></dir>
      <b><font color="#008000">} <br>
      <br>
      void monitor_exit(){ <br>
      </font> </b>
      <dir><b><font color="#008000"> V(mutex); <br>
        </font></b></dir>
      <b><font color="#008000">} <br>
      <br>
      Semaphore c<sub>i</sub> = 0; <br>
      <br>
      void wait(){ <br>
      </font> </b>
      <dir><b><font color="#008000"> V(mutex); <br>
        P(c<sub>i </sub>); <br>
        </font></b></dir>
      <b><font color="#008000">} <br>
      <br>
      void signal_exit(){ <br>
      </font> </b>
      <dir><b><font color="#008000"> V(c<sub>i</sub> ); <br>
        </font></b></dir>
      <b><font color="#008000">} </font></b><br>
  </dir></dir></dir></i></font>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Заметим, что при выполнении 
  функции <i><font color="#008000"><b>signal_exit</b></font></i>, </FONT><FONT FACE="Times New Roman" size=3>процесс 
  покидает монитор без увеличения значения семафора <i><font color="#008000"><b>mutex</b></font></i>, 
  не разрешая тем самым всем процессам, кроме разбуженного, войти в монитор. Это 
  увеличение совершит разбуженный процесс, когда покинет монитор нормальным способом, 
  либо когда выполнит новую операцию <i><font color="#008000"><b>wait</b></font></i> 
  над какой-либо условной переменной.</font></P>
 
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Рассмотрим теперь, как 
  реализовать передачу сообщений, используя семафоры. Для простоты опишем реализацию 
  только одной очереди сообщений. Выделим в разделяемой памяти достаточно большую 
  область под хранение сообщений, там же будем записывать, сколько пустых и заполненных 
  ячеек находится в буфере, хранить ссылки на списки процессов, ожидающих чтения 
  и памяти. Взаимоисключение при работе с разделяемой памятью будем обеспечивать 
  семафором<b><font color="#008000"> <i>mutex</i></font></b>. </FONT><FONT FACE="Times New Roman" size=3>Также 
  заведем по одному семафору <i><font color="#008000"><b>c<sub>i</sub></b></font> 
  </i>на взаимодействующий процесс для того, чтобы обеспечивать блокирование процесса 
  при попытке чтения из пустого буфера или при попытке записи в переполненный 
  буфер. Поглядим, как такой механизм будет работать. Начнем с процесса, желающего 
  получить сообщение. </font></P>
  
   
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Процесс-получатель, прежде 
  всего, выполняет операцию <i><font color="#008000"><b>P(mutex)</b></font>, </i>получая 
  в монопольное владение разделяемую память.<i> </i>После чего он изучает наличие 
  сообщений в буфере. Если сообщений нет, то он заносит себя в список процессов, 
  ожидающих сообщения, выполняет <i><font color="#008000"><b>V(mutex) </b></font></i>и 
  <i><font color="#008000"><b>P(c<sub>i </sub>)</b></font>. </i>Если сообщение 
  в буфере есть, то он читает сообщение, изменяет счетчики буфера и проверяет, 
  есть ли процессы в списке процессов, жаждущих записи. Если такой процесс есть, 
  то он удаляется из этого списка, выполняется <i><font color="#008000"><b>V</b></font> 
  </i>для его семафора<i><font color="#008000"><b> c<sub>i</sub></b></font></i>, 
  и мы выходим из критического района<i>. </i>Проснувшийся процесс начинает выполняться 
  в критическом районе, так как<b><font color="#008000"> <i>mutex </i></font></b>у 
  нас имеет значение <b><font color="#008000">0</font></b>, и никто более не может 
  попасть в критический район. При выходе из критического района именно разбуженный 
  процесс произведет вызов <i> <b><font color="#008000">V(mutex)</font></b>.</i></font></P>
 
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Как строится работа процесса-отправителя? 
  Процесс, посылающий сообщение, тоже ждет, пока он не сможет иметь монополию 
  на использование разделяемой памяти, выполнив операцию <i><font color="#008000"><b>P(mutex)</b></font>.</i> 
  Далее он проверяет наличие места в буфере и, если оно есть, помещает сообщение 
  в буфер, изменяет счетчики и смотрит, есть ли процессы, ожидающие сообщения. 
  Если нет, выполняет <i><font color="#008000"><b>V(mutex)</b></font></i> и выходит 
  из критической области, если есть, будит один из них, вызывая <i><font color="#008000"><b>V(c<sub>i</sub> 
  )</b></font>,</i> с одновременным удалением этого процесса из списка процессов, 
  ожидающих сообщений, и выходит из критического региона без вызова <i><font color="#008000"><b>V(mutex</b></font></i><b><font color="#008000">)</font></b></FONT><FONT FACE="Times New Roman" size=3>, 
  предоставляя тем самым возможность разбуженному процессу прочитать сообщение. 
  Если места в буфере нет, то процесс-отправитель заносит себя в очередь процессов, 
  ждущих возможности записи, и вызывает <i><font color="#008000"><b>V(mutex)</b></font></i>и 
  <i><font color="#008000"><b>P(c<sub>i </sub>)</b></font></i>.</font></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman" size=3><a name="l060402"></a>6.4.2. 
  Реализация семафоров и передачи сообщений с помощью мониторов</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Нам достаточно показать, 
    что с помощью мониторов можно реализовать семафоры, так как, из семафоров 
    получить сообщения мы уже умеем.</FONT></P>
  
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Самый простой способ такой 
  реализации выглядит следующим образом. Заведем внутри монитора переменную-счетчик, 
  связанный с эмулируемым семафором список блокируемых процессов и по одной условной 
  переменной на каждый процесс. При выполнении операции <i><font color="#008000"><b>P</b></font></i> 
  над семафором вызывающий процесс проверяет значение счетчика. Если оно больше 
  нуля, уменьшает его на <b><font color="#008000">1</font></b> и выходит из монитора. 
  Если оно равно <b><font color="#008000">0</font></b>, процесс добавляет себя 
  в очередь процессов, ожидающих события, и выполняет операцию <i><font color="#008000"><b>wait</b></font></i> 
  над своей условной переменной. При выполнении операции <i><font color="#008000"><b>V</b></font></i> 
  над семафором процесс увеличивает значение счетчика, проверяет, есть ли процессы, 
  ожидающие этого события, если есть, удаляет один из них из списка и выполняет 
  операцию <i><font color="#008000"><b>signal</b></font></i> для условной переменной, 
  соответствующей процессу.</font></P>
 
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman" size=3><a name="l060403"></a>6.4.3. 
  Реализация семафоров и мониторов с помощью очередей сообщений</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Покажем, наконец, как реализовать 
  семафоры с помощью очередей сообщений. Для этого воспользуемся более хитрой 
  конструкцией, введя новый синхронизирующий процесс. Этот процесс имеет счетчик 
  и очередь процессов, ожидающих включения семафора. Для того чтобы выполнить 
  операции<b><font color="#008000"> <i>P</i></font></b><i> </i>и <i><font color="#008000"><b>V</b></font></i>, 
  процессы посылают синхронизирующему процессу сообщения, в которых говорится, 
  чего они желают, после чего ожидают получения подтверждения от синхронизирующего 
  процесса.</font></P>

<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>После прибытия сообщения 
  синхронизирующий процесс проверяет значение счетчика, чтобы выяснить, можно 
  ли совершить требуемую операцию. Операция <i><font color="#008000"><b>V</b></font> 
  </i>всегда может быть совершена, в то время как операция <i><font color="#008000"><b>P</b></font></i> 
  может потребовать блокирования процесса. Если операция может быть совершена, 
  то она выполняется, и синхронизирующий процесс посылает подтверждающее сообщение. 
  Если процесс должен быть блокирован, то его идентификатор заносится в очередь 
  блокированных процессов и подтверждение не посылается. Позднее, когда кто-либо 
  из других процессов выполнит операцию <i><font color="#008000"><b>V</b></font>,</i> 
  один из блокированных процессов удаляется из очереди ожидания и получает соответствующее 
  подтверждение.</font></P>

<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Поскольку мы показали ранее, 
  как из семафоров построить мониторы, мы доказали эквивалентность мониторов, 
  семафоров и сообщений.</FONT></P>

  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman" size=3><a name="l0605"></a>6.5. 
  Резюме</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Для организации синхронизации 
  процессов могут применяться специальные механизмы высокого уровня, блокирующие 
  процесс, ожидающий входа в критическую секцию или наступления своей очереди 
  для использования совместного ресурса. К таким механизмам относятся
  <a href="#l0601">семафоры</a>, 
  <a href="#l0602">мониторы</a> и <a href="#l0603">сообщения</a>. Все эти конструкции 
  являются <a href="#l0604">эквивалентными</a>, т.&nbsp;е. используя любую из 
  них, можно реализовать две оставшихся.</FONT></P>
  <P align="center"><a href="../05/ch5.htm"> Предыдущая глава</a> | <a href="../os.html">Программа курса</a> | 
 <a href="../07/ch7.htm"> Следующая глава</a></P>

</BODY>
</HTML>
