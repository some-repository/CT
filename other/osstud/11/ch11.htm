<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Глава 11</TITLE>
</HEAD>
<body bgcolor="#FFFFFF">
 <basefont face="Times New Roman, sans-serif, Courier, mono" size="3">
<h3 align="center"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="6">
Часть  IV.  Файловые системы </font></B></h3>

<p align="center"><a href="../10/ch10.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../12/ch12.htm"> Следующая глава</a></p>



 <p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Все компьютерные приложения нуждаются  в хранении и обновлении 
  информации.  Возможности оперативной памяти для хранения информации ограничены. 
  Во-первых, оперативная память обычно теряет свое содержимое после отключения 
  питания, а во-вторых, объем обрабатываемых данных зачастую превышает ее возможности. 
  Кроме того, информацию желательно иметь в виде, независимом от процессов. Поэтому 
  принято хранить данные  на внешних носителях (обычно это диски) в единицах, 
  называемых файлами.  В большинстве компьютерных систем предусмотрены устройства 
  внешней (вторичной) памяти, большой емкости, на которых можно хранить огромные 
  объемы данных. Однако характеристики доступа к таким устройствам существенно 
  отличаются от характеристик доступа к основной памяти. Чтобы повысить эффективность 
  использования этих устройств, был разработан ряд специфичных для них структур 
  данных и алгоритмов.</font></p>
<p align=left ><b><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="4">Глава 11.  Файлы с точки зрения пользователя</font></b></p>
<p align=left ><b><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
<a name="l1101">11.1 Введение</a></font></b></p>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">История систем управления данными во внешней памяти начинается 
  еще с магнитных лент, но современный облик  они приобрели с появлением магнитных 
  дисков. До этого каждая прикладная программа сама решала проблемы именования 
  данных и структуризации данных во внешней памяти. Это затрудняло поддержание 
  на внешнем носителе  нескольких архивов долговременно хранимой информации. Историческим  
  шагом явился переход к  использованию централизованных систем управления файлами. 
  Система управления файлами берет на себя распределение внешней памяти, отображение 
  имен файлов в адреса внешней памяти и обеспечение доступа к данным.</font></p>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><i>Файловая система</i> - это часть операционной системы, 
  назначение которой состоит в том, чтобы  организовать эффективную работу с данными, 
  хранящимися во внешней памяти и обеспечить пользователю удобный интерфейс при 
  работе с этими данными. Организовать хранение информации на  магнитном диске 
  непросто.  Это требует хорошего знания устройства контроллера диска, особенностей 
  работы с его регистрами и.т. д. (этим обычно занимается компонент системы ввода-вывода 
  ОС, называемый драйвером диска). Для того чтобы избавить пользователя компьютера 
  от сложностей взаимодействия с аппаратурой и была придумана ясная абстрактная 
  модель файловой системы. Операции записи или чтения файла концептуально проще, 
  чем  низкоуровневые операции работы с устройствами. <br><br>
Основная идея использования внешней памяти состоит в следующем. ОС делит ее 
  на блоки фиксированного размера, например, 4096 байт. С точки зрения пользователя 
  каждый файл состоит из набора индивидуальных элементов, называемых <i>записями 
  </i>(например, характеристика какого-нибудь объекта). Каждый файл хранится 
  в виде определенной последовательности блоков (не обязательно смежных); каждый 
  блок хранит целое число записей. В некоторых ОС (MS-DOS) адреса блоков, содержащих данные 
  файла, могут быть организованы в связный список и вынесены в отдельную таблицу 
  в памяти. В других ОС (Unix), адреса блоков данных файла 
  хранятся в отдельном блоке внешней памяти (так называемом индексе или индексном 
  узле).  Этот прием называется <i>индексацией</i> и является наиболее распространенным 
  для приложений, требующих произвольного доступа к записям файлов. Индекс файла 
  состоит из списка элементов, каждый из которых содержит номер блока в файле 
  и указание о местоположении данного блока. В современных ОС файлы  обычно представляют 
  собой неструктурированную последовательность байтов (длина записи равна 1) и 
  считывание очередного байта осуществляется с так называемой <i>текущей</i> позиции, 
  которая характеризуется смещением от начала файла. Зная размер блока, легко 
  вычислить номер блока, содержащего текущую позицию. Адрес же нужного блока диска 
  можно затем извлечь из индекса файла. Базовой операцией, выполняемой по отношению 
  к файлу, является чтение блока с диска и перенос его в буфер, находящийся в 
  основной памяти.<br><br>
Файловая система позволяет при помощи системы справочников (каталогов, директорий)  
  связать уникальное имя файла с блоками  вторичной памяти, содержащими данные 
  файла. Иерархическая структура каталогов, используемая для управления файлами, 
  является другим примером индексной структуры.  В этом случае каталоги или папки 
  играют роль индексов, каждый из которых содержит ссылки на свои подкаталоги. 
  С этой точки зрения вся файловая система компьютера представляет собой большой 
  индексированный файл.<br><br>
  Понятие «файловая система» включает <a href="../literature/literature.htm">[30]</a>: 
  </font> 
<ul type=square><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
  <li><p align="JUSTIFY">совокупность всех файлов на диске, </li>
  <li><p align="JUSTIFY">наборы структур данных, используемых для управления файлами, такие, например, 
    как каталоги файлов, дескрипторы файлов, таблицы распределения свободного 
    и занятого пространства на диске, </li>
  <li><p align="JUSTIFY">комплекс системных программных средств, реализующих управление файлами, 
    в частности: создание, уничтожение, чтение, запись, именование, поиск и другие 
    операции над файлами. </li>
</font></ul>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Файлы 
  управляются ОС. То, как они структурированы, поименованы, используются, защищены, 
  реализованы – одна из главных тем проектирования ОС. <br>
  <br>
Перечислим <i>основные функции</i> файловой системы:</font></p>
<ol>
<FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
<li><p align="JUSTIFY">
Идентификация 
  файлов. Связывание имени файла с выделенным ему пространством внешней памяти. 
</li>
<li><p align="JUSTIFY">
 Распределение 
  внешней памяти между файлами. Для работы с конкретным файлом не требуется иметь 
  информацию о местоположении этого файла на внешнем носителе информации. Например, 
  для того, чтобы загрузить документ в редактор с жесткого диска нам не требуется 
  знать на какой стороне какого магнитного диска и на каком цилиндре и в каком 
  секторе находится требуемый документ.
  </li>
<li><p align="JUSTIFY"> Обеспечение 
  надежности и отказоустойчивости. Стоимость информации может во много раз превышать 
  стоимость компьютера.
  </li>
<li><p align="JUSTIFY"> Обеспечение 
  защиты от НСД.
  </li>
<li><p align="JUSTIFY"> Обеспечение 
  совместного доступа к файлам, не требуя от пользователя специальных усилий по 
  обеспечению синхронизации доступа.
</li>
<li><p align="JUSTIFY"> Обеспечение 
  высокой производительности. 
  </li>
</font>  </ol>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Иногда говорят, что файл - поименованный набор связанной 
  информации, записанной во вторичную память. Для большинства пользователей файловая 
  система - наиболее видимая часть ОС.  Она предоставляет механизм для он-лайнового 
  хранения и доступа, как данным, так и программам ОС  для всех пользователям 
  системы. С точки зрения пользователя файл - минимальная величина внешней памяти, 
  то есть данные, записанные на диск должны  быть в составе какого-нибудь файла.<br><br>
Важный аспект организации файловой системы – учет стоимости 
  операций взаимодействия с вторичной памятью. Процесс считывания блока диска 
  состоит из позиционирования  считывающей головки над дорожкой, содержащей требуемый 
  блок, ожидания, пока требуемый блок сделает оборот и окажется под головкой  
  и собственно считывания блока. Для этого требуется значительное время (десятки 
  миллисекунд). В современных компьютерах обращение к диску примерно в 100000  
  медленнее, чем обращение к памяти. Таким образом,  критерием вычислительной 
  сложности алгоритмов, работающих с внешней памятью, является количество обращений 
  к диску.<br><br>
В данной главе рассмотрены вопросы  структуры, именования, 
  защиты файлов, операции, разрешенные над файлами, организация файлового  архива.    
  Проблемы выделения дискового пространства, обеспечения  производительной работы 
  файловой системы и ряд других, интересующие дизайнеров системы, вынесены в следующую 
  главу.</font><br><br>
  
<p align="left"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
<b><a name="l1102">11.2 Имена файлов</a></b></font></p>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Файлы – абстрактные объекты. Они предоставляют пользователям 
  возможность сохранять информацию, скрывая от него детали того, как и где она 
  хранится и то, как диски в действительности работают. Вероятно, одна из наиболее 
  важных характеристик любого абстрактного механизма – способ именования объектов, 
  которыми он управляет. Когда процесс создает файл, он дает файлу имя. После 
  завершения процесса файл продолжает существовать и через свое имя может быть 
  доступен другим процессам.<br><br>
Многие ОС поддерживают имена из <i>двух частей</i> (имя+расширение), 
  например progr.c(файл, содержащий 
  текст программы на языке Си) или autoexec.bat (файл, содержащий команды 
  интерпретатора командного языка).  Тип расширения файла позволяет ОС организовать 
  работу с ним различных  прикладных  программ в соответствии  с  заранее оговоренными 
  соглашениями.<br><br>
Обычно ОС накладывают некоторые ограничения, как на используемые 
  в имени символы, так и на длину имени.  Например, в ОС Unix учитывается регистр при вводе имени  файла
  (case sensitive), а в MS-DOS – нет.  В популярной файловой системе FAT длина имен ограничивается 
  известной схемой 8.3 (8 символов - собственно имя, 3 символа - расширение имени). 
  Современные файловые системы, как правило, поддерживают 
  более удобные для пользователя 
  длинные символьные имена файлов.  Так, в соответствии со стандартом POSIX, 
   в ОС UNIX  допускаются имена 
  длиной до 255 символов, та же самая длина устанавливается для имен файлов и 
  в ОС  Windows NT для файловой системы NTFS.</font><br><br>
<p align="left"><b><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
<a name="l1103">11.3 Структура файлов</a></font></b></p>
<p align="JUSTIFY"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Как уже говорилось,  программист воспринимает файл  в виде набора логических 
  записей.  Логическая запись - это наименьший элемент данных, которым может оперировать 
  программа при обмене с внешним устройством. Даже если физический обмен с устройством 
  осуществляется большими единицами (обычно блоками), операционная система обеспечивает 
  программисту доступ к отдельной логической записи. <br><br>
ОС поддерживают несколько вариантов структуризации файлов.<br><br>
Первый из них, файл, как <i>неструктурированная последовательность байтов</i>. 
  Например, в файловых системах ОС UNIX и MS-DOS файл имеет простейшую логическую 
  структуру - последовательность однобайтовых записей. <br><br>
ОС не осуществляет никакой интерпретации этих байтов.  Тем не менее,  ОС с 
  файловыми системами данного типа должны поддерживать, по крайней мере, одну 
  структуру - выполняемый файл - для запуска программ.  Этой схеме присущи максимальная  
  гибкость и универсальность. Используя базовые системные вызовы (или функции 
  библиотеки ввода/вывода), пользователи могут, как угодно структурировать файлы. 
  В частности, многие СУБД хранят свои базы данных в обычных файлах. <br><br>
Первый  шаг в структурировании  - хранение файла в виде <i>последовательности 
  записей фиксированной длины</i>, каждая из которых имеет внутреннюю структуру. 
  Центральная  идея этой схемы  - операция чтения проводится над записью и операция 
  записи - переписывает или добавляет запись целиком.  Ранее были записи по 80 
  байт (соответствовало числу позиций в перфокарте) или  по 132 символа (ширина 
  принтера). В ОС CP/M файлы были последовательностями 128-символьных записей. 
  С введением CRT терминалов эта идея утратила популярность.<br><br>
Третий способ представления файлов - <i>последовательность 
  записей переменной длины</i>, каждая из которых содержит  ключевое поле в фиксированной 
  позиции внутри записи. Базисная операция в данном случае - считать запись с 
  каким-либо  значением ключа.  Записи могут располагаться в файле последовательно 
  (например, будучи отсортированы по значению ключевого поля) или в более сложном 
  порядке.  <br><br></font>
    <p align="center"><img width=545 height=88 src="./images/image001.gif">
  

    <p align="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2">Рис.
    11..  Файл, 
  как последовательность записей переменной длины</font></p>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Использование  
  индексов файлов, хранящих адреса записей, позволяет обеспечить быстрый доступ 
  к отдельной записи (<i>индексно-последовательная организация</i>,  см. также 
  <a href="#l1105">раздел 11.5</a>). При добавлении новой 
  записи в файл, место, куда ее поместить будет определено не пользователем, а 
  операционной системой. Такой способ применяется в больших мэйнфреймах для коммерческих 
  процессов обработки данных.<br>
  <br></font>
<p align="left"><b><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
<a name="l1104">11.4 Типы и атрибуты файлов</a></font></b></p>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Важный 
  аспект дизайна файловой системы и ОС - следует ли поддерживать и распознавать 
  типы файлов. Если да, то это может помочь правильному функционированию ОС, например 
  не допустить вывода на принтер бинарного файла. <br>
  <br>
  К типам файлов, поддерживаемых современными ОС, относят регулярные (обычные) 
  файлы и директории. Обычные (регулярные) файлы содержат пользовательскую информацию. 
  Директории (справочники, каталоги) - системные файлы,  поддерживающие структуру 
  файловой системы. В каталоге содержится перечень файлов, входящих в него, и 
  устанавливается соответствие между файлами и их характеристиками (атрибутами). 
  Мы будем рассматривать директории ниже. <br>
  <br>
  </font><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> Напомним, 
  что хотя внутри подсистемы управления файлами обычный файл представляется в 
  виде набора блоков внешней памяти, для пользователей обеспечивается представление 
  файла в виде линейной последовательности байтов. Такое представление позволяет 
  использовать абстракцию файла при работе с внешними устройствами, при<a href="prep/sem11-12.htm#s1103"><img src="../images/computer.gif" width="48" height="48" align="right" alt="Материалы семинарских занятий" border="0"></a> 
  организации межпроцессных взаимодействий и т.д.  Поэтому, иногда к файлам приписывают 
  <b>другие объекты </b>ОС, например, специальные символьные файлы и специальные 
  блочные файлы, именованные каналы и сокеты, имеющие  файловый интерфейс. Эти 
  объекты рассмотрены в других разделах данного курса. <br>
  <br>
  </font> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> Далее, 
  главным образом, речь пойдет об <i>обычных файлах</i>. <br>
  <br>
  Обычные (или регулярные) файлы реально представляют собой набор блоков (возможно, 
  пустой) на устройстве внешней памяти, на котором поддерживается файловая система. 
  Такие файлы могут содержать как текстовую информацию (обычно в формате ASCII), 
  так и произвольную двоичную информацию. <br>
  <br>
  Обычные регулярные файлы бывают  - <i>ASCII и бинарные</i>. <br>
  <br>
  ASCII файлы  содержат строки текста, которые  можно распечатать, увидеть на 
  экране или редактировать обычным текстовым редактором. <br>
  <br>
  Другой тип файлов – бинарные файлы, означает, что это не ASCII файлы. Обычно 
  они имеют некоторую  внутреннюю  структуру. Например, выполнимый Unix файл имеет 
  пять секций: заголовок, текст, данные, биты реаллокации и символьную таблицу. 
  ОС выполняет  файл, только если он имеет нужный формат.   Другим примером бинарного 
  файла может быть архивный файл. <br>
  <br>
  Типизация файлов не слишком строгая. <br>
  <br>
  Обычно прикладные программы, работающие с файлами, распознают тип файла по его 
  имени в соответствии с общепринятыми соглашениями. Например, файлы с расширениями 
  .c, .pas, .txt – ASCII файлы, файлы с расширениями .exe – выполнимые, файлы 
  с расширениями .obj, .zip – бинарные и т.д. <br>
  <br>
  Помимо имени  ОС часто  связывают  с каждым файлом и  другую информацию, например 
  дату модификации, размер и т.д.  Эти другие характеристики файлов  называются 
  <i>атрибутами</i>.  Список атрибутов может варьироваться от одной ОС к другой.  
  Он может включать: атрибуты защиты, пароль, имя создателя, флаги  скрытости, 
  архивности, системности, бинарности, тип доступа, длину записи, позицию ключа, 
  время, дату, размер  и т.д. <br>
  <br>
  Эта информация обычно хранится в структуре директорий (см. раздел реализация 
  директорий) или других структурах, обеспечивающих доступ к данным файла. </font><br>
  <br>
<p align="left"><b><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
<a name="l1105">11.5 Доступ к файлам</a></font></b></p>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Для использования информации, хранимой в  файлах, она должна 
  быть считана в память компьютера. Есть несколько способов доступа к файлам.  
<br><br>
  Ранние ОС давали только один способ доступа – <i>последовательный</i><b> </b>(модель 
  ленты).  Записи считывались в порядке поступления.  Текущая позиция считывания 
  могла быть возвращена к началу файла (rewind).   Вместе с магнитными барабанами 
  и дисками появились файлы с <i>прямым </i>(random) доступом.    Для специфицирования  
  места, с которого надо начинать чтение  используются два способа:  с начала, 
  или с <i>текущей</i> позиции, которую  дает операция seek.<br>
  <br>
Последовательный доступ базируется на модели ленты и работает 
  как на устройствах последовательного доступа, так и прямого. Это наиболее общая 
  модель. Организация прямого доступа существенна для многих приложений, например, 
  для систем управления базами данных.<br><br>
  Не все системы поддерживают оба (последовательный и прямой) метода доступа.  
  Последовательный доступ легко эмулировать  при помощи  прямого, однако реализация 
  прямого доступа через последовательный была бы очень неэффективной.<br>
  <br>
Помимо прямого и последовательного существуют и другие методы 
  доступа. Обычно они включают конструирование <i>индекса</i> файла и базируются 
  на прямом методе доступа.  Для поиска записи вначале происходит обращение к 
  индексу,  где находится указатель на нужную запись.<br><br>
Предположим, что имеется большой файл, содержащий  разнообразные 
  сведения о студентах, состоящих из записей с несколькими полями, и возникает 
  задача организации быстрого поиска по одному из полей, например по фамилии студента.</font>
 <br><br>

<img border="0" src="IMAGES/IMAGE002.GIF" width="734" height="313">
<p  align="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2">Рис.
11.2  Пример 
  организации индекса для последовательного файла</font>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Рис. иллюстрирует решение данной проблемы – организацию индексно-последовательного 
  метода доступа к фалу.
  <br><br>
  Способ выделения дискового пространства  при помощи  индексных 
  узлов, применяемый в ряде ОС (Unix и ряде других, см. 
  следующую главу) может служить другим примером организации индекса.<br><br>
В этом  случае ОС использует древовидную организацию блоков, 
  при которой блоки, составляющие файл, являются листьями дерева, а каждый внутренний 
  узел содержит указатели на множество блоков файла. Для больших файлов индекс 
  может быть слишком большим. В этом случае создают индекс для индексного файла 
  (блоки промежуточного уровня или блоки косвенной адресации). </font><br><br>
<p align="left"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><b>
<a name="l1106">11.6 Операции над файлами.</a></b></font></p>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Операционная 
  система должна предоставить в распоряжение пользователя набор операций  для 
  работы с файлами, реализованных через системные вызовы. Чаще всего при работе 
  с файлом пользователь выполняет не одну, а несколько операций. Во-первых, нужно 
  найти данные <a href="prep/sem11-12.htm#s1107"><img src="../images/computer.gif" width="48" height="48" align="right"  alt="Материалы семинарских занятий" border="0"></a>файла 
  и его атрибуты по его символьному имени, во-вторых, считать необходимые атрибуты 
  файла в отведенную область оперативной памяти и проанализировать права пользователя 
  на выполнение требуемой операции. Затем выполнить операцию, после чего освободить 
  занимаемую данными файла область памяти. Рассмотрим в качестве примера основные 
  файловые операции ОС Unix:</font><br>

<ul type=square><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
  <li >
    <p align="JUSTIFY">Create. Создание файла, не содержащего данных. Смысл данного 
      вызова - объявить, что файл существует и присвоить ему ряд атрибутов.
  </li>
  <li><p align="JUSTIFY">Delete. Удаление файла и освобождение занятого им дискового 
    пространства.</li>
  <li ><p align="JUSTIFY">Open. Перед использованием файла процесс должен его открыть. 
    Цель данного системного вызова разрешить системе проанализировать атрибуты 
    файла и проверить права доступа к файлу, а также считать в оперативную память 
    список адресов блоков файла для быстрого доступа к его данным.</li>
  <li><p align="JUSTIFY">Close. Если работа с файлом завершена, 
    его атрибуты и адреса блоков на диске больше не нужны. В этом случае файл 
    нужно закрыть, чтобы освободить место во внутренних таблицах файловой системы.</li>
  <li><p align="JUSTIFY">Seek. Дает возможность специфицировать место внутри файла, 
    откуда будет производиться считывание (или запись) данных, то есть задать 
    <i>текущую</i> позицию.</li>
  <li><p align="JUSTIFY">Read. Чтение данных из файла. Обычно это происходит с текущей 
    позиции. Пользователь  должен задать объем считываемых данных и предоставить 
    буфер для них.</li>
  <li><p align="JUSTIFY">Write. Запись данных в файл с текущей позиции. 
    Если текущая позиция находится в конце файла, его размер увеличивается, в 
    противном случае запись осуществляется на место имеющихся данных, которые, 
    таким образом, теряются.</li>
  <li><p align="JUSTIFY">Get attributes. Предоставляет процессам 
    нужные им сведения об атрибутах файла.  В качестве примера можно привести, 
    утилиту make, которая использует информацию о времени последней модификации 
    файлов.</li>
  <li>
    <p align="JUSTIFY">Set attributes. Дает возможность пользователю установить 
      некоторые атрибуты. Наиболее очевидный пример - установка режима доступа 
      к файлу.
  </li>
  <li><p align="JUSTIFY">Rename. Возможность переименования файла 
    создает дополнительные удобства для пользователя. Данная операция может быть 
    смоделирована копированием данного файла в файл с новым именем и последующим 
    его удалением.</li></font>
</ul>
<p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Существует два способа выполнить последовательность действий над файлами <a href="../literature/literature.htm">[30]</a>: 
  <br>
  <br>
  
В первом случае для каждой операции выполняются как универсальные, 
  так и уникальные действия (схема stateless). Например, 
  последовательность операций может быть такой: open,  read1, close, 
  … open, read2, close, 
  … open, read3, close.
  <br><br>
  Альтернативный способ, это когда  универсальные действия 
  выполняются в начале и в конце последовательности операций, а для каждой промежуточной 
  операции выполняются только уникальные действия. В этом случае последовательность 
  вышеприведенных операций будет выглядеть так:  open, read1, … read2, … 
 read3, close.
 <br><br>
 Большинство ОС использует второй способ, как более экономичный 
  и быстрый. Первый способ более устойчив к сбоям, поскольку  результаты  каждой 
  операции становятся независимыми от результатов предыдущей операции, поэтому 
  он иногда применяется в распределенных системах (например, Sun
NFS).</font><br><br>
<p align="left"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><b>
<a name="l1107">11.7 Директории. Логическая структура файлового архива. </a> </b></font></p>
<p align="JUSTIFY"> 
<FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> Количество файлов 
на компьютере может быть большим. Отдельные системы хранят тысячи файлов, занимающие  
сотни гигабайтом диска. <a href="prep/sem11-12.htm#s1105"><img src="../images/computer.gif" width="48" height="48" align="right"  alt="Материалы семинарских занятий"  border="0"></a>Эффективное 
управление этими данными подразумевает наличие в них четкой логической структуры. 
Все современные файловые системы поддерживают многоуровневое именование файлов 
за счет поддержания во внешней памяти дополнительных файлов со специальной структурой 
– <i>каталогов</i><b> </b>(или директорий). <br>
<br>
Каждый каталог содержит  список каталогов и/или файлов, содержащихся в данном 
каталоге. Каталоги  имеют один и тот же внутренний формат, где каждому файлу соответствует 
одна запись в файле директории. <br>
<br>
<img border="0" src="IMAGES/IMAGE003.GIF" width="710" height="178"> 
<p style='text-autospace:none'>Рис. 11.3   Директории. (а) Атрибуты внутри записи 
  в директории. (б) Атрибуты  в другой структуре</p>
<p style='text-autospace:none'>Когда система открывает файл, она ищет имя файла 
  в директории. Затем извлекаются атрибуты и адреса блоков файла на диске или 
  непосредственно из записи в директории или из структуры, на которую запись в 
  директории указывает. Эта информация помещается в системную таблицу в главной 
  памяти. Все последующие  ссылки на этот файл используют  эту информацию.</p>
<p style='text-autospace:none'>Число директорий зависит от системы. В ранних ОС 
  имелась только одна  корневая директория,  затем появились директории для пользователей  
  (по одной директории на пользователя). В современных ОС используется произвольная 
  структура дерева директорий.</p>
<p>Таким образом, файлы на диске образуют иерархическую древовидную структуру 
  (см. рис. 11.4). </p>
<img border="0" src="IMAGES/image004.gif" width="359" height="184"> &nbsp; <br clear=ALL>
<p>Рис. 11.4  Древовидная структура файловой системы.</p>
<p>Существует несколько эквивалентных способов изображения дерева, структура перевернутого 
  дерева, приведенного на рис.11.4, наиболее популярна. Верхнюю вершину называют 
  корнем. Если элемент дерева не может иметь потомков, он называется терминальной 
  вершиной или листом (в данном случае является файлом). Не листовые вершины – 
  справочники или каталоги, содержат списки листовых и не листовых вершин. Путь 
  от корня к файлу однозначно определяет файл. </p>
<p>Внутри одного каталога имена  листовых файлов уникальны. Имена файлов, находящихся 
  в разных каталогах могут совпадать. Для того чтобы однозначно определить файл 
  по его имени (избежать коллизии имен)  принято именовать файл <i>полным именем 
  (</i><i><span lang=EN-US>pathname</span>),</i><b> </b>которое состоит из списка 
  имен вложенных каталогов, по которому можно найти путь от корня к файлу, плюс 
  имя файла в каталоге, непосредственно содержащем данный файл.  Таким образом, 
  имя включает цепочку имен - путь к файлу, например /usr/ast/mailbox . Это так 
  называемое<b> </b><i>абсолютное</i> имя.  Такие имена уникальны.  Компоненты 
  пути разделяют символами ‘/’ (слеш) в Unix или обратными слешами в MS-DOS (в 
  Multics – ‘&gt;’).  </p>
<p>Другой способ задания имени - <i>относительный</i>  путь к файлу. Он использует 
  концепцию рабочей или текущей директории, которая входит в состав окружения 
  (<span lang=EN-US>environment</span>) процесса, работающего с данным файлом. 
  Например, в ОС <span lang=EN-US>Linux</span>  рабочая директория  является частью 
  структуры данных процесса.  Тогда к файлам в такой директории можно ссылаться 
  только по имени,  при этом  поиск файла будет осуществляться в рабочей директории. 
  Это удобнее, но по существу то же самое, что и абсолютная форма.</p>
<p align="JUSTIFY">Для получения доступа к файлу и локализации его блоков система 
  должна выполнить <i>навигацию</i> по каталогам. Рассмотрим для примера путь 
  /usr/<span lang=EN-US>linux</span>/<span lang=EN-US>progr</span>.<span lang=EN-US>c</span>. 
  Алгоритм одинаков для всех иерархических систем. Сначала в фиксированном месте 
  на диске находится корневая директория.  Затем находится компонент пути <span lang=EN-US>usr</span>, 
  т.е. в корневой директории ищется  файл  /usr.   Исследуя этот файл, система 
  понимает, что данный файл является каталогом,  и  блоки данных данного файла 
  рассматривает как список файлов  и ищет следующий компонент <span lang=EN-US>linux</span> 
  в нем. Из строки для <span lang=EN-US>linux</span> находится файл, соответствующий  
  компоненту usr/<span lang=EN-US>linux</span>/.  Затем  также находится компонент  
  <span
lang=EN-US>progr</span>.<span lang=EN-US>c</span>, который затем открывается,  
  заносится в таблицу открытых файлов и сохраняется  в ней до закрытия файла. 
</p>
<p align="JUSTIFY">Отклонение от типовой обработки компонентов <span
lang=EN-US>pathname</span> может возникнуть в том случае, когда этот компонент 
  является не обычным каталогом с соответствующим ему индексным узлом и списком 
  файлов, а служит точкой монтирования  другого файлового архива к  данной  файловой 
  системе. Этот случай рассмотрен в следующей главе.</p>
<p>Многие прикладные программы  работают с файлами, находящимися в текущей директории, 
  не указывая явным образом ее имени. Это дает возможность пользователю возможность 
  произвольным образом именовать каталоги, содержащие различные программные пакеты. 
  Для реализации этой возможности в большинстве ОС, поддерживающих иерархическую 
  структуру директорий, используется обозначение '.' - для текущей  директории  
  и '..' - для  родительской. </p>
<p>Задание пути к файлу в файловых системах некоторых ОС отличаются тем, <i>с 
  чего начинается</i> эта цепочка имен. В этом отношении есть несколько вариантов. 
  В некоторых системах управления файлами требуется, чтобы каждый архив файлов 
  (полное дерево справочников) целиком располагался на одном  диске (или логическом 
  диске, разделе физического дискового пакета, представляемом с помощью средств 
  операционной системы как отдельный диск). В этом случае полное имя файла начинается 
  с имени дискового устройства, на котором установлен соответствующий диск (буквы 
  диска). Например, <span
lang=EN-US>c</span>:\<span lang=EN-US>util</span>\<span lang=EN-US>nu</span>\<span lang=EN-US>ndd</span>.<span
lang=EN-US>exe</span>. Такой способ именования используется в файловых системах 
  фирм DEC и <span lang=EN-US>Microsoft</span></p>
<p>В других системах (<span lang=EN-US>Multics</span>) вся совокупность файлов 
  и каталогов представляет собой единое дерево. Сама система, выполняя поиск файлов 
  по имени, начиная с корня,  требовала установки необходимых дисков. </p>
<p>В ОС <span lang=EN-US>Unix</span> предполагается наличие нескольких архивов 
  файлов, каждый на своем разделе, один из которых считается корневым. После запуска 
  системы можно <i>&quot;смонтировать&quot; </i>корневую файловую систему и ряд 
  изолированных файловых систем в одну общую файловую систему. </p>
<p>Технически это производится с помощью заведения в корневой файловой системе 
  специальных пустых каталогов (см. также следующую главу). Специальный системный 
  вызов “<span lang=EN-US>mount</span>” ОС UNIX позволяет подключить к одному 
  из этих пустых каталогов корневой каталог указанного архива файлов. После монтирования 
  общей файловой системы именование файлов производится так же, как если бы она 
  с самого начала была централизованной. Задачей ОС является беспрепятственный 
  проход точки монтирования при получении доступа к файлу по цепочке имен. Если 
  учесть, что обычно монтирование файловой системы производится при раскрутке 
  системы, то пользователи ОС UNIX обычно и не задумываются об исходном происхождении 
  общей файловой системы. </p>
<p><b><span
style='font-size:12.0pt;'> <a name="l1108">11.8 Операции над директориями</a></span></b></p>
<p align="JUSTIFY">Так же, как и в случае файлов, система обязана обеспечить пользователя 
  набором операций, необходимых для работы с директориями, реализованных через 
  системные вызовы.  Несмотря на то, что директории, это файлы, логика работы 
  с ними отличается от логики работы с <a href="prep/sem11-12.htm#s1107">
<img src="../images/computer.gif" width="48" height="48" align="right"  alt="Материалы семинарских занятий"  border="0"></a>обычными 
  файлами и определяется природой этих объектов, предназначенных поддерживать 
  структуру файлового архива. Совокупность системных вызовов для управления директориями 
  зависит от особенностей конкретной ОС. Рассмотрим в качестве примера некоторые 
  системные вызовы ОС <span
lang=EN-US>Unix</span>.</p>
<ul type=disc>
  <li style='          text-autospace:none'><span
     lang=EN-US>Create</span>. Создание директории. Вновь созданная директория 
    включает записи с именами '.' и '..', однако считается пустой.</li>
  <li style='          text-autospace:none'>Delete. Удаление директории. Удалена 
    может быть только пустая директория.</li>
  <li style='     text-autospace:none'>Opendir. Открытие директории для последующего 
    чтения. Например, чтобы перечислить файлы, входящие в директорию, процесс 
    должен открыть директорию и считать имена всех файлов, которые она включает.</li>
  <li style='     text-autospace:none'>Closedir. Закрытие директории после ее 
    чтения для освобождения места во внутренних системных таблицах.</li>
  <li style='     text-autospace:none'>Readdir. Данный системный вызов возвращает 
    содержимое текущей записи в открытой директории. Вообще говоря, для этих целей 
    может быть использован системный вызов Read, но в этом случае от программиста 
    потребуется знание внутренней структуры директории. Readdir возвращает содержимое 
    записи в стандартном формате, независимо от используемой структуры директорий.</li>
  <li style='     text-autospace:none'>Rename. Имена директорий можно менять, 
    также как и имена файлов.</li>
  <li style='     text-autospace:none'>Link. Связывание - это техника, которая 
    позволяет информации о файле появляться более чем в одной директории. Данный 
    системный вызов связывает существующий файл с абсолютным именем директории, 
    используя их в качестве параметров. При помощи вызова Link можно связать файл 
    сразу с несколькими директориями.</li>
  <li style='     text-autospace:none'>Unlink. Удаление записи о файле из директории. 
    Если удаляемый файл присутствует только в одной директории, то он вообще удаляется 
    из файловой системы, в противном случае система ограничивается только удалением 
    специфицируемой записи.</li>
</ul>
<p style='text-autospace:none'>Имеется также ряд других системных вызовов, например, 
  связанных с защитой информации.</p>
<p><b><span
style='font-size:12.0pt;'> <a name="l1109">11.9 Защита файлов.</a></span></b></p>
<p>Общие проблемы безопасности ОС рассмотрены в гл. <a href="../15/ch15.htm">15</a>-<a href="../16/ch16.htm">16</a>. 
  Информация в компьютерной системе должна быть защищена как от физического разрушения 
  (reliability), так и от несанкционированного доступа (protection).</p>
<p>Здесь мы коснемся  отдельных аспектов защиты, связанных с контролем доступа 
  к файлам. </p>
<p><a name="_Toc496008218"></a><a name="l110901"><b> <span
style='font-size:11.0pt;'>11.9.1 </span></b></a><b><span
style='font-size:11.0pt;'>Контроль доступа к файлам </span></b><b><span style='font-size:11.0pt;'></span></b></p>
<p align="JUSTIFY">Наличие в системе многих пользователей предполагает организацию 
  контролируемого доступа к файлам. Выполнение любой операции над файлом должно 
  быть разрешено только в случае наличия у пользователя соответствующих привилегий. 
  Обычно контролируются следующие операции: <span
lang=EN-US>Read</span>, <span lang=EN-US>Write</span>, <span lang=EN-US>Execute</span>, 
  <span lang=EN-US>Append</span>, <span lang=EN-US>Delete</span>, <span lang=EN-US>List</span></p>
<p align="JUSTIFY">Другие операции, например,  копирование файлов  или их переименование 
  также могут контролироваться. Однако они чаще реализуются через перечисленные.  
  Так, операцию копирования файлов можно представить как операцию  чтения и последующую 
  операцию записи. </p>
<p><a name="_Toc496008219"><b> <a name="l110902">11.9.2  Списки прав доступа </a></b></a><b><span
style='font-size:11.0pt;'> </span></b><b><span style='font-size:11.0pt;'></span></b></p>
<p align="JUSTIFY">Наиболее общий подход к защите файлов от несанкционированного 
  использования - сделать доступ зависящим от идентификатора пользователя, то 
  есть связать с каждым файлом или директорией список прав доступа (<span
lang=EN-US>access control list</span>), где перечислены имена пользователей и 
  типы разрешенных для них способов доступа к файлу. Любой запрос на выполнение 
  операции сверяется с таким списком.  Основная проблема  реализации такого способа 
  -  список может быть длинным.  Чтобы разрешить всем пользователям читать файл, 
  необходимо всех их внести в список. У этой техники есть два нежелательных следствия:</p>
<p class=MsoPlainText> <span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </span></span> <span style='font-family:"Times New Roman"'>Конструирование такого 
  списка может быть сложной задачей, особенно если мы не знаем заранее список 
  пользователей системы.</span></p>
<p class=MsoPlainText> <span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </span></span> <span style='font-family:"Times New Roman"'>Запись в директории 
  должна теперь иметь переменный размер (включать список потенциальных пользователей).</span></p>
<p class=MsoPlainText>Для решения этих проблем  создают классификации пользователей, 
  например, в ОС <span lang=EN-US style='font-family:&quot;Times New Roman&quot;;
'>Unix</span><span style='font-family:"Times New Roman"'> все пользователи разделены 
  на три группы:</span></p>
<p class=MsoListBullet> <span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </span></span> Владелец (<span lang=EN-US>Owner</span>).</p>
<p class=MsoListBullet> <span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </span></span> Группа (Group).  Набор пользователей, разделяющих файл и нуждающихся 
  в  типовом способе  доступа к нему.</p>
<p class=MsoListBullet> <span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </span></span> Остальные (Univers),</p>
<p class=MsoPlainText>что позволяет реализовать  конденсированную версию списка 
  прав доступа. В рамках этой ограниченной классификации задаются только три поля 
  (по одному для каждой группы) для каждой контролируемой операции. В итоге, в 
  <span lang=EN-US style='font-family:&quot;Times New Roman&quot;;
'>Unix</span> операции чтения, записи и исполнения контролируются  при помощи 
  9 бит (rwxrwxrwx).  </p>
<p><b><span
style='font-size:12.0pt;'> <a name="l1110">11.10 Резюме </a></span></b></p>
<p class=MsoHeader>Итак, файловая система, есть набор файлов и директорий и операций 
  над ними. Имена, структуры, файлов, способы доступа к ним и их атрибуты – важные 
  аспекты дизайна файловой системы. Большинство современных ОС поддерживает иерархическую 
  систему каталогов или директорий с возможным вложением директорий. Безопасность 
  файловой системы – одна из важнейших концепций ОС.</p>
<p class=MsoHeader> </p>
</font> 
<p align="center"><a href="../10/ch10.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../12/ch12.htm"> Следующая глава</a></p>

</body>
</html>
