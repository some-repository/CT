<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Лекция 4</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
<P ALIGN="CENTER"><B> </B></P>
<P ALIGN="CENTER"><B><font face="Times New Roman"  size=4> Глава 4. Кооперация процессов и основные 
  аспекты ее логической организации </FONT></B></p>
  <P align="center"><a href="../03/ch3.htm"> Предыдущая глава</a> | <a href="../os.html">Программа курса</a> | 
 <a href="../05/ch5.htm"> Следующая глава</a></P>
<B><FONT> </font></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Жизнь процессов в вычислительной системе напоминает 
  жизнь соседей в коммунальной квартире. Постоянное ожидание в очереди к местам 
  общего пользования (к процессору?) и постоянная борьба за другие ресурсы (кто 
  опять занял все конфорки на плите?). Для нормального функционирования процессов 
  операционная система старается максимально обособить их друг от друга. Каждый 
  процесс имеет свое собственное адресное пространство (каждая семья должна жить 
  в отдельной комнате), нарушение которого, как правило, приводит к аварийной 
  остановке процесса (вызов милиции). Каждому процессу, по возможности, предоставляются 
  свои собственные дополнительные ресурсы (у каждой семьи желателен свой собственный 
  холодильник). Тем не менее, для решения некоторых задач (приготовление праздничного 
  стола на всю квартиру) процессы могут объединять свои усилия. Настоящая глава 
  описывает причины, по которым взаимодействуют процессы, способы их взаимодействия 
  и возникающие при этом проблемы (попытайтесь отремонтировать общую квартиру 
  так, чтобы не переругались все проживающие в ней семьи). </FONT></p>

<p  align="center"><B><FONT FACE="Times New Roman" size=3><a name="l0401">4.1. Взаимодействующие процессы</a></font></b></p>

<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman"> Для достижения поставленной цели различные процессы 
  (возможно, даже принадлежащие разным пользователям) могут исполняться псевдопараллельно 
  на одной вычислительной системе или параллельно на разных вычислительных системах, 
  взаимодействуя между собой. </FONT></p>
<P ALIGN="JUSTIFY">  <FONT FACE="Times New Roman"> 
Для чего процессам нужно заниматься совместной деятельностью? Какие существуют 
  причины для их кооперации? </font>
  <UL>
    <LI><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Одной из причин является повышение скорости 
      работы. Когда один процесс ожидает наступления некоторого события (например, 
      окончания операции ввода-вывода), другие в это время могут заниматься полезной 
      работой, направленной на решение общей задачи. В многопроцессорных вычислительных 
      системах программа разделяется на отдельные кусочки, каждый из которых будет 
      исполняться на своем процессоре.</FONT></LI>
    <LI><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Второй причиной является совместное использование 
      данных. Различные процессы могут, к примеру, работать с одной и той же динамической 
      базой данных или с разделяемым файлом, совместно изменяя их содержимое.</FONT></LI>
    <LI>
    <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Третьей причиной является 
      модульная конструкция какой-либо системы. Типичным примером может служить 
      микроядерный способ построения операционной системы, когда ее различные 
      части представляют собой отдельные процессы, общающиеся путем передачи сообщений 
      через микроядро.</FONT>
  </LI>
    <LI><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Наконец, это может быть необходимо просто 
      для удобства работы пользователя, желающего, например, редактировать и отлаживать 
      программу одновременно. В этой ситуации процессы редактора и отладчика должны 
      уметь взаимодействовать друг с другом.</FONT></LI>
  </UL>
<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman" size=3>Процессы не могут взаимодействовать 
  не общаясь. Общение процессов обычно приводит к изменению их поведения в зависимости 
  от полученной информации. Если деятельность процессов остается неизменной при 
  любой принятой ими информации, то это означает, что они на самом деле не нуждаются 
  во взаимном общении. Процессы, которые влияют на поведение друг друга путем 
  обмена информацией, принято называть <I>кооперативными</I> или <I>взаимодействующими</I> 
  процессами, в отличие от независимых процессов, не оказывающих друг на друга 
  никакого воздействия и ничего не знающих о взаимном сосуществовании в вычислительной 
  системе. </font> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Различные процессы в вычислительной 
  системе изначально представляют собой обособленные сущности. Работа одного процесса 
  не должна приводить к нарушению работы другого процесса. Для этого, в частности, 
  разделены их адресные пространства и системные ресурсы, и для обеспечения корректного 
  взаимодействия процессов требуются специальные средства и действия операционной 
  системы. Нельзя просто поместить значение, вычисленное в одном процессе, в область 
  памяти, соответствующую переменной в другом процессе, не предприняв каких-либо 
  дополнительных организационных усилий. Давайте рассмотрим основные аспекты организации 
  совместной работы процессов.</FONT></P>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman" size=3><a name="l0402">4.2. Категории средств 
  обмена информацией</a></FONT></B> 
<P ALIGN="JUSTIFY">   <FONT FACE="Times New Roman" size=3> Процессы могут взаимодействовать друг с другом только обмениваясь информацией. 
  По объему передаваемой информации и степени возможного воздействия на поведение 
  другого процесса все средства такого обмена можно разделить на три категории: </font>
  <UL>
      <LI><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">
	  <a href="../13/prep/sem13-14.htm#s1305">
<img border="0" src="../images/computer.gif" align="right" alt="Сигналы в UNIX" vspace="4" width="48" height="48">
</a> <I>Сигнальные</i>. Передается минимальное 
      количество информации — один бит, “да” или “нет”. Используются, как правило, 
      для извещения процесса о наступлении какого-либо события. Степень воздействия 
      на поведение процесса, получившего информацию, минимальна. Все зависит от 
      того, знает ли он, что означает полученный сигнал, надо ли на него реагировать 
      и каким образом. Неправильная реакция на сигнал или его игнорирование могут 
      привести к трагическим последствиям. Вспомним профессора Плейшнера из кинофильма 
      “Семнадцать мгновений весны”. Сигнал тревоги — цветочный горшок на подоконнике 
      — был ему передан, но проигнорирован. И к чему это привело? </FONT></LI>
      <LI><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"><I>Канальные</i>. Общение процессов происходит 
      через линии связи, предоставленные операционной системой, и напоминает общение 
      людей по телефону, с помощью записок, писем или объявлений. Объем передаваемой 
      информации в единицу времени ограничен пропускной способностью линий связи. 
      С увеличением количества информации увеличивается и возможность влияния 
      на поведение другого процесса.</FONT></LI>
      <LI><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">
	  <a href="../06/prep/sem6-7.htm#s0605">
<img border="0" src="../images/computer.gif" align="right" alt="Разделяемая память в UNIX" vspace="4" width="48" height="48">
</a> <I>Разделяемая память</i>. Два или более 
      процессов могут совместно использовать некоторую область адресного пространства. 
      Созданием разделяемой памяти занимается операционная система (если, конечно, 
      ее об этом попросят). Общение процессов напоминает совместное проживание 
      студентов в одной комнате общежития. Возможность обмена информацией максимальна, 
      как, впрочем, и влияние на поведение другого процесса, но требует повышенной 
      осторожности (если вы переложили с места на место все вещи вашего соседа 
      по комнате, а часть из них еще и выбросили, то представляете, как он отреагирует?). 
      Использование разделяемой памяти для передачи/получения информации осуществляется 
      с помощью средств обычных языков программирования, в то время как сигнальным 
      и канальным средствам коммуникации для этого необходимы специальные системные 
      вызовы. Разделяемая память представляет собой наиболее быстрый способ взаимодействия 
      процессов в одной вычислительной системе.</FONT></LI>
  </UL>
<p  align="center"><B><FONT FACE="Times New Roman" size=3><a name="l0403">4.3. Логическая организация 
  механизма передачи информации</a></FONT></B> 
<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman"> При рассмотрении любого из средств коммуникации 
  нас с вами будет интересовать не их физическая реализация (общая шина данных, 
  прерывания, аппаратно разделяемая память и т.&nbsp;д. — мало ли чего придумает 
  человечество), а логическая, определяющая, в конечном счете, механизм их использования. 
  Некоторые важные аспекты логической реализации являются общими для всех категорий 
  средств связи, некоторые относятся к отдельным категориям. Давайте кратко охарактеризуем 
  основные вопросы, требующие освещения при изучении того или иного способа обмена 
  информацией. </FONT>
<p  align="center"><B><FONT FACE="Times New Roman" size=3><a name="l040301">4.3.1. Как устанавливается связь?</a></FONT></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Могу ли я использовать средство связи непосредственно 
    для обмена информацией сразу после создания процесса или первоначально необходимо 
    предпринять некоторые действия по инициализации обмена? Так, например, для 
    использования общей памяти различными процессами потребуется специальное обращение 
    к операционной системе, которая выделит требуемую область адресного пространства. 
    Но для передачи сигнала от одного процесса к другому никакая инициализация 
    не нужна. В то же время, передача информации по линиям связи может потребовать 
    первоначального резервирования такой линии для процессов, желающих обменяться 
    информацией. </FONT>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> <a name="l040301a"></a>К этому же вопросу тесно примыкает вопрос 
    о способе адресации при использовании средства связи. Если я передаю некоторую 
    информацию, то я должен указать, куда я ее передаю. Если я желаю получить 
    некоторую информацию, то мне нужно знать, откуда я могу ее получить. </FONT>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Различают два способа адресации: 
  <i>прямую</i> и <i>непрямую</i>. В случае прямой адресации взаимодействующие 
  процессы непосредственно общаются друг с другом, при каждой операции обмена 
  данными явно указывая имя или номер процесса, которому информация предназначена 
  или от которого она должна быть получена. Если и процесс, от которого данные 
  исходят, и процесс, принимающий данные, оба указывают имена своих партнеров 
  по взаимодействию, то такая схема адресации называется <i>симметричной прямой 
  адресацией</i>. <img border="0" src="../images/znak.gif" align="left" vspace="8" alt="Nota bene" hspace="10"> 
  <u><b>Ни один другой процесс не может вмешаться в процедуру симметричного прямого 
  общения двух процессов, перехватить посланные или подменить ожидаемые данные</b></u>. 
  Если только один из взаимодействующих процессов, например передающий, указывает 
  имя своего партнера по кооперации, а второй процесс в качестве возможного партнера 
  рассматривает любой процесс в системе, например, ожидает получения информации 
  от произвольного источника, то такая схема адресации называется<i> асимметричной 
  прямой адресацией</i>.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>При непрямой адресации 
  данные помещаются передающим процессом в некоторый промежуточный объект для 
  хранения данных, имеющий свой адрес, из которого они могут быть затем изъяты 
  каким-либо другим процессом. Примером такого объекта в повседневной жизни может 
  служить обычная доска объявлений или рекламная газета. При этом передающий процесс 
  не знает, как именно идентифицируется процесс, который получит информацию, а 
  принимающий процесс не имеет представления об идентификаторе процесса, от которого 
  он должен ее получить</font><FONT size=3>.</font></P>
<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman"> Естественно, что при использовании 
  прямой адресации связь между процессами в классической операционной системе 
  устанавливается автоматически, без дополнительных инициализирующих действий. 
  Единственное, что нужно для использования средства связи, — это знать, как идентифицируются 
  процессы, участвующие в обмене данными. </FONT></p>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> При использовании непрямой адресации 
  инициализация средства связи может как требоваться, так и не требоваться. Информация, 
  которой должен обладать процесс для взаимодействия с другими процессами, — это 
  некий идентификатор промежуточного объекта для хранения данных, если он, конечно, 
  не является единственным и неповторимым в вычислительной системе для всех процессов. 
  </FONT></p>
  
  <P ALIGN="center"> <B><FONT FACE="Times New Roman"><a name="l040302">4.3.2. Информационная валентность 
  процессов и средств связи</a></FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Следующий важный вопрос — это вопрос об информационной 
    валентности связи. Слово валентность здесь использовано по аналогии с химией. 
    Сколько процессов может быть одновременно ассоциировано с конкретным средством 
    связи? Сколько таких средств связи может быть задействовано между двумя процессами? 
    </FONT></p>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Понятно, что при прямой адресации 
  только одно данное средство связи может быть задействовано для обмена данными 
  между двумя процессами, и только эти два процесса могут быть ассоциированы с 
  ним. При непрямой адресации может существовать более двух процессов, использующих 
  один и тот же объект для данных, и более одного объекта может быть использовано 
  двумя процессами. </FONT></p>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> К этой же группе вопросов следует 
  отнести и вопрос о направленности связи. Является ли связь однонаправленной 
  или двунаправленной? Под однонаправленной связью мы будем понимать связь, при 
  которой каждый процесс, ассоциированный с ней, может использовать средство связи 
  либо только для приема информации, либо только для ее передачи. При двунаправленной 
  связи, каждый процесс, участвующий в общении, может использовать связь и для 
  приема, и для передачи данных. В коммуникационных системах принято называть 
  однонаправленную связь <I>симплексной</I>, двунаправленную связь с поочередной 
  передачей информации в разных направлениях — <I>полудуплексной</I>, а двунаправленную 
  связь с возможностью одновременной передачи информации в разных направлениях 
  — <i>дуплексной</i>. Прямая и непрямая адресация не имеют непосредственного 
  отношения к направленности связи. </FONT></p>
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman"><a name="l040303">4.3.3. Особенности передачи 
  информации с помощью линий связи</a></FONT></B> </p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Как мы говорили выше, передача информации между 
  процессами посредством линий связи является достаточно безопасной по сравнению 
  с использованием разделяемой памяти и достаточно информативной по сравнению 
  с сигнальными средствами коммуникации. Кроме того, разделяемая память не может 
  быть использована для связи процессов, функционирующих на различных вычислительных 
  системах. Возможно, именно поэтому каналы связи получили наибольшее распространение 
  среди других средств коммуникации процессов. Коснемся некоторых вопросов, связанных 
  с логической реализацией канальных средств коммуникации. </FONT></p>
  
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman"><a name="l04030301">4.3.3.1 Буферизация</a></FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Может ли линия связи сохранять 
  информацию, переданную одним процессом, до ее получения другим процессом или 
  помещения в промежуточный объект? Каков объем этой информации? Иными словами, 
  речь идет о том, обладает ли канал связи <I>буфером</I> и каков объем этого 
  буфера. Здесь можно выделить три принципиальных варианта: </FONT></p>
<OL>
     <LI>
	  
    <P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman">Буфер нулевой емкости или 
      отсутствует. Никакая информация не может сохраняться на линии связи. В этом 
      случае процесс, посылающий информацию, должен ожидать, пока процесс, принимающий 
      информацию, не соблаговолит ее получить, прежде чем заниматься своими дальнейшими 
      делами.</FONT>
  </LI>
  <LI> 
    <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Буфер ограниченной емкости. Размер буфера 
      равен <I>n</I>, то есть линия связи не может хранить до 
      момента получения более чем <I>n</I> единиц информации. Если в момент передачи 
      данных в буфере хватает места, то передающий процесс не должен ничего ожидать. 
      Информация просто копируется в буфер. Если же в момент передачи данных буфер 
      заполнен или места не достаточно, то необходимо задержать работу процесса 
      отправителя до появления в буфере свободного пространства.</font>
  </LI>
  <LI><P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman">Буфер неограниченной емкости. Теоретически 
      это возможно, но практически вряд ли реализуемо. Процесс, посылающий информацию, 
      никогда не ждет окончания ее передачи и приема другим процессом.</FONT></LI>
</OL>
<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman"> При использовании канального 
  средства связи с непрямой адресацией под емкостью буфера обычно понимается количество 
  информации, которое может быть помещено в промежуточный объект для хранения 
  данных. </font>
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman"><a name="l04030302">4.3.3.2. Поток ввода/вывода и сообщения</a></FONT></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Существует две модели передачи 
  данных по каналам связи — <I>поток ввода-вывода</I> и <I>сообщения</I>. При 
  передаче данных с помощью потоковой модели, операции передачи/приема информации 
  вообще не интересуются содержимым данных. Процесс, прочитавший 100 байт из линии 
  связи, не знает и не может знать, были ли они переданы одновременно, т.&nbsp;е. 
  одним куском, или порциями по 20 байт, пришли они от одного процесса или от 
  разных процессов. Данные представляют собой простой поток байт, без какой-либо 
  их интерпретации со стороны системы. Примерами потоковых каналов связи могут 
  служить <I>pipe</I> 
  и <I>FIFO</I>, 
  описанные ниже.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"><a href="../05/prep/sem5.htm#s0508">
<img border="0" src="../images/computer.gif" align="right" alt="Pipe в UNIX" vspace="4" width="48" height="48">
</a> <a name="l04030302a"></a>
 Одним из наиболее простых способов передачи 
  информации между процессами по линиям связи является передача данных через pipe 
  (канал, трубу или, как его еще называют в литературе, конвейер). Представим 
  себе, что у вас есть некоторая труба в вычислительной системе, в один из концов 
  которой процессы могут сливать информацию, а из другого конца принимать полученный 
  поток. Естественно, что такой способ реализует потоковую модель ввода/вывода. 
  Информацией о расположении трубы в операционной системе обладает только процесс, 
  создавший ее. Этой информацией он может поделиться исключительно со своими наследниками 
  — процессами-детьми и их потомками. Поэтому использовать pipe для связи между 
  собой могут только родственные процессы, имеющие общего предка, создавшего этот 
  канал связи. </FONT></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"><a href="../05/prep/sem5.htm#s0514">
<img border="0" src="../images/computer.gif" align="right" alt="FIFO в UNIX" vspace="4" width="48" height="48">
</a> <a name="l04030302b"></a>
 Если разрешить процессу, создавшему трубу, сообщать 
  об ее точном расположении в системе другим процессам, сделав вход и выход трубы 
  каким-либо образом видимыми для всех остальных, например, зарегистрировав ее 
  в операционной системе под определенным именем, мы получим объект, который принято 
  называть FIFO или именованный pipe. Именованный pipe может использоваться для 
  связи между любыми процессами в системе. </FONT></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3><a href="../09/prep/sem9.htm#s0902"> 
  <img border="0" src="../images/computer.gif" align="right" alt="Сообщения в UNIX" vspace="4" width="48" height="48"> 
  </a> <a name="l04030302c"></a>В модели сообщений процессы налагают на передаваемые 
  данные некоторую структуру. Весь поток информации они разделяют на отдельные 
  сообщения, вводя между данными, по крайней мере, границы сообщений. Примером 
  границ сообщений являются точки между предложениями в сплошном тексте или границы 
  абзаца. Кроме того, к передаваемой информации может быть присоединены указания 
  на то, кем конкретное сообщение было послано и для кого оно предназначено. Примером 
  указания отправителя могут служить подписи под эпиграфами в книге. Все сообщения 
  могут иметь одинаковый фиксированный размер или могут быть переменной длины. 
  В вычислительных системах используются разнообразные средства связи для передачи 
  сообщений: очереди сообщений, sockets (гнезда) и т.д. Часть из них мы рассмотрим 
  подробнее в дальнейшем, в частности очереди сообщений будут рассмотрены в <a href="../06/ch6.htm#l0603">главе&nbsp;6</a>, 
  а гнезда (иногда их еще называют по транслитерации английского названия без 
  перевода – сокеты) в <a href="../14/ch14.htm">главе&nbsp;14</a>.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> И потоковые линии связи, и каналы сообщений 
  могут иметь или не иметь буфер. Когда мы будем говорить о емкости буфера для 
  потоков данных, мы будем измерять ее в байтах. Когда мы будем говорить о емкости 
  буфера для сообщений, мы будем измерять ее в сообщениях. </FONT></p>

 
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman"><a name="l040304">4.3.4. Надежность средств связи</a></FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Одним из существенных вопросов при рассмотрении 
  всех категорий средств связи является вопрос об их надежности. Из житейского 
  опыта мы знаем, как тяжело расслышать собеседника по вечно трещащему телефону. 
  Некоторые полученные телеграммы вызывают чувство глубокого недоумения: “Прибду 
  пыездом в вонедельник 33 июня в 25.34. Пама”, а некоторые вообще не доставляются. 
  </FONT></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Мы будем называть способ коммуникации надежным, если при обмене данными выполняются 
  следующие четыре условия: </font>
  <OL>
    <LI><FONT FACE="Times New Roman">Не происходит потери информации.</FONT></LI>
    <LI><FONT FACE="Times New Roman">Не происходит повреждения информации.</FONT></LI>
    <LI><FONT FACE="Times New Roman">Не появляется лишней информации.</FONT></LI>
    <LI><FONT FACE="Times New Roman">Не нарушается порядок данных в процессе обмена.</FONT></LI>
  </OL>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Очевидно, что передача 
  данных через разделяемую память является надежным способом связи. То, что мы 
  сохранили в разделяемой памяти, будет считано другими процессами в первозданном 
  виде, если, конечно, не произойдет сбоя в питании компьютера. Для других средств 
  коммуникации,
  как видно из приведенных выше примеров, это не всегда верно. </font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Каким образом в вычислительных 
  системах пытаются бороться с ненадежностью коммуникаций? Давайте рассмотрим 
  возможные варианты на примере обмена данными через линию связи с помощью сообщений. 
  Для обнаружения повреждения информации будем снабжать каждое передаваемое сообщение 
  некоторой контрольной суммой, вычисленной по посланной информации. При приеме 
  сообщения контрольную сумму будем вычислять заново и проверять ее соответствие 
  пришедшему значению. Если данные не повреждены (контрольные суммы совпадают), 
  то подтвердим правильность их получения. Если данные повреждены (контрольные 
  суммы не совпадают), то сделаем вид, что сообщение к нам не поступило. Вместо 
  контрольной суммы можно использовать специальное кодирование передавамых данных 
  с помощью кодов, исправляющих ошибки. Такое кодирование позволяет при числе 
  искажений информации, не превышающем некоторого значения, восстановить начальные 
  неискаженные данные. Если по прошествии некоторого интервала времени подтверждение 
  о правильности полученной информации не придет на передающий конец линии связи, 
  то информацию будем считать утерянной, и пошлем ее повторно. Для того чтобы 
  избежать двойного получения одной и той же информации, на приемном конце линии 
  связи должен производиться соответствующий контроль. Для гарантии правильного 
  порядка получения сообщений будем их нумеровать. При приеме сообщения с номером, 
  не соответствующим ожидаемому, поступаем с ним как с утерянным и ждем сообщения 
  с правильным номером </FONT></p>
<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman">Подобные действия могут быть возложены:</font> 
  <UL>
    <LI><FONT FACE="Times New Roman">на операционную систему;</FONT></LI>
    <LI><FONT FACE="Times New Roman">на процессы, обменивающиеся данными;</FONT></LI>
    <LI><FONT FACE="Times New Roman">совместно на систему и процессы, разделяя 
      их ответственность. Операционная система может обнаруживать ошибки при передаче 
      данных и извещать об этом взаимодействующие процессы для принятия ими решения 
      о дальнейшем поведении.</FONT></LI>
  </UL>
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman"><a name="l040305">4.3.5. Как завершается связь?</a></FONT></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Наконец, важным вопросом при изучении средств 
  обмена данными является вопрос прекращения обмена. Здесь нужно выделить два 
  аспекта: требуются ли от процесса какие-либо специальные действия по прекращению 
  использования средства коммуникации, и влияет ли такое прекращение на поведение 
  других процессов. Для способов связи, которые не подразумевали никаких инициализирующих 
  действий, обычно ничего специального для окончания взаимодействия предпринимать 
  не надо. Если же установление связи требовало некоторой инициализации, то, как 
  правило, при ее завершении необходимо выполнение ряда операций, например, сообщения 
  операционной системе об освобождении выделенного связного ресурса. </FONT></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Если кооперативные процессы прекращают взаимодействие 
  согласовано, то такое прекращение не влияет на их дальнейшее поведение. Иная 
  картина наблюдается при несогласованном окончании связи одним из процессов. 
  Если какой-либо из взаимодействующих процессов, не завершивших общение, находится 
  в этот момент в состоянии ожидания получения данных, либо попадает в такое состояние 
  позже, то операционная система обязана предпринять некоторые действия для того, 
  чтобы исключить вечное блокирование этого процесса. Обычно это либо прекращение 
  работы ожидающего процесса, либо его извещение о том, что связи больше нет (например, 
  с помощью передачи заранее определенного сигнала). </FONT></p>
  <P ALIGN="CENTER"><B><FONT FACE="Times New Roman"><a name="l0404">4.4. Нити исполнения</a></FONT></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Рассмотренные выше аспекты логической реализации 
  относятся к средствам связи, ориентированным на организацию взаимодействия различных 
  процессов. Однако усилия, направленные на ускорение решения задач в рамках классических 
  операционных систем, привели к появлению совершенно иных механизмов, к изменению 
  самого понятия “процесс”. </FONT></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> В свое время внедрение идеи мультипрограммирования 
  позволило повысить пропускную способность компьютерных систем, т.е. уменьшить 
  среднее время ожидания результатов работы процессов. Но любой отдельно взятый 
  процесс в мультипрограммной системе никогда не может быть выполнен быстрее, 
  чем при выполнении в однопрограммном режиме на том же вычислительном комплексе. 
  Тем не менее, если алгоритм решения задачи обладает определенным внутренним 
  параллелизмом, мы могли бы ускорить его работу, организовав взаимодействие нескольких 
  процессов. Рассмотрим следующий пример. Пусть у нас есть следующая программа 
  на псевдоязыке программирования: </FONT></p>
<table align="center"  CELLSPACING=0 BORDER=0 CELLPADDING=0 width="30%">
  <tr>
    <td width="100%"><I><FONT FACE="Times New Roman" size=3>Ввести массив a</font></I></td>
  </tr>
  <tr>
    <td width="100%">
<I><FONT FACE="Times New Roman" size=3>Ввести массив b</font></I></td>
  </tr>
  <tr>
    <td width="100%">
<I><FONT FACE="Times New Roman" size=3>Ввести массив c</font></I></td>
  </tr>
  <tr>
    <td width="100%">
<I><FONT FACE="Times New Roman" size=3> a&nbsp;=&nbsp;a&nbsp;+&nbsp;b </FONT></I></td>
  </tr>
  <tr>
    <td width="100%">
<I><FONT FACE="Times New Roman" size=3> c&nbsp;=&nbsp;a&nbsp;+&nbsp;c </FONT></I></td>
  </tr>
  <tr>
    <td width="100%">
<I><FONT FACE="Times New Roman" size=3>Вывести массив </font><FONT size=3>c</font></I></td>
  </tr>
</table>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>При выполнении такой программы 
  в рамках одного процесса этот процесс четырежды будет блокироваться, ожидая 
  окончания операций ввода-вывода. Но наш алгоритм обладает внутренним параллелизмом. 
  Вычисление суммы массивов <I>a&nbsp;+&nbsp;b</I>
  можно было бы делать параллельно с ожиданием окончания операции ввода массива 
<I>c</I>.</font></P>
<P ALIGN="CENTER"> 
<TABLE ALIGN="CENTER" CELLSPACING=0 BORDER=0 CELLPADDING=0 WIDTH=60%>
  <TR> 
    <TD WIDTH="64%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman" size=3>Ввести массив a</FONT></I> 
    </TD>
    <TD WIDTH="36%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="64%" VALIGN="TOP" align="left"> 
      <P ALIGN="JUSTIFY"><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="36%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="64%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman" size=3>Ввести массив b</FONT></I> 
    </TD>
    <TD WIDTH="36%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="64%" VALIGN="TOP" align="left"> 
      <P ALIGN="JUSTIFY"><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="36%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="64%" VALIGN="TOP" align="left"> 
      <P ALIGN="JUSTIFY"><I><FONT FACE="Times New Roman"> Ввести массив с</font></I></p>
    </TD>
    <TD WIDTH="36%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="64%" VALIGN="TOP" align="left"> 
      <P ALIGN="JUSTIFY"><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="36%" VALIGN="TOP"> 
      <P ALIGN="CENTER"><I><FONT  FACE="Times New Roman"> a&nbsp;=&nbsp;a&nbsp;+&nbsp;b</font></I></p>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="64%" VALIGN="TOP" align="left"> 
      <P ALIGN="JUSTIFY"><I><FONT FACE="Times New Roman"> c&nbsp;=&nbsp;a&nbsp;+&nbsp;c</font></I></p>
    </TD>
    <TD WIDTH="36%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="64%" VALIGN="TOP" align="left"> 
      <P ALIGN="JUSTIFY"><I><FONT FACE="Times New Roman"> Вывести массив с</font></I></p>
    </TD>
    <TD WIDTH="36%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="64%" VALIGN="TOP" align="left"> 
      <P ALIGN="JUSTIFY"><I><FONT FACE="Times New Roman"> Ожидание окончания операции вывода</font></I></p>
    </TD>
    <TD WIDTH="36%" VALIGN="TOP">&nbsp;</TD>
  </TR>
</TABLE>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Такое совмещение операций по времени можно было 
  бы реализовать, используя два взаимодействующих процесса. Для простоты будем 
  полагать, что средством коммуникации между ними служит разделяемая память. Тогда 
  наши процессы могут выглядеть следующим образом: </FONT></p>
<P ALIGN="JUSTIFY"><FONT> &nbsp; &nbsp; &nbsp;</FONT></p>
<TABLE align="center" CELLSPACING=0 BORDER=0 CELLPADDING=0 WIDTH=60%>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP"> 
      <P ALIGN="center"><FONT FACE="Times New Roman"> Процесс 1 <br>&nbsp;</FONT></p>
    
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP"> 
      <P ALIGN="center"><FONT FACE="Times New Roman"> Процесс 2</FONT></p>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman" size=3>Ввести массив a</FONT></I> 
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman"> Ожидание ввода</font></I></p>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman" size=3>массивов a  и b </FONT></I> 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman" size=3>Ввести массив b</FONT></I> 
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman"> Ввести массив с</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left"> 
      <P><I><FONT  FACE="Times New Roman"> a&nbsp;=&nbsp;a&nbsp;+&nbsp;b</font></I></p>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT  FACE="Times New Roman"> c&nbsp;=&nbsp;a&nbsp;+&nbsp;c</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman"> Вывести массив с</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman"> Ожидание окончания операции вывода</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left">&nbsp;</TD>
  </TR>
</TABLE>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Казалось бы, мы предложили конкретный способ 
  ускорения решения задачи. Однако в действительности дело обстоит не так просто. 
  Второй процесс должен быть создан, оба процесса должны сказать операционной 
  системе, что им необходима память, которую они могли бы разделить с другим процессом, 
  и, наконец, нельзя забывать о переключении контекста. Поэтому реальное поведение 
  процессов будет выглядеть примерно так. </FONT></p>
<TABLE align="center" CELLSPACING=0 BORDER=0 CELLPADDING=0 WIDTH=60%>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP"> 
      <P ALIGN="center"><FONT FACE="Times New Roman"> Процесс 1 <br>&nbsp;</FONT></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP"> 
      <P ALIGN="center"><FONT FACE="Times New Roman"> Процесс 2<br>&nbsp;</FONT></p>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman"> Создать процесс 2</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD VALIGN="TOP" COLSPAN=3> 
      <P ALIGN="center"><I><FONT FACE="Times New Roman"> Переключение контекста</font></I></p>
    </TD>
  </TR>
  <TR>
    <TD WIDTH="55%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman"> Выделение общей памяти</font></I></p>
    </TD>
  </TR>
  <TR>
    <TD WIDTH="55%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman" size=3>Ожидание ввода 
        a и b</FONT></I> 
    </TD>
  </TR>
  <TR> 
    <TD VALIGN="TOP" COLSPAN=3> 
      <P ALIGN="center"><I><FONT FACE="Times New Roman"> Переключение контекста</font></I></p>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman"> Выделение общей памяти</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman" size=3>Ввести массив 
       a</FONT></I> 
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P><I><FONT FACE="Times New Roman" size=3>Ввести массив b</FONT></I> 
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman"> Ввести массив с</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="55%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD VALIGN="TOP" COLSPAN=3> 
      <P ALIGN="center"><I><FONT FACE="Times New Roman"> Переключение контекста</font></I></p>
    </TD>
  </TR>
  <TR>
    <TD WIDTH="55%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP" align="left"> 
      <P ><I><FONT FACE="Times New Roman"> a&nbsp;=&nbsp;a&nbsp;+&nbsp;b</font></I></p>
    </TD>
  </TR>
  <TR> 
    <TD VALIGN="TOP" COLSPAN=3> 
      <P ALIGN="center"><I><FONT FACE="Times New Roman"> Переключение контекста</font></I></p>
    </TD>
  </TR>
  <TR align="left"> 
    <TD WIDTH="55%" VALIGN="TOP"> 
      <P ><I><FONT FACE="Times New Roman"> c&nbsp;=&nbsp;a&nbsp;+&nbsp;c</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR align="left"> 
    <TD WIDTH="55%" VALIGN="TOP"> 
      <P ><I><FONT FACE="Times New Roman"> Вывести массив с</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR align="left"> 
    <TD WIDTH="55%" VALIGN="TOP"> 
      <P ><I><FONT FACE="Times New Roman"> Ожидание окончания операции вывода</font></I></p>
    </TD>
    <TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="34%" VALIGN="TOP">&nbsp;</TD>
  </TR>
</TABLE>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Как видим, мы можем не только не выиграть во 
  времени решения задачи, но даже и проиграть, так как временные потери на создание 
  процесса, выделение общей памяти и переключение контекста могут превысить выигрыш, 
  полученный за счет совмещения операций. </FONT></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Для того, чтобы реализовать 
  нашу идею, введем новую абстракцию внутри понятия “процесс” – <I>нить исполнения</I> 
  или просто <I>нить</I> (в англоязычной литературе используется термин <I>thread</I>). 
Нити процесса разделяют его программный 
  код, глобальные переменные и системные ресурсы, но каждая нить имеет свой собственный 
  программный счетчик, свое содержимое регистров и свой собственный стек. Теперь 
  процесс представляется как совокупность взаимодействующих нитей и выделенных 
  ему ресурсов. Процесс, содержащий всего одну нить исполнения, идентичен процессу 
  в том смысле, который мы употребляли ранее. Для таких процессов мы в дальнейшем 
  будем использовать термин “традиционный процесс”. Иногда нити называют облегченными 
  процессами или мини-процессами, так как во многих отношениях они подобны традиционным 
  процессам. <a href="./../06/prep/sem6-7.htm#s0611">
<img border="0" src="../images/computer.gif" align="right" alt="Нити исполнения в UNIX" vspace="4"  hspace="5" width="48" height="48">
</a> Нити, как и процессы, могут порождать нити-потомки, правда, только 
  внутри своего процесса, и переходить из состояния в состояние. Состояния нитей 
  аналогичны состояниям традиционных процессов. Из состояния <B><I>рождение </i></B>процесс 
  приходит содержащим всего одну нить исполнения. Другие нити процесса будут являться 
  потомками этой нити прародительницы. Мы можем считать, что процесс находится 
  в состоянии <B><I>готовность</i></B>, если хотя бы одна из его нитей находится 
  в состоянии <B><I>готовность </i></B>и ни одна из нитей не находится в состоянии 
  <B><I>исполнение</i></B>. Мы можем считать, что процесс находится в состоянии 
  <B><I>исполнение</i></B>, если одна из его нитей находится в состоянии <B><I>исполнение</i></B>. 
  Процесс будет находиться в состоянии <B><I>ожидание</i></B>, если все его нити 
  находятся в состоянии <B><I>ожидание</i></B>. Наконец, процесс находится в состоянии 
  <B><I>завершил исполнение</i></B>, если все его нити находятся в состоянии <B><I>завершили 
  исполнение</i></B>. Пока одна нить процесса заблокирована, другая нить того 
  же процесса может выполняться. Нити разделяют процессор так же, как это делали 
  традиционные процессы, в соответствии с рассмотренными алгоритмами планирования. 
  </font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Поскольку нити одного процесса разделяют существенно 
  больше ресурсов, чем различные процессы, то операции создания новой нити и переключения 
  контекста между нитями одного процесса занимают существенно меньше времени, 
  чем аналогичные операции для процессов в целом. Предложенная нами схема совмещения 
  работы в терминах нитей одного процесса получает право на существование. </FONT></p>
<TABLE align="center" CELLSPACING=0 BORDER=0 CELLPADDING=0 WIDTH=60%>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P ALIGN="center" ><FONT FACE="Times New Roman"> Нить 1 <br>&nbsp;</FONT></p>
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP"> 
      <P ALIGN="center" ><FONT FACE="Times New Roman"> Нить 2<br>&nbsp;</FONT></p>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P  align="LEFT"><I><FONT FACE="Times New Roman"> Создать нить 2</font></I></p>
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD VALIGN="TOP" COLSPAN=3> 
      <P ALIGN="center"><I><FONT FACE="Times New Roman"> Переключение контекста нитей</font></I></p>
    </TD>
  </TR>
  <TR>
    <TD WIDTH="54%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT FACE="Times New Roman" size=3>Ожидание ввода 
       a и b</FONT></I> 
    </TD>
  </TR>
  <TR> 
    <TD VALIGN="TOP" COLSPAN=3> 
      <P ALIGN="center"><I><FONT FACE="Times New Roman"> Переключение контекста нитей</font></I></p>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT FACE="Times New Roman" size=3>Ввести массив 
    a</FONT></I> 
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P><I><FONT FACE="Times New Roman" size=3>Ввести массив b</FONT></I> 
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT FACE="Times New Roman"> Ввести массив с</font></I></p>
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT FACE="Times New Roman"> Ожидание окончания операции ввода</font></I></p>
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD VALIGN="TOP" COLSPAN=3> 
      <P ALIGN="center"><I><FONT FACE="Times New Roman"> Переключение контекста нитей</font></I></p>
    </TD>
  </TR>
  <TR>
    <TD WIDTH="54%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT  FACE="Times New Roman"> a&nbsp;=&nbsp;a&nbsp;+&nbsp;b</font></I></p>
    </TD>
  </TR>
  <TR> 
    <TD VALIGN="TOP" COLSPAN=3> 
      <P ALIGN="center"><I><FONT FACE="Times New Roman"> Переключение контекста нитей</font></I></p>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT  FACE="Times New Roman"> c&nbsp;=&nbsp;a&nbsp;+&nbsp;c</font></I></p>
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT FACE="Times New Roman"> Вывести массив с</font></I></p>
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
  <TR> 
    <TD WIDTH="54%" VALIGN="TOP"> 
      <P align="LEFT"><I><FONT FACE="Times New Roman"> Ожидание окончания операции вывода</font></I></p>
    </TD>
    <TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
    <TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
  </TR>
</TABLE>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3><a name="l0404a"></a>Различают 
  операционные системы, поддерживающие нити на уровне ядра и на уровне библиотек. 
  Все выше сказанное справедливо для операционных систем, поддерживающих нити 
  на уровне ядра. В них планирование использования процессора происходит в терминах 
  нитей, а управление памятью и другими системными ресурсами остается в терминах 
  процессов. В операционных системах, поддерживающих нити на уровне библиотек 
  пользователей, и планирование процессора, и управление системными ресурсами 
  осуществляется в терминах процессов. Распределение использования процессора 
  по нитям в рамках выделенного процессу временного интервала осуществляется средствами 
  библиотеки. В таких системах блокирование одной нити приводит к блокированию 
  всего процесса, ибо ядро операционной системы ничего не знает о существовании 
  нитей. По сути дела, в таких вычислительных системах просто имитируется наличие 
  нитей исполнения.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> В дальнейшем тексте этой части книги для простоты 
  изложения мы будем использовать термин “процесс”, хотя все сказанное будет относиться 
  и к нитям исполнения. </FONT></p>
 
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman"><a name="l0405">4.5. Резюме</a></FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Для достижения поставленной цели различные процессы 
  могут исполняться псевдопараллельно на одной вычислительной системе или параллельно 
  на разных вычислительных системах, взаимодействуя между собой. Причинами для 
  совместной деятельности процессов обычно являются: необходимость ускорения решения 
  задачи, совместное использование обновляемых данных, удобство работы или модульный 
  принцип построения программных комплексов. Процессы, которые влияют на поведение 
  друг друга путем обмена информацией, называют
<a href="#l0401"> кооперативными или взаимодействующими 
  процессами</a>, в отличие от независимых процессов, не оказывающих друг на друга 
  никакого воздействия и ничего не знающих о взаимном сосуществовании в вычислительной 
  системе. </FONT></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Для обеспечения корректного обмена 
  информацией операционная система должна предоставить процессам специальные средства 
  связи. По объему передаваемой информации и степени возможного воздействия на 
  поведение процесса, получившего информацию, их можно разделить на три
  <a href="#l0402">категории</a>: сигнальные, канальные и разделяемую память. Через канальные средства 
  коммуникации информация может передаваться в виде <a href="#l04030302"> потока 
  данных</a> или в виде <a href="#l04030302"> сообщений</a> и накапливаться в 
  <a href="#l04030301"> буфере определенного размера</a>. Для 
  <a href="#l040301">инициализации общения процессов</a> и его <a href="#l040305"> прекращения</a> 
  могут потребоваться специальные действия со стороны операционной системы. Процессы, 
  связываясь друг с другом, могут использовать <a href="#l040301">непрямую, прямую 
  симметричную и прямую асимметричную схемы адресации</a>. Существуют 
  <a href="#l040302">одно- и двунаправленные средства передачи информации</a>. Средства коммуникации 
  обеспечивают <a href="#l040304">надежную связь</a>, если при общении процессов 
  не происходит потери информации, не происходит повреждения информации, не появляется 
  лишней информации, не нарушается порядок данных. </FONT></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman" size=3>Усилия, направленные на 
  ускорение решения задач в рамках классических операционных систем, привели к 
  появлению новой абстракции внутри понятия “процесс” -
<a href="#l0404"> нити исполнения или просто 
  нити</a>. Нити процесса разделяют его программный код, глобальные переменные и системные 
  ресурсы, но каждая нить имеет свой собственный программный счетчик, свое содержимое 
  регистров и свой собственный стек. Теперь процесс представляется как совокупность 
  взаимодействующих нитей и выделенных ему ресурсов</font><FONT size=3>.</FONT><FONT FACE="Times New Roman" size=3> 
  Нити могут порождать новые нити внутри своего процесса, они имеют состояния, 
  аналогичные состояниям процесса, и могут переводиться операционной системой 
  из одного состояния в другое. В системах, поддерживающих нити на уровне ядра, 
  планирование использования процессора осуществляется в терминах нитей исполнения, 
  а управление остальными системными ресурсами в терминах процессов. Накладные 
  расходы на создание новой нити и на переключение контекста между нитями одного 
  процесса существенно меньше, чем на те же</FONT><FONT size=3> </FONT><FONT FACE="Times New Roman" size=3>самые 
  действия для процессов, что позволяет на однопроцессорной вычислительной системе 
  ускорять решение задач с помощью организации работы нескольких взаимодействующих 
  нитей.</font></P>
  <P align="center"><a href="../03/ch3.htm"> Предыдущая глава</a> | <a href="../os.html">Программа курса</a> | 
 <a href="../05/ch5.htm"> Следующая глава</a></P>
</BODY>
</HTML>
