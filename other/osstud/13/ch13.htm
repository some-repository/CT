<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Глава 13</TITLE>
</HEAD>

<body bgcolor="#FFFFFF">
<basefont face="Times New Roman, sans-serif, Courier, mono" size="3">
<h3 align="center"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="6"> 
  Часть V. Ввод-вывод </FONT></B></h3>
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="4"><a name="l1300"></a>Глава 
  13. Система управления вводом-выводом</FONT></B></P>

<p align="center"><a href="../12/ch12.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../14/ch14.htm"> Следующая глава</a></p>

<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Функционирование любой 
  вычислительной системы обычно сводится к выполнению двух видов работы: обработке 
  информации и операций по осуществлению ее ввода-вывода. Поскольку в рамках модели, 
  принятой в этом курсе, все, что выполняется в вычислительной системе, организовано 
  как набор процессов, эти два вида работы выполняются процессами. Процессы занимаются 
  обработкой информации и выполнением операций ввода-вывода. </FONT></P>

<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Содержание 
  понятий “обработка информации” и “операции ввода-вывода” зависит от того, с 
  какой точки зрения мы смотрим на них. С точки зрения программиста под “обработкой 
  информации” понимается выполнение команд процессора над данными, лежащими в 
  памяти независимо от уровня иерархии – в регистрах, кэше, оперативной или вторичной 
  памяти. Под “операциями ввода-вывода” программист понимает обмен данными между 
  памятью и устройствами, являющимися внешними по отношению к памяти и процессору, 
  такими как магнитные ленты, диски, монитор, клавиатура, таймер. С точки зрения 
  операционной системы “обработкой информации” являются только операции, совершаемые 
  процессором над данными, находящимися в памяти на уровне иерархии не ниже, чем 
  оперативная память. Все остальное относится к “операциям ввода-вывода”. Чтобы 
  совершить операции над данными, временно расположенными во вторичной памяти, 
  операционная система, <a href="../08/ch8.htm">как мы обсуждали в части III нашего 
  курса,</a> сначала производит их подкачку в оперативную память, а лишь затем 
  процессор совершает необходимые действия.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Рассмотрение 
  того, что именно делает процессор при обработке информации, как он решает задачу 
  и какой алгоритм выполняет, не входит в задачи нашего курса. Это скорее относится 
  к курсу “Алгоритмы и структуры данных”, с которого обычно начинается изучение 
  информатики. Как операционная система управляет обработкой информации, мы разобрали 
  в <a href="../02/ch2.htm">части II</a>, в деталях <a href="../02/ch2.htm#l0202">описав 
  два состояния процессов</a> – <B><I>исполнение</i></B> (а что его описывать 
  то?) и <B><I>готовность</i></B> (очереди планирования и т.д.), а также правила, 
  по которым осуществляется перевод процессов из одного состояния в другое (<a href="../03/ch3.htm#l0305">алгоритмы 
  планирования процессов</a>). </FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Данная глава будет посвящена 
  второму виду работы вычислительной системы - операциям ввода-вывода. Мы разберем, 
  что происходит в компьютере при выполнении операций ввода-вывода, и как операционная 
  система управляет их выполнением. При этом для простоты мы будем считать, что 
  объем оперативной памяти в вычислительной системе достаточно большой, т.е. все 
  процессы полностью располагаются в оперативной памяти, и поэтому понятия “операция 
  ввода-вывода” с точки зрения операционной системы и с точки зрения пользователя 
  содержательно совпадают. Такое предположение не снижает общности нашего рассмотрения, 
  так как подкачка информации из вторичной памяти в оперативную память и обратно 
  обычно строится по тому же принципу, что и все прочие операции ввода-вывода.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Прежде чем говорить о работе 
  операционной системы при осуществлении операций ввода-вывода, нам придется вспомнить 
  часть сведений из курса “Архитектура современных ЭВМ и язык ассемблера”, чтобы 
  понять, как осуществляется передача информации между оперативной памятью и внешним 
  устройством, и почему для подключения к вычислительной системе новых разнообразных 
  устройств ее не требуется перепроектировать.</FONT></P>

  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1301"></a>13.1 
  Физические принципы организации ввода-вывода.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Существует много разнообразных 
  устройств, которые могут взаимодействовать с процессором и памятью: таймер, 
  жесткие диски, клавиатура, дисплеи, мышь, модемы и т.&nbsp;д., вплоть до устройств 
  отображения и ввода информации в авиационно-космических тренажерах. Часть этих 
  устройств может быть встроена внутрь корпуса компьютера, часть - вынесена за 
  его пределы, и общаться с компьютером через различные линии связи: кабельные, 
  оптоволоконные, радиорелейные, спутниковые и т.д. Конкретный набор устройств 
  и способы их подключения определяются целями функционирования вычислительной 
  системы, желаниями и финансовыми возможностями пользователя. Несмотря на все 
  многообразие устройств, управление их работой и обмен информацией с ними строятся 
  на относительно небольшом количестве принципов, которые мы постараемся разобрать 
  в этом разделе.</FONT></P>

  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130101"></a>13.1.1. 
  Общие сведения об архитектуре компьютера.</FONT></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В 
  простейшем случае процессор, память и многочисленные внешние устройства связаны 
  большим количеством электрических соединений - </FONT><I><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">линий</font></I><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">, 
  которые в совокупности принято называть <I>локальной магистралью</I> компьютера. 
  Внутри локальной магистрали линии, служащие для передачи сходных сигналов и 
  предназначенные для выполнения сходных функций, принято группировать в <I>шины</I>. 
  При этом понятие шины включает в себе не только набор проводников, но и набор 
  жестко заданных протоколов, определяющий перечень сообщений, который может быть 
  передан с помощью электрических сигналов по этим проводникам. В современных 
  компьютерах выделяют, как минимум, три шины:</font></P>
<dir><ol>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Шину данных, состоящую из линий данных 
    и служащую для передачи информации между процессором и памятью, процессором 
    и устройствами ввода-вывода, памятью и внешними устройствами.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Адресную шину, состоящую из линий адреса 
    и служащую для задания адреса ячейки памяти или указания устройства ввода-вывода, 
    участвующих в обмене информацией.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Шину управления, состоящую из линий 
    управления локальной магистралью и линий ее состояния, определяющих поведение 
    локальной магистрали. В некоторых архитектурных решениях линии состояния выносятся 
    из этой шины в отдельную шину состояния.</FONT></LI>
</ol></dir>
<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Количество 
  линий, входящих в состав шины, принято называть <I>разрядностью</I> (<I>шириной</I>) 
  этой шины. Ширина адресной шины, например, определяет максимальный размер оперативной 
  памяти, которая может быть установлена в вычислительной системе. Ширина шины 
  данных определяет максимальный объем информации, которая за один раз может быть 
  получена или передана по этой шине.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Операции обмена информацией 
  осуществляются при одновременном участии всех шин. Рассмотрим, к примеру, действия, 
  которые должны быть выполнены для передачи информации из процессора в память. 
  В простейшем случае необходимыми являются три действия:</FONT></P>
<dir><ol>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">На адресной шине процессор должен выставить 
    сигналы, соответствующие адресу ячейки памяти, в которую будет осуществляться 
    передача информации.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">На шину данных процессор должен выставить 
    сигналы, соответствующие информации, которая должна быть записана в память.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">После выполнения действий 1 и 2 на шину 
    управления выставляются сигналы, соответствующие операции записи и работе 
    с памятью, что приведет к занесению необходимой информации по требуемому адресу.</FONT></LI>
</ol></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Естественно, что приведенные 
  выше действия являются необходимыми, но недостаточными при рассмотрении работы 
  конкретных процессоров и микросхем памяти. Конкретные архитектурные решения 
  могут требовать дополнительных действий, например, выставления на шину управления 
  сигналов частичного использования шины данных (для передачи меньшего количества 
  информации, чем позволяет ширина этой шины), выставления сигнала готовности 
  магистрали после завершения записи в память, разрешающего приступить к новой 
  операции, и т.д., однако общие принципы выполнения операции записи в память 
  остаются одинаковыми. </FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130101a"></a>В 
  то время как память легко можно представить себе в виде последовательности пронумерованных 
  адресами ячеек, локализованных внутри одной микросхемы или набора микросхем, 
  подобный подход неприменим к устройствам ввода-вывода. Внешние устройства разнесены 
  пространственно и могут подключаться к локальной магистрали в одной точке или 
  множестве точек, получивших название <I>портов ввода-вывода. </I>Тем не менее, 
  точно так же, как ячейки памяти взаимно однозначно отображались в адресное пространство 
  памяти, порты ввода-вывода можно взаимно однозначно отобразить в другое адресное 
  пространство – адресное пространство ввода-вывода. При этом каждый порт ввода-вывода 
  получает свой номер или адрес в этом пространстве. В некоторых случаях, когда 
  адресное пространство памяти (размер которого определяется шириной адресной 
  шины) задействовано не полностью (остались адреса, которым не соответствуют 
  физические ячейки памяти), и протоколы работы с внешним устройством совместимы 
  с протоколами работы с памятью, часть портов ввода-вывода может быть отображена 
  непосредственно в адресное пространство памяти (так, например, поступают с видеопамятью 
  дисплеев), правда тогда эти порты уже не принято называть портами. Надо отметить, 
  что при отображении портов в адресное пространство памяти для организации доступа 
  к ним в полной мере могут быть задействованы существующие механизмы защиты памяти 
  без организации специальных защитных устройств.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В ситуации прямого отображения 
  портов ввода-вывода в адресное пространство памяти действия, требуемые для записи 
  информации и управляющих команд в эти порты или для чтения данных из них и их 
  состояний, ничем не отличаются от действий, производимых для передачи информации 
  между оперативной памятью и процессором, и для их выполнения применяются те 
  же самые команды. Если же порт отображен в адресное пространство ввода-вывода, 
  то процесс обмена информацией инициируется специальными командами ввода-вывода 
  и включает в себя несколько другие действия. Например, для передачи данных в 
  порт необходимо выполнить следующее:</FONT></P>
<dir><ol>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">На адресной шине процессор должен выставить 
    сигналы, соответствующие адресу порта, в который будет осуществляться передача 
    информации, в адресном пространстве ввода-вывода.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">На шину данных процессор должен выставить 
    сигналы, соответствующие информации, которая должна быть передана в порт.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">После выполнения действий 1 и 2 на шину 
    управления выставляются сигналы, соответствующие операции записи и работе 
    с устройствами ввода-вывода (переключение адресных пространств!), что приведет 
    к передаче необходимой информации в требуемый порт.</FONT></LI>
</ol></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Существенным отличием памяти 
  от устройств ввода-вывода является то, что занесение информации в память является 
  окончанием операции записи, в то время как занесение информации в порт зачастую 
  является инициализацией реального совершения операции ввода-вывода. Что именно 
  должны совершать устройства, приняв 
  информацию через свой порт, и каким именно образом они должны поставлять информацию 
  для чтения из порта, определяется электронными схемами устройств, получившими 
  названия <I>контроллеров</I>. Контроллер может непосредственно управлять отдельным 
  устройством (например, контроллер диска), а может управлять несколькими устройствами, 
  связываясь с их контроллерами посредством специальных шин ввода-вывода (шина 
  IDE, шина SCSI 
  и т.д.).</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Современные вычислительные 
  системы могут иметь разнообразную архитектуру, множество шин и магистралей, 
  мосты для перехода информации от одной шины к другой и т.п. С точки зрения нашего 
  рассмотрения важными является только следующие моменты:</FONT></P>
<dir><ul type="square">
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Устройства ввода-вывода подключаются 
    к системе через порты.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Могут существовать два адресных пространства: 
    пространство памяти и пространство ввода-вывода.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Порты, как правило, отображаются в адресное 
    пространство ввода-вывода и, иногда, непосредственно в адресное пространство 
    памяти.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Использование того или иного адресного 
    пространства определяется типом команды, выполняемой процессором, или типом 
    ее операндов.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Физическим управлением устройством ввода-вывода, 
    передачей информации через порт, и выставлением некоторых сигналов на магистрали 
    занимается контроллер устройства.</FONT></LI>
 </ul></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Именно единообразие подключения 
  внешних устройств к вычислительной системе является одной из составляющих идеологии, 
  позволяющих добавлять новые устройства без перепроектирования всей системы.</FONT></P>

  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130102"></a>13.1.2. 
  Структура контроллера устройства.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Контроллеры устройств 
    ввода-вывода весьма различны как по своему внутреннему строению, так и по 
    исполнению (от одной микросхемы до специализированной вычислительной системы 
    со своим процессором, памятью и т.&nbsp;д.), поскольку им приходится управлять 
    совершенно разными приборами. Не вдаваясь в детали этих различий, мы выделим 
    некоторые общие черты контроллеров, необходимые им для взаимодействия с вычислительной 
    системой. Обычно каждый контроллер имеет, по крайней мере, четыре внутренних 
    регистра, называемых регистрами <B><I>состояния</i></B>, 
    <B><I>управления</i></B>, 
    <B><I>входных данных</i></B> 
    и <B><I>выходных данных</i></B>. Для доступа к содержимому этих регистров 
    вычислительная система может использовать один или несколько портов, что не 
    существенно для нас. Для простоты изложения будем считать, что каждому регистру 
    соответствует свой собственный порт. </font></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Регистр <B><I>состояния</i></B> 
    содержит биты, значение которых определяется состоянием устройства ввода-вывода, 
    и которые доступны только для чтения вычислительной системой. Эти биты индицируют 
    завершение выполнения текущей команды на устройстве (<B><I>бит занятости</i></B>), 
    наличие очередного данного в регистре выходных данных (<B><I>бит готовности 
    данных</i></B>), возникновения ошибки при выполнении команды (<B><I>бит ошибки</i></B>) 
    и т.д.</FONT></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Регистр <B><I>управления</i></B> 
    получает данные, которые записываются вычислительной системой для инициализации 
    устройства ввода-вывода или выполнения очередной команды, а также изменения 
    режима работы устройства. Часть битов в этом регистре может быть отведена 
    под код выполняемой команды, часть битов кодировать режим работы устройства, 
    бит <B><I>готовности команды</i></B> свидетельствует о том, что можно приступить 
    к ее выполнению.</FONT></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Регистр <B><I>выходных 
    данных</i></B> служит для помещения в него данных для чтения вычислительной 
    системой, а регистр <B><I>входных данных</i></B> предназначен для помещения 
    в него информации, которая должна быть выведена на устройство. Обычно емкость 
    этих регистров не превышает ширину линии данных (а чаще всего меньше ее), 
    хотя некоторые контроллеры могут использовать в качестве регистров очередь 
   FIFO для буферизации 
    поступающей информации.</font></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Разумеется, набор регистров 
    и составляющих их битов является приблизительным, он призван послужить нам 
    моделью для описания процесса передачи информации от вычислительной системы 
    к внешнему устройству и обратно, но в том или ином виде он обычно присутствует 
    во всех контроллерах устройств.</FONT></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130103"></a>13.1.3. 
  Опрос устройств и прерывания. Исключительные ситуации и системные вызовы</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Построив модель контроллера 
  и, представляя себе, что скрывается за словами “прочитать информацию из порта” 
  и “записать информацию в порт”, мы готовы к рассмотрению процесса взаимодействия 
  устройства и процессора. Как и в предыдущих случаях, примером нам послужит команда 
  записи, теперь уже записи или вывода данных на внешнее устройство. В нашей модели 
  для вывода информации, помещающейся в регистр <B><I>входных данных</i></B>, 
  без проверки успешности вывода процессор и контроллер должны общаться следующим 
  образом:</FONT></P>
<dir><ol>
  <li>
      <p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Процессор 
        в цикле читает информацию из порта регистра <B><I>состояний</i></B> и 
        проверяет значение <B><I>бита занятости</i></B>. Если <I><b>бит занятости</b></I> 
        установлен, то это означает, что устройство еще не завершило предыдущую 
        операцию, и процессор уходит на новую итерацию цикла. Если <B><I>бит занятости</i></B> 
        сброшен, то устройство готово к выполнению новой операции и процессор 
        переходит на следующий шаг.</FONT>
    </LI>
  <li>
      <p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Процессор 
        записывает код команды вывода в порт регистр <B><I>управления</i></B>.</font>
    </LI>
  <li>
      <p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Процессор 
        записывает данные в порт регистра <B><I>входных данных</i></B>.</font>
    </LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Процессор устанавливает <B><I>бит готовности 
    команды</i></B>. В следующих шагах процессор не задействован.</FONT></LI>
  <li>
      <p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Когда 
        контроллер замечает, что <B><I>бит готовности команды</i></B> установлен, 
        он устанавливает <B><I>бит занятости</i></B>.</font>
    </LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Контроллер анализирует код команды в 
    регистре <B><I>управления</i></B> и обнаруживает, что это команда вывода. 
    Он берет данные из регистра <B><I>входных данных</i></B> и инициирует выполнение 
    команды.</FONT></LI>
  <li>
      <p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">После 
        завершения операции контроллер обнуляет <B><I>бит готовности команды</i></B>.</font>
    </LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">При успешном завершении операции контроллер 
    обнуляет <B><I>бит ошибки</i></B> в регистре состояния, при неудачном завершении 
    команды устанавливает его.</FONT></LI>
  <li>
      <p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Контроллер 
        сбрасывает <B><I>бит занятости</i></B>.</font>
    </LI>
</ol></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">При необходимости вывода 
  новой порции информации все эти шаги повторяются. Если процессор интересует 
  корректно или не корректно была выведена информация, то после шага 4 он должен 
  в цикле считывать информацию из порта регистра <B><I>состояний</i></B> до тех 
  пор, пока не будет сброшен <B><I>бит занятости</i></B> устройства, после чего 
  проанализировать состояние <B><I>бита ошибки</i></B>.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Как 
  видим, на первом шаге (и, возможно, после шага 4) процессор ожидает освобождения 
  устройства, непрерывно опрашивая значение <B><I>бита занятости</i></B>. Такой 
  способ взаимодействия процессора и контроллера получил название <i>polling</i> 
  или, в русском переводе, <i>способа опроса устройств</i>. Если скорости работы 
  процессора и устройства ввода-вывода примерно равны, то это не приводит к существенному 
  уменьшению полезной работы, совершаемой процессором. Если же скорость работы 
  устройства существенно меньше скорости процессора, то указанная техника резко 
  снижает производительность системы 
  и необходимо применять другой архитектурный подход.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  <a name="l130103a"></a>Для того чтобы процессор не дожидался состояния готовности 
  устройства ввода-вывода в цикле, а мог выполнять в это время другую работу, 
  необходимо, чтобы устройство само умело сигнализировать процессору о своей готовности. 
  Технический механизм, который позволяет внешним устройствам оповещать процессор 
  о завершении команды вывода или команды ввода, получил название механизма <I>прерываний</I>. 
  </font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В простейшем случая для 
  реализации механизма прерываний необходимо к имеющимся у нас шинам локальной 
  магистрали добавить еще одну линию, соединяющую процессор и устройства ввода-вывода 
  – линию прерываний. По завершении выполнения операции внешнее устройство выставляет 
  на эту линию специальный сигнал, по которому процессор после выполнения очередной 
  команды (или после завершения очередной итерации при выполнении цепочечных команд, 
  т.е. команд, повторяющихся циклически со сдвигом по памяти) изменяет свое поведение. 
  Вместо выполнения очередной команды из потока команд,
  он частично сохраняет содержимое своих регистров и переходит на выполнение программы 
  обработки прерывания, расположенной по заранее оговоренному адресу. При наличии 
  только одной линии прерываний процессор при выполнении этой программы должен 
  опросить состояние всех устройств ввода-вывода, чтобы определить от какого именно 
  устройства пришло прерывание (polling 
  прерываний!), выполнить необходимые действия (например, вывести в это устройство 
  очередную порцию информации или перевести соответствующий процесс из состояния 
  <B><I>ожидание</i></B> в состояние <B><I>готовность</i></B>) и сообщить устройству, 
  что прерывание обработано (снять прерывание).</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В большинстве современных 
  компьютеров процессор стараются полностью освободить от необходимости опроса 
  внешних устройств, в том числе и от определения с помощью опроса устройства, 
  сгенерировавшего сигнал прерывания. Устройства сообщают о своей готовности процессору 
  не напрямую, а через специальный контроллер прерываний, при этом для общения 
  с процессором он может использовать не одну линию, а целую шину прерываний. 
  Каждому устройству присваивается свой номер прерывания, который при возникновении 
  прерывания контроллер прерывания заносит в свой регистр состояния и, возможно, 
  после распознавания процессором сигнала прерывания и получения от него специального 
  запроса, выставляет на шину прерываний или шину данных для чтения процессором. 
  Номер прерывания обычно служит индексом в специальной таблице прерываний, лежащей 
  по адресу, задаваемому при инициализации вычислительной системы, и содержащей 
  адреса программ 
  обработки прерываний – <I>вектора</I> прерываний. Для распределения устройств 
  по номерам прерываний необходимо, чтобы от каждого устройства к контроллеру 
  прерываний шла специальная линия, соответствующая одному номеру прерывания. 
  При наличии множества устройств, такое подключение становится невозможным, и 
  на один проводник (один номер прерывания) подключается несколько устройств. 
  В этом случае процессор при обработке прерывания все равно вынужден заниматься 
  опросом устройств для определения устройства, выдавшего прерывание, но в существенно 
  меньшем объёме. Обычно при установке в систему нового устройства ввода-вывода 
  требуется аппаратно или программно определить, каким будет номер прерывания, 
  вырабатываемый этим устройством.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a href="../05/ch5.htm#l0501">Когда 
  мы с вами рассматривали кооперацию процессов и взаимоисключения</a>, <a href="../05/ch5.htm#l050302">мы 
  говорили о существовании критических секций внутри ядра операционной системы</a>, 
  при выполнении которых необходимо исключить всякие прерывания от внешних устройств. 
  Для запрещения прерываний, а, точнее, для невосприимчивости процессора к внешним 
  прерываниям, обычно существуют специальные команды, которые могут маскировать 
  (запрещать) все или некоторые из прерываний устройств ввода-вывода. В то же 
  время, определенные кризисные ситуации в вычислительной системе (например, неустранимый 
  сбой в работе оперативной памяти), должны требовать ее немедленной реакции. 
  Такие ситуации вызывают прерывания, которые невозможно замаскировать или запретить 
  и которые поступают в процессор по специальной линии шины прерываний, называемой 
  линией немаскируемых прерываний (NMI – Non-Maskable Interrupt).</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Не все внешние устройства 
  являются одинаково важными с точки зрения вычислительной системы (“все животные 
  равны, но некоторые равнее других”). Соответственно, некоторые прерывания являются 
  более существенными, чем другие. Контроллер прерываний обычно позволяет устанавливать 
  приоритеты для прерываний от внешних устройств. При почти одновременном возникновении 
  прерываний от нескольких устройств (во время выполнения одной и той же команды 
  процессора), процессору сообщается номер наиболее приоритетного прерывания, 
  для его обслуживания в первую очередь. Менее приоритетное прерывание при этом 
  не пропадает, о нем процессору будет доложено после обработки более приоритетного 
  прерывания. Более того, при обработке возникшего прерывания процессор может 
  быть извещен о возникновении прерывания с более высоким приоритетом, и переключиться 
  на его обработку. </FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
 <img border="0" src="../images/znak.gif" align="left" vspace="8" alt="Nota bene" hspace="10"> 
<a name="l130103a1"></a>Механизм обработки прерываний, 
  по которому процессор прекращает выполнение команд в обычном режиме и, частично 
  сохранив свое состояние, ответвляется на выполнение других действий, оказался 
  настолько удобен, что зачастую разработчики процессоров используют их и для 
  других целей. Хотя эти случаи и не относятся к операциям ввода-вывода, мы вынуждены 
  упомянуть их здесь, для того, чтобы их не путали с прерываниями. Похожим образом 
  процессор обрабатывает исключительные ситуации и программные прерывания.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Для внешних прерываний 
  характерны следующие особенности:</FONT></P>
<dir><ul type="square">
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Внешнее прерывание обнаруживается процессором 
    между выполнением команд (или между итерациями в случае выполнения цепочечных 
    команд).</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Процессор при переходе на обработку 
    прерывания сохраняет часть своего состояния перед выполнением <B><U>следующей</u></B> 
    команды.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Прерывания происходят <B><U>асинхронно</u></B> 
    с работой процессора и <B><U>непредсказуемо</u></B>, программист ни коим образом 
    не может предугадать, в каком именно месте работы программы произойдет прерывание.</FONT></LI>
</ul></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130103b"></a>Исключительные 
  ситуации возникают во время выполнения процессором команды. К их числу относятся 
  ситуации переполнения, деления на ноль, обращения к отсутствующей странице памяти 
  (<a href="../10/ch10.htm#l1001">см. часть&nbsp;III</a>) и т.д. Для исключительных 
  ситуаций характерно следующее: </FONT></P>
<dir><ul type="square">
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Исключительные ситуации обнаруживаются 
    процессором во время выполнения команд.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Процессор при переходе на выполнение 
    исключительной ситуации сохраняет часть своего состояния перед выполнением 
    <B><U>текущей </u></B>команды.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Исключительные ситуации возникают <B><U>синхронно</u></B> 
    с работой процессора, но <B><U>непредсказуемо</u></B> для программиста, если 
    только тот специально не заставил процессор делить некоторое число на ноль.</FONT></LI>
</ul></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130103c"></a>Программные 
  прерывания возникают после выполнения специальных команд, как правило, для выполнения 
  привилегированных действий внутри системных вызовов. Программные прерывания 
  имеют следующие свойства:</FONT></P>
<dir><ul type="square">
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Программное прерывание происходит в 
    результате выполнения специальной команды.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Процессор при выполнении программного 
    прерывания сохраняет свое состояние перед выполнением <B><U>следующей</u></B> 
    команды.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Программные прерывания, естественно, 
    возникают <B><U>синхронно</u></B> с работой процессора и <B><U>абсолютно предсказуемы</u></B> 
    программистом.</FONT></LI>
</ul></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Надо честно сказать, что 
  похожие механизмы обработки внешних прерываний, исключительных ситуаций и программных 
  прерываний лежат целиком на совести разработчиков процессоров. Существуют вычислительные 
  системы, где все эти три ситуации обрабатываются по-разному.</FONT></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130104"></a>13.1.4. 
  Прямой доступ к памяти (Direct Memory Access – DMA).</font></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Использование 
  механизма прерываний позволяет разумно загружать процессор в то время, когда 
  устройство ввода-вывода занимается своей работой. Однако запись или чтение большого 
  количества информации из адресного пространства ввода-вывода (например, с диска) 
  приводят к большому количеству операций ввода-вывода, которые должен совершать 
  процессор. Для разгрузки процессора от операций последовательного вывода данных 
  из оперативной памяти или последовательного ввода в нее был предложен механизм 
  прямого доступа внешних устройств к памяти – ПДП или Direct Memory Access – 
  DMA. Давайте кратко рассмотрим, как работает этот механизм.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Для 
  того чтобы какое-либо устройство помимо процессора могло записать информацию 
  в память или прочитать ее из памяти, необходимо чтобы это устройство могло забрать 
  у процессора управление локальной магистралью для выставления соответствующих 
  сигналов на шины адреса, данных и управления. Для централизации эти обязанности 
  обычно возлагаются не на каждое устройство в отдельности, а на специальный контроллер 
  – контроллер прямого доступа к памяти. Контроллер прямого доступа к памяти имеет 
  несколько спаренных линий – каналов DMA, которые могут подключаться к различным 
  устройствам. Перед началом использования прямого доступа к памяти этот контроллер 
  необходимо запрограммировать, записав в его порты информацию о том, какой канал 
  или каналы предполагается задействовать, какие операции они будут совершать, 
  какой адрес памяти является начальным для передачи информации, и какое количество 
  информации должно быть передано. Получив по одной из линий каналов DMA сигнал 
  запроса на передачу данных от внешнего устройства, контроллер по шине управления 
  сообщает процессору о желании взять на себя управление локальной магистралью. 
  Процессор, возможно через некоторое время, необходимое для завершения его действий 
  с магистралью, передает управление ею контроллеру DMA. известив его специальным 
  сигналом. Контроллер DMA выставляет на адресную шину адрес памяти для передачи 
  очередной порции информации и по второй линии канала прямого доступа к памяти 
  сообщает устройству о готовности магистрали к передаче данных. После этого, 
  используя шину данных и шину управления, контроллер DMA, устройство ввода-вывода 
  и память осуществляют процесс обмена информацией. Затем контроллер прямого доступа 
  к памяти извещает процессор о своем отказе от управления магистралью, и тот 
  берет руководящие функции на себя. При передаче большого количества данных весь 
  процесс повторяется циклически. </font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">При 
  прямом доступе к памяти процессор и контроллер DMA по очереди управляют локальной 
  магистралью. Это, конечно, несколько снижает производительность процессора, 
  так как при выполнении некоторых команд или при чтении очередной порции команд 
  во внутренний кэш он должен поджидать освобождения магистрали, но в целом производительность 
  вычислительной системы существенно возрастает. </font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">При подключении к системе 
  нового устройства, которое умеет использовать прямой доступ к памяти, обычно 
  необходимо программно или аппаратно задать номер канала   DMA, 
  к которому будет приписано устройство. В отличие от прерываний, где один номер 
  прерывания мог соответствовать нескольким устройствам, каналы   DMA     
  всегда находятся в монопольном владении устройств.</font></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1302"></a>13.2. 
  Логические принципы организации ввода-вывода.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Рассмотренные в предыдущем 
  разделе физические механизмы взаимодействия устройств ввода-вывода с вычислительной 
  системой позволяют понять, почему разнообразные внешние устройства легко могут 
  быть добавлены в существующие компьютеры. Все, что необходимо сделать пользователю 
  при подключении нового устройства - это отобразить порты устройства в соответствующее 
  адресное пространство, определить какой номер будет соответствовать прерыванию, 
  генерируемому устройством, и, если нужно, закрепить за устройством некоторый 
  канал   DMA.  Для 
  нормального функционирования   hardware     
  этого будет достаточно. Однако мы с вами до сих пор ничего не говорили о том, 
  как должна быть построена подсистема управления вводом-выводом в операционной 
  системе для легкого и безболезненного добавления новых устройств, и какие функции 
  вообще обычно на нее возлагаются. Выяснению этого вопроса и посвящен настоящий 
  раздел.</font></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130201"></a>13.2.1. 
  Структура системы ввода-вывода. </FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Если поручить неподготовленному 
  пользователю сконструировать систему ввода-вывода, способную работать со всем 
  множеством внешних устройств, то, скорее всего, он окажется в ситуации, в которой 
  находились биологи и зоологи до появления трудов Линнея. Все устройства разные, 
  отличаются по выполняемым функциям и своим характеристикам, и кажется, что принципиально 
  невозможно создать систему, которая без больших постоянных переделок позволяла 
  бы охватывать все многообразие видов. Вот перечень лишь несколько направлений 
  (далеко не полный), по которым различаются устройства:</FONT></P>
<dir><ul type="square">
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Скорость обмена информацией может варьироваться 
    в диапазоне от нескольких байт в секунду (клавиатура) до нескольких гигабайт 
    в секунду (сетевые карты).</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Некоторые устройства могут быть использованы 
    параллельно несколькими процессами (являются разделяемыми), в то время как 
    другие требуют монопольного захвата процессом.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Устройства могут запоминать выведенную 
    информацию для ее последующего ввода или не обладать этой функцией. Устройства, 
    запоминающие информацию, в свою очередь, могут дифференцироваться по формам 
    доступа к сохраненной информации: обеспечивать к ней последовательный доступ 
    в жестко заданном порядке или уметь находить и передавать только необходимую 
    порцию данных.</FONT></LI>
  <li>
      <p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Часть 
        устройств умеет передавать данные только по одному байту последовательно 
        (<I>символьные устройства</I>), а часть устройств умеет передавать блок 
        байт как единое целое (<I>блочные устройства</I>). </font>
    </LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Существуют устройства, предназначенные 
    только для ввода информации, устройства, предназначенные только для вывода 
    информации, и устройства, которые могут совершать и ввод, и вывод.</FONT></LI>
</ul></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В области технического 
  обеспечения удалось выделить несколько основных принципов взаимодействия внешних 
  устройств с вычислительной системой, т.&nbsp;е. создать единый интерфейс для 
  их подключения, возложив все специфические действия на контроллеры самих устройств. 
  Тем самым конструкторы вычислительных систем переложили головную боль, связанную 
  с подключением внешней аппаратуры, на разработчиков самой аппаратуры, заставляя 
  их придерживаться определенного стандарта.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Похожий 
  подход оказался продуктивным и в области программного подключения устройств 
  ввода-вывода. Подобно тому, как Линнею удалось заложить основы систематики растительного 
  и животного мира, разделив все живое в природе на относительно небольшое число 
  классов и отрядов, мы можем разделить устройства на относительно небольшое число 
  типов, отличающихся по набору операций, которые могут быть ими выполнены, считая 
  все остальные различия несущественными. Мы можем затем специфицировать интерфейсы 
  между ядром операционной системы, осуществляющим некоторую общую политику ввода-вывода, 
  и программными частями, непосредственно управляющими устройствами, для каждого 
  из таких типов. Более того, разработчики операционных систем получают возможность 
  освободиться от написания и тестирования этих специфических программных частей, 
  получивших название <I>драйверов</I>, передав эту деятельность производителям 
  самих внешних устройств. Фактически мы приходим к использованию принципа уровневого 
  или слоеного построения системы управления вводом-выводом для операционной системы 
  (см. рис. 13.1). </FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Два 
  нижних уровня этой слоеной системы составляет hardware: сами устройства, непосредственно 
  выполняющие операции, и их контроллеры, служащие для организации совместной 
  работы устройств и остальной вычислительной системы. Следующий уровень составляют 
  драйвера устройств ввода-вывода, скрывающие от разработчиков операционных систем 
  особенности функционирования конкретных приборов и обеспечивающие четко определенный 
  интерфейс между hardware и вышележащим уровнем – уровнем базовой подсистемы 
  ввода-вывода, которая, в свою очередь, предоставляет механизм взаимодействия 
  между драйверами и программной частью вычислительной системы в целом.</font></P>
<P ALIGN="center"><img src="images/sr13-1.gif" width="716" height="428"></P>
<P ALIGN="CENTER"><FONT FACE="Times New Roman, sans-serif, Courier, mono" SIZE=2>Рис 13.1. Структура системы 
  ввода-вывода</FONT><br><br></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В последующих разделах 
  мы подробнее рассмотрим организацию и функции набора драйверов и базовой подсистемы 
  ввода-вывода.</FONT></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130202"></a>13.2.2. 
  Систематизация внешних устройств и интерфейс между базовой подсистемой ввода-вывода 
  и драйверами.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Как и система видов Линнея, 
  система типов устройств является далеко не полной и не строго выдержанной. Устройства 
  обычно принято разделять по преобладающему типу интерфейса на следующие типы:</FONT></P>
<dir><ul type="square">
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">символьные (клавиатура, модем, терминал 
    и т.п.);</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">блочные (магнитные и оптические диски 
    и ленты, и т.д.);</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">сетевые (сетевые карты);</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">все остальные (таймеры, графические 
    дисплеи, телевизионные устройства, видеокамеры и т.п.);</FONT></LI>
</ul></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Такое деление является 
  весьма условным. В некоторых операционных системах сетевые устройства могут 
  не выделяться в отдельную группу, в некоторых – отдельные группы составляют 
  звуковые устройства и видеоустройства и т.д. Некоторые группы в свою очередь 
  могут разбиваться на подгруппы: подгруппа жестких дисков, подгруппа мышек, подгруппа 
  принтеров. Нас такие детали не интересуют. Нашей целью не является построение 
  стройной и единственно       возможной 
  систематизации всех возможных устройств, которые могут быть подключены к вычислительной 
  системе. Единственное, для чего нам понадобится эта классификация – так это 
  для иллюстрации того, что устройства могут быть разделены на группы по выполняемым 
  ими функциям, и для понимания функций драйверов и интерфейса между ними и базовой 
  подсистемой ввода-вывода.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Для этого мы рассмотрим 
  только две группы устройств: символьные и блочные. Как уже упоминалось в предыдущем 
  разделе, символьные устройства – это устройства, которые умеют передавать данные 
  только последовательно байт за байтом, а блочные устройства – это устройства, 
  которые могут передавать блок байт как единое целое.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  <a name="l130202a"></a>К символьным устройствам обычно относятся устройства 
  ввода информации, которые спонтанно, т.е. во времена непредсказуемые вычислительной 
  системой, генерируют входные данные: клавиатура, мышь, модем, джойстик. К ним 
  же относятся и устройства вывода информации, для которых характерно представление 
  данных в виде линейного потока: принтеры, звуковые карты и т.д. По своей природе 
  символьные устройства обычно умеют совершать две общих операции: ввести символ 
  (байт) и вывести символ (байт) – <B><I>get</i></B> и <B><I>put</i></B>.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Для блочных устройств, 
  таких как магнитные и оптические диски, ленты и т.п., естественными являются 
  операции чтения и записи блока информации – <B><I>read </i></B>и 
 <B><I>write</i></B>, 
  а также, для устройств прямого доступа, операция поиска требуемого блока информации 
  – <B><I>seek</i></B>.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Драйвера символьных и блочных 
  устройств должны предоставлять базовой подсистеме ввода-вывода функции для осуществления 
  описанных общих операций. Помимо общих операций некоторые устройства могут выполнять 
  операции специфические, свойственные только им – например, звуковые карты умеют 
  увеличивать или уменьшать среднюю громкость звучания, дисплеи умеют изменять 
  свою разрешающую способность. Для выполнения таких специфических действий в 
  интерфейс между драйвером и базовой подсистемой ввода-вывода обычно входит еще 
  одна функция, позволяющая непосредственно передать драйверу устройства произвольную 
  команду с произвольными параметрами, что позволяет задействовать любую возможность 
  драйвера без изменения интерфейса. В операционной системе   UNIX     
  такая функция получила название <B><I>ioctl</i></B> 
  (от <B>i</B>nput-<B>o</B>utput <B>c</B>on<B>t</B>ro<B>l</B>).</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Помимо функций <B><I>read</i></B>, 
  <B><I>write</i></B>, <B><I>seek</i></B>     
  (для блочных устройств), <B><I>get</i></B>, 
  <B><I>put</i></B>     (для символьных 
  устройств) и <B><I>ioctl</i></B>
  в состав интерфейса обычно включают еще следующие функции:</font></P>
<dir><ul type="square">
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Функцию инициализации или повторной 
    инициализации работы драйвера и устройства – <B><I>open</i></B>.</font></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Функцию временного завершения работы 
    с устройством (может, например, вызывать отключение устройства) – <B><I>close</i></b>.</font></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Функцию опроса состояния устройства 
    (если по каким-либо причинам работа с устройством производится методом опроса 
    его состояния – например, в операционных системах   Windows 
    NT     и   Windows&nbsp;9x     
    так построена работа с принтерами через параллельный порт) – <B><I>poll</i></b>.</font></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Функцию останова драйвера, которая вызывается 
    при останове операционной системы или выгрузке драйвера из памяти, - <B><I>halt</i></b>.</font></LI>
</ul></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Существует еще ряд действий, 
  выполнение которых может быть возложено на драйвер, но поскольку, как правило, 
  они являются действиями базовой подсистемы ввода-вывода, мы поговорим о них 
  в следующем разделе. Приведенные выше названия функций, конечно, являются условными 
  и могут меняться от одной операционной системы к другой, но действия, выполняемые 
  драйверами, характерны для большинства операционных систем, и соответствующие 
  функции присутствуют в интерфейсах к ним.</FONT></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130203"></a>13.2.3. 
  Функции базовой подсистемы ввода-вывода. </FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Базовая подсистема ввода-вывода 
  служит посредником между процессами вычислительной системы и набором драйверов. 
  Системные вызовы для выполнения операций ввода-вывода трансформируются ею в 
  вызовы функций необходимого драйвера устройства. Однако обязанности базовой 
  подсистемы не сводятся к выполнению только действий трансляции общего системного 
  вызова в обращение к частной функции драйвера. Базовая подсистема предоставляет 
  вычислительной системе такие услуги, как поддержка блокирующихся, не блокирующихся 
  и асинхронных системных вызовов, буферизация и кэширование входных и выходных 
  данных, осуществление   spooling’а 
  и монопольного захвата внешних устройств, обработку ошибок и прерываний, возникающих 
  при операциях ввода-вывода, планирование последовательности запросов на выполнение 
  этих операций. Давайте остановимся на этих услугах подробнее.</font></P>
  
<P ALIGN="CENTER"> <B><a name="l13020301"></a></b><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">13.2.3.1. 
  Блокирующиеся, не блокирующиеся и асинхронные системные вызовы.</font></b> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Все системные вызовы, связанные 
  с осуществлением операций ввода-вывода, можно разбить на три группы по способам 
  реализации взаимодействия процесса и устройства ввода-вывода.</FONT></P>
<dir><ul type="square">
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">К первой, наиболее привычной для большинства 
    программистов, группе относятся <I>блокирующиеся</I> системные вызовы. Как 
    следует из самого названия, применение такого вызова приводит к блокировке 
    инициировавшего его процесса, т.е. процесс переводится операционной системой 
    из состояния <B><I>исполнение</i></B> в состояние <B><I>ожидание</i></B>. 
    Завершив выполнение всех операций ввода-вывода, предписанных системным вызовом, 
    операционная система переводит процесс из состояния <B><I>ожидание</i></B> 
    в состояние <B><I>готовность</i></B>. После того, как процесс будет снова 
    выбран для <B><I>исполнения</i></B>, в нем произойдет окончательный возврат 
    из системного вызова. Типичным случаем для применения такого системного вызова 
    является случай, когда процессу требуется получить от устройства строго определенное 
    количество данных, без которых он не может выполнять работу далее.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Ко второй группе относятся <I>не блокирующиеся</I> 
    системные вызовы. Их название не совсем точно отражает суть дела. В простейшем 
    случае, процесс, применивший не блокирующийся вызов, не переводится в состояние 
    <B><I>ожидание</i></B> вообще. Системный вызов возвращается немедленно, выполнив 
    предписанные ему операции ввода-вывода полностью, частично или не выполнив 
    совсем, в зависимости от текущей ситуации (состояния устройства, наличия данных 
    и т.д.). В более сложных ситуациях процесс может блокироваться, но условием 
    его разблокирования является завершение всех необходимых операций или окончание 
    некоторого промежутка времени. Типичным случаем применения не блокирующегося 
    системного вызова может являться периодическая проверка на поступление информации 
    с клавиатуры при выполнении трудоемких расчетов.</FONT></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">К третьей группе относятся <I>асинхронные</I> 
    системные вызовы. Процесс, использовавший асинхронный системный вызов, никогда 
    в нем не блокируется. Системный вызов инициирует выполнение необходимых операций 
    ввода-вывода и немедленно возвращается, после чего процесс продолжает выполнять 
    свою регулярную деятельность. Об окончании завершения операции ввода-вывода 
    операционная система впоследствии информирует процесс изменением значений 
    некоторых переменных, передачей ему сигнала или сообщения, или каким-либо 
    еще способом. Необходимо четко понимать разницу между не блокирующимися и 
    асинхронными вызовами. Не блокирующийся системный вызов для выполнения операции 
    <B><I>read</i></B>
    вернется немедленно, но может прочитать запрошенное количество байт, меньшее 
    количество или вообще ничего. Асинхронный системный вызов для этой операции 
    также вернется немедленно, но требуемое количество байт рано или поздно будет 
    прочитано в полном объеме.</font></LI>
</ul></dir>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l13020302"></a>13.2.3.2. 
  Буферизация и кэширование.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Под <I>буфером</I> обычно 
  понимается некоторая область памяти для запоминания информации при обмене данных 
  между двумя устройствами, двумя процессами или процессом и устройством. Обмен 
  информацией между двумя процессами относится к области кооперации процессов, 
  и мы подробно рассмотрели его организацию в соответствующей главе. Нас здесь 
  будет интересовать использование буферов в том случае, когда одним из участников 
  обмена является внешнее устройство. Существуют три причины, приводящие к использованию 
  буферов в базовой подсистеме ввода-вывода:</FONT></P>
<dir><ul type="square">
  <li>
      <p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Первая 
        причина буферизации – это разные скорости приема и передачи информации, 
        которыми обладают участники обмена. Рассмотрим, например, случай передачи 
        потока данных от клавиатуры на модем. Скорость, с которой поставляет информацию 
        клавиатура, определяется скоростью набора текста человеком и обычно существенно 
        меньше скорости передачи данных модемом. Для того чтобы не занимать модем 
        на все время набора текста, делая его недоступным для других процессов 
        и устройств, разумно накапливать введенную информацию в буфере или нескольких 
        буферах достаточного размера и отсылать ее через модем после заполнения 
        буферов.</font>
    </LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Вторая причина буферизации – это разные 
    объемы данных, которые могут быть приняты или получены участниками обмена 
    единовременно. Возьмем другой пример. Пусть информация поставляется модемом 
    и записывается на жесткий диск. Помимо обладания разными скоростями совершения 
    операций модем и жесткий диск относятся к разным типам устройств. Модем является 
    символьным устройством и выдает данные байт за байтом, в   
        то время как диск является блочным 
    устройством и для проведения операции записи для него требуется накопить необходимый 
    блок данных в буфере. Здесь также можно применять более одного буфера. После 
    заполнения первого буфера модем начинает заполнять второй одновременно с записью 
    первого на жесткий диск. Поскольку скорость работы жесткого диска в тысячи 
    раз больше, чем скорость работы модема, то к моменту заполнения второго буфера 
    операция записи первого будет завершена, и модем снова может заполнять первый 
    буфер одновременно с записью второго на диск. </font></LI>
  <li><p align="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Третья причина буферизации связана с 
    необходимостью копирования информации из приложений, осуществляющих ввод-вывод, 
    в буфера ядра операционной системы и обратно. Допустим, что некоторый пользовательский 
    процесс пожелал вывести информацию из своего адресного пространства на внешнее 
    устройство. Для этого он должен выполнить системный вызов с обобщенным названием 
    <B><I>write</i></B>, 
    передав в качестве параметров адрес области памяти, где расположены данные, 
    и их объем. Если внешнее устройство временно занято, то возможна ситуация, 
    когда к моменту его освобождения содержимое требуемой области окажется испорченным 
    (например, при использовании асинхронной формы системного вызова). Чтобы избежать 
    возникновения подобных ситуаций, проще всего в начале работы системного вызова 
    откопировать необходимые данные в буфер ядра операционной системы, постоянно 
    находящийся в оперативной памяти, и выводить их на устройство из этого буфера.</font></LI>
</ul></dir>
<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Под словом <I>кэш</I>   
  (cache – “наличные”), этимологию 
  которого мы не будем здесь рассматривать, обычно понимают область быстрой памяти, 
  содержащую копию данных, расположенных где-либо в более медленной памяти, предназначенную 
  для ускорения работы вычислительной системы. Мы с вами сталкивались с этим понятием 
  при рассмотрении иерархии памяти. В базовой подсистеме ввода-вывода не следует 
  смешивать два понятия: буферизация и кэширование, хотя зачастую для выполнения 
  этих функций отводится одна и та же область памяти. Буфер часто содержит единственный 
  набор данных, существующий в системе, в то время как кэш, по своему определению, 
  содержит копию данных, существующих где-нибудь еще. Например, буфер, используемый 
  базовой подсистемой для копирования данных из пользовательского пространства 
  процесса при выводе на диск, может в       свою 
  очередь использоваться как кэш для этих данных, если операции модификации и 
  повторного чтения этого блока выполняются достаточно часто.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Функции буферизации и кэширования 
  не обязательно должны быть локализованы в базовой подсистеме ввода-вывода. Они 
  могут быть частично реализованы в драйверах и даже в контроллерах устройств, 
  скрытно по отношению к базовой подсистеме.</FONT></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l13020303"></a>13.2.3.3. 
  Spooling и захват устройств.</font></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">О 
  понятии spooling мы с вами говорили в первой главе нашего курса, как о механизме, 
  впервые позволившем совместить реальные операции ввода-вывода одного задания 
  с выполнением другого задания. Теперь мы можем определить это понятие более 
  аккуратно. Под словом spool мы будем понимать буфер, который содержит входные 
  или выходные данные для устройства, на котором следует избегать чередования 
  его использования (возникновения interleaving – <a href="../05/ch5.htm#l0501">см. 
  раздел&nbsp;5.1. главы&nbsp;5</a>) различными процессами. Правда, в современных 
  вычислительных системах spool практически не используется для ввода данных, 
  а в основном предназначен для накопления выходной информации. </font></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Рассмотрим в качестве 
    внешнего устройства принтер. Хотя принтер не может печатать информацию, поступающую 
    одновременно от нескольких процессов, может оказаться желательным разрешить 
    процессам совершать вывод на принтер параллельно. Для этого операционная система 
    вместо передачи информации напрямую на принтер накапливает выводимые данные 
    в буферах на диске, организованных в виде отдельного   spool     
    файла для каждого процесса. После завершения некоторого процесса, соответствующий 
    ему   spool     файл 
    ставится в очередь для реальной печати. Механизм, обеспечивающий подобные 
    действия, и получил название   spooling.</font></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В некоторых операционных 
    системах вместо использования   spooling’а 
    для устранения   race condition     
    применяется механизм монопольного захвата устройств процессами. Если устройство 
    свободно, то один из процессов может получить его в монопольное распоряжение. 
    При этом все другие процессы при попытке осуществления операций над этим устройством 
    будут либо блокированы (переведены в состояние <B><I>ожидание</i></B>), либо 
    получат информацию о невозможности выполнения операции до тех пор, пока процесс, 
    захвативший устройство, не завершится или явно не сообщит операционной системе 
    о своем отказе от его использования.</font></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Обеспечение   spooling’а 
    и механизма захвата устройств является прерогативой базовой подсистемы ввода-вывода.</font></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l13020304"></a>13.2.3.4. 
  Обработка прерываний и ошибок.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Если 
  при работе с внешним устройством вычислительная система не пользуется методом 
  опроса его состояния, а использует механизм прерываний, то при возникновении 
  прерывания, как мы уже говорили раньше, процессор, частично сохранив свое состояние, 
  передает управление специальной программе обработки прерывания. Мы уже рассматривали 
  действия операционной системы над процессами, происходящими при возникновении 
  прерывания <a href="../02/ch2.htm#l020305">в разделе 2.3.5. – “Переключение 
  контекста”</a>, где после возникновения прерывания осуществлялись следующие 
  действия: сохранение контекста, обработка прерывания, планирование использование 
  процессора, восстановление контекста, обратив пристальное внимание на действия, 
  связанные с сохранением и восстановлением контекста и планированием использования 
  процессора. Давайте теперь подробнее остановимся на том, что скрывается за словами 
  “обработка прерывания”.</font></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Одна и та же процедура 
    обработки прерывания может использоваться для нескольких устройств ввода-вывода 
    (например, если эти устройства используют одну линию прерываний, идущую от 
    них к контроллеру прерываний), поэтому первое действие собственно программы 
    обработки состоит в определении того, какое именно устройство выдало прерывание. 
    Зная устройство, мы можем выявить процесс, который инициировал выполнение 
    соответствующей операции. Поскольку прерывание возникает как при удачном, 
    так и при неудачном ее выполнении, следующее, что мы должны сделать – это 
    определить успешность завершения операции, проверив значение <B><I>бита ошибки</i></B> 
    в регистре <B><I>состояния </i></B>устройства. В некоторых случаях операционная 
    система может предпринять определенные действия, направленные на компенсацию 
    возникшей ошибки. Например, в случае возникновения ошибки чтения с гибкого 
    диска, можно попробовать несколько раз повторить выполнение команды. Если 
    компенсация ошибки невозможна, то операционная система впоследствии известит 
    об этом процесс, запросивший выполнение операции, (например, специальным кодом 
    возврата из системного вызова). Если этот процесс был заблокирован до выполнения 
    завершившейся операции, то операционная система переводит его в состояние 
    <B><I>готовность</i></B>. При наличии других неудовлетворенных запросов к 
    освободившемуся устройству операционная система может инициировать выполнение 
    следующего запроса, одновременно известив устройство, что прерывание обработано. 
    На этом собственно обработка прерывания заканчивается, и система может приступать 
    к планированию использования процессора.</FONT></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Действия по обработке 
    прерывания и компенсации возникающих ошибок могут быть частично переложены 
    на плечи соответствующего драйвера. Для этого в состав интерфейса между драйвером 
    и базовой подсистемой ввода-вывода добавляют еще одну функцию – функцию обработки 
    прерывания <B><I>intr.</i></b></font></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l13020305"></a>13.2.3.5. 
  Планирование запросов.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">При 
  использовании не блокирующегося системного вызова может оказаться, что требуемое 
  устройство уже занято выполнением некоторых операций. В этом случае не блокирующийся 
  вызов может немедленно вернуться, не выполнив запрошенных команд. При организации 
  запроса на совершение операций ввода-вывода с помощью блокирующегося или асинхронного 
  вызова занятость устройства приводит к необходимости постановки запроса в очередь 
  к данному устройству. В результате с каждым устройством оказывается связан список 
  неудовлетворенных запросов процессов, находящихся в состоянии <B><I>ожидания</i></B>, 
  и запросов, выполняющихся в асинхронном режиме. Состояние <B><I>ожидание</i></B> 
  расщепляется на набор очередей процессов, дожидающихся различных устройств ввода-вывода 
  (или ожидающих изменения состояний различных объектов – семафоров, очередей 
  сообщений, условных переменных в мониторах и т.д. – <a href="../06/ch6.htm">см. 
  главу 6</a>).</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">После 
  завершения выполнения текущего запроса операционная система (по ходу обработки 
  возникшего прерывания) должна решить, какой из запросов в списке должен быть 
  удовлетворен следующим, и инициировать его исполнение. Точно так же, как для 
  выбора очередного процесса на исполнение из списка готовых нам приходилось осуществлять 
  <a href="../03/ch3.htm#l0301b">краткосрочное планирование процессов</a>, здесь 
  нам необходимо осуществлять планирование использования устройств, пользуясь 
  каким-либо алгоритмом этого планирования. Критерии и цели такого планирования 
  мало отличаются от <a href="../03/ch3.htm#l0302">критериев и целей планирования процессов</a>.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Задача планирования использования 
  устройства обычно возлагается на базовую подсистему ввода-вывода, однако для 
  некоторых устройств лучшие алгоритмы планирования могут быть тесно связаны с 
  деталями их внутреннего функционирования. В таких случаях операция планирования 
  переносится внутрь драйвера соответствующего устройства, так как эти детали 
  скрыты от базовой подсистемы. Для этого в интерфейс драйвера добавляется еще 
  одна специальная функция, которая осуществляет выбор очередного запроса, - функция 
  <B><I>strategy</i></b>.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В следующем разделе мы 
  рассмотрим некоторые алгоритмы планирования, связанные с удовлетворением запросов, 
  на примере жесткого диска.</FONT></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l130204"></a>13.2.4. 
  Алгоритмы планирования запросов к жесткому диску.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Прежде, чем приступить 
  к непосредственному изложению самих алгоритмов, давайте вспомним внутренне устройство 
  жесткого диска и определимся с тем, какие параметры запросов мы можем использовать 
  для планирования.</FONT></P>
  
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l13020401"></a>13.2.4.1. 
  Строение жесткого диска и параметры планирования.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Современный жесткий магнитный 
    диск представляет собой набор круглых пластин, находящихся на одной оси, и 
    покрытых с одной или двух сторон специальным магнитным слоем (см. рисунок&nbsp;13.2.). 
    Около каждой рабочей поверхности каждой пластины расположены магнитные головки 
    для чтения и записи информации. Эти головки присоединены к специальному рычагу, 
    который может перемещать весь блок головок над поверхностями пластин как единое 
    целое. Поверхности пластин разделены на концентрические кольца, внутри которых 
    собственно и может храниться информация. Набор концентрических колец на всех 
    пластинах для одного положения головок (т.е. все кольца равноудаленные от 
    оси) образует цилиндр. Каждое кольцо внутри цилиндра получило название дорожки 
    (по 1-й или 2-е дорожки на каждую пластину). Все дорожки делятся на равное 
    число секторов. Количество дорожек, цилиндров и секторов может варьироваться 
    от одного жесткого диска к другому в достаточно широких пределах. Как правило, 
    сектор является минимальным объемом информации, которое может быть прочитано 
    с диска за один раз.</FONT></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">При работе диска набор 
    пластин вращается вокруг своей оси с высокой скоростью, подставляя по очереди 
    под головки соответствующих дорожек все их сектора. Номер сектора, номер дорожки 
    и номер цилиндра однозначно определяют положение данных на жестком диске и, 
    наряду с типом совершаемой операции – чтение или запись, полностью характеризуют 
    часть запроса, связанную с устройством, при обмене информацией в объеме одного 
    сектора.</FONT></P>
  
<P ALIGN="CENTER"><img src="images/sr13-2.gif" width="537" height="382"></P>
  <P ALIGN="CENTER"><FONT FACE="Times New Roman, sans-serif, Courier, mono" SIZE=2>Рис 13.2. Схема жесткого 
    диска</FONT></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l13020402"></a>13.2.4.2. 
  Алгоритм First Come First Served (FCFS)</font></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Простейшим алгоритмом, 
    к которому мы уже должны были привыкнуть, является алгоритм   First 
    Come First Served (FCFS) – первым 
    пришел, первым обслужен. Все запросы организуются в очередь   FIFO     
    и обслуживаются в порядке поступления. Алгоритм прост в реализации, но может 
    приводить к достаточно большим общим временам обслуживания запросов. Рассмотрим 
    пример. Пусть у нас на диске из 100 цилиндров (от 0 до 99) есть следующая 
    очередь запросов: 23, 67, 55, 14, 31, 7, 84, 10 и головки в начальный момент 
    находятся на 63 цилиндре. Тогда положение головок будет меняться следующим 
    образом:</font></P>
<P ALIGN="CENTER"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">63-&gt;23-&gt;67-&gt;55-&gt;14-&gt;31-&gt;7-&gt;84-&gt;10</FONT></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">и всего головки переместятся 
    на 329 цилиндров. Неэффективность алгоритма хорошо иллюстрируется двумя последними 
    перемещениями с 7 цилиндра через весь диск на 84 цилиндр и, затем опять через 
    весь диск на цилиндр 10. Простая замена порядка двух последних перемещений 
    (7-&gt;10-&gt;84) позволила бы существенно сократить общее время обслуживания 
    запросов. Поэтому давайте перейдем к рассмотрению другого алгоритма.</FONT></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l13020403"></a>13.2.4.3. 
  Алгоритм Short Seek Time First (SSTF).</font></B> 
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Как мы видели, достаточно 
    разумным является первоочередное обслуживание запросов, данные для которых 
    лежат рядом с текущей позицией головок, а уж затем далеко отстоящих. Алгоритм 
      Short Seek Time First (SSTF) 
    – короткое время поиска первым - как раз и исходит из этой позиции. Для очередного 
    обслуживания будем выбирать запрос, данные для которого лежат наиболее близко 
    к текущему положению магнитных головок. Естественно, что при наличии равноудаленных 
    запросов, решение о выборе между ними может приниматься из различных соображений, 
    например по алгоритму   FCFS. 
    Для предыдущего примера алгоритм даст следующую последовательность положений 
    головок: </font></P>
<P ALIGN="CENTER"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">63-&gt;67-&gt;55-&gt;31-&gt;23-&gt;14-&gt;10-&gt;7-&gt;84</FONT></P>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">и 
  всего головки переместятся на 141 цилиндр. Заметим, что наш алгоритм похож на 
  <a href="../03/ch3.htm#l030503">алгоритм SJF планирования процессов</a>, если за аналог 
  оценки времени очередного CPU burst процесса выбирать расстояние между текущим 
  положением головки и положением, необходимым для удовлетворения запроса. И точно 
  так же, как  <a href="../03/ch3.htm#l030503">алгоритм SJF</a>, он может приводить к длительному откладыванию выполнения 
  какого-либо запроса. Необходимо вспомнить, что запросы в очереди могут появляться 
  в любой момент времени. Если у нас все запросы, кроме одного, постоянного группируются 
  в области с большими номерами цилиндров, то этот один запрос может находиться 
  в очереди неопределенно долго. </font></P>
  <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Точный  
  <a href="../03/ch3.htm#l030503">алгоритм   SJF</a>     
    являлся оптимальным для заданного набора процессов с заданными временами   CPU 
    burst. Легко видеть, что алгоритм 
      SSTF     не является 
    оптимальным. Если мы перенесем обслуживание запроса 67 цилиндра в промежуток 
    между запросами 7 и 84 цилиндров, мы уменьшим общее время обслуживания. Это 
    наблюдение приводит нас к идее целого семейства других алгоритмов – алгоритмов 
    сканирования.</font></P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l13020404"></a>13.2.4.4. 
  Алгоритмы сканирования (SCAN, C-SCAN, LOOK, C-LOOK)</font></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В простейшем из алгоритмов 
  сканирования –   SCAN     
  – головки постоянно перемещаются от одного края диска до его другого края, по 
  ходу дела обслуживая все встречающиеся запросы. По достижении другого края направление 
  движения меняется, и все повторяется снова. Пусть в предыдущем примере в начальный 
  момент времени головки двигаются в направлении уменьшения номеров цилиндров. 
  Тогда мы и получим порядок обслуживания запросов, подсмотренный в конце предыдущего 
  раздела. Последовательность перемещения головок выглядит следующим образом:</font></P>
<P ALIGN="CENTER"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">63-&gt;55-&gt;31-&gt;23-&gt;14-&gt;10-&gt;7-&gt;0-&gt;67-&gt;84</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">и всего головки переместятся 
  на 147 цилиндров.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Если мы знаем, что обслужили 
  последний попутный запрос в направлении движения головок, то мы можем не доходить 
  до края диска, а сразу изменить направление движения на обратное:</FONT></P>
<P ALIGN="CENTER"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">63-&gt;55-&gt;31-&gt;23-&gt;14-&gt;10-&gt;7-&gt;67-&gt;84</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">и всего головки переместятся 
  на 133 цилиндра. Полученная модификация алгоритма   SCAN     
  получила название   LOOK.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Допустим, что к моменту 
  изменения направления движения головки в алгоритме   SCAN, 
  т.е. когда головка достигла одного из краев диска, у этого края накопилось большое 
  количество новых запросов, на обслуживание которых будет потрачено достаточно 
  большое время (не забываем, что надо не только перемещать головку, но еще и 
  передавать прочитанные данные!). Тогда запросы, относящиеся к другому краю диска 
  и поступившие раньше, будут ждать обслуживания несправедливо долгое время. Для 
  сокращения времени ожидания запросов применяется другая модификация алгоритма 
    SCAN     – циклическое 
  сканирование. Когда головка достигает одного из краев диска, она без чтения 
  попутных запросов (иногда существенно быстрее, чем при выполнении обычного поиска 
  цилиндра) перемещается на другой край, откуда вновь начинает свое движение. 
  Для этого алгоритма, получившего название   C-SCAN, 
  последовательность перемещений будет выглядеть так:</font></P>
<P ALIGN="CENTER"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">63-&gt;55-&gt;31-&gt;23-&gt;14-&gt;10-&gt;7-&gt;0-&gt;99-&gt;84-&gt;67</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">По аналогии с алгоритмом 
    LOOK     для алгоритма 
    SCAN     можно предложить 
  и алгоритм   C-LOOK     
  для алгоритма   C-SCAN:</font></P>
<P ALIGN="CENTER"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">63-&gt;55-&gt;31-&gt;23-&gt;14-&gt;10-&gt;7-&gt;84-&gt;67</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Существуют и другие разновидности 
  алгоритмов сканирования, и совсем другие алгоритмы, но мы на этом закончим наше 
  рассмотрение, ибо было сказано:    “И 
  еще раз говорю: никто не обнимет необъятного”</FONT>.</P>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1303"></a>13.3. 
  Резюме.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Функционирование любой 
  вычислительной системы обычно сводится к выполнению двух видов работы: обработке 
  информации и операций по осуществлению ее ввода-вывода. С точки зрения операционной 
  системы “обработкой информации” являются только операции, совершаемые процессором 
  над данными, находящимися в памяти на уровне иерархии не ниже, чем оперативная 
  память. Все остальное относится к “операциям ввода-вывода”, т.е. к обмену информацией 
  с внешними устройствами.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Несмотря на все многообразие 
  устройств ввода-вывода, управление их работой и обмен информацией с ними строятся 
  на относительно небольшом количестве принципов. Основными физическими принципами 
  построения системы ввода-вывода является следующие: <a href="#l130101a">возможность использования 
  различных адресных пространств для памяти и устройств ввода-вывода</a>; <a href="#l130101a">подключение 
  устройств к системе через порты ввода-вывода, отображаемые в одно из адресных 
  пространств</a>; <a href="#l130103a">существование механизма прерывания для извещения процессора о завершении 
  операций ввода-вывода</a>;<a href="#l130104"> наличие механизма прямого доступа устройств к памяти, 
  минуя процессор</a>.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Механизм, подобный механизму 
  прерываний, может использоваться также и для обработки <a href="#l130103b">исключений</a> и <a href="#l130103c">программных 
  прерываний</a>, однако это целиком лежит на совести разработчиков вычислительных 
  систем. </FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Для построения программной 
  части системы ввода-вывода характерен <a href="#l130201">слоеный подход</a>. Для непосредственного 
  взаимодействия с   hardware     
  используются драйвера устройств, скрывающие от остальной части операционной 
  системы все особенности их функционирования. Драйвера устройств через <a href="#l130202">жестко 
  определенный интерфейс</a> связаны с базовой подсистемой ввода-вывода, в функции 
  которой входят: <a href="#l13020301">организация работы блокирующихся, не блокирующихся и асинхронных 
  системных вызовов</a>,<a href="#l13020302"> буферизация и кэширование входных и выходных данных</a>, <a href="#l13020303">осуществление 
    spooling’а и 
  монопольного захвата внешних устройств</a>, <a href="#l13020304">обработка ошибок и прерываний, возникающих 
  при операциях ввода-вывода</a>, <a href="#l13020305">планирование последовательности запросов на выполнение 
  этих операций</a>. Доступ к базовой подсистеме ввода-вывода осуществляется посредством 
  системных вызовов.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Часть функций базовой подсистемы 
  может быть делегирована драйверам устройств и самим устройствам ввода-вывода.</FONT></P>
<p align="center"><a href="../12/ch12.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../14/ch14.htm"> Следующая глава</a></p>

</BODY>
</HTML>
