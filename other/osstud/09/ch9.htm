<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Глава 9</TITLE>
</HEAD>
<body lang=RU class="Normal" bgcolor="#FFFFFF">
<p style='text-align:center'><font face="Times New Roman,sans-serif,Courier,mono" size="4"><b>
Глава 9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти</b></font></p>
<p style='text-align:justify'><font size="3">

<p align="center"><a href="../08/ch8.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../10/ch10.htm"> Следующая глава</a></p>


</font><a name="l0901"></a><font size="3"><b>9.1 Проблема размещения больших программ. Понятие виртуальной памяти.</b></font><p></p>
<p style='text-align:justify'>Уже давно существует проблема размещения в памяти
  программ, размер которых превышает  размер доступной памяти. Один из вариантов
  ее решения  организация структур с перекрытием рассмотрен в предыдущей главе.
  При этом предполагалось активное участие программиста в процессе сегментации
  и  загрузки программы.  Было предложено переложить проблему на компьютер.  Развитие
  архитектуры компьютеров привело к значительному усложнению организации памяти,
  соответственно, усложнились и расширились задачи операционной системы по управлению
  памятью. Одним из главных усовершенствований архитектуры стало появление виртуальной
  памяти (virtual memory). Она впервые была реализована в 1959 г. на компьютере
  Атлас, разработанном в Манчестерском университете, и стала популярной только
  спустя десятилетие.</p>
<p style='text-align:justify'>При помощи виртуальной памяти обычно решают <i>две 
  задачи.</i> <i>Во-первых</i>, виртуальная память позволяет адресовать пространство, 
  гораздо большее, чем емкость физической памяти конкретной вычислительной машины. 
  В соответствии с принципом локальности для реальных программ  обычно нет  необходимости 
  в помещении их в физическую память целиком. </p>
<p style='text-align:justify'>Возможность выполнения  программы, находящейся в
  памяти лишь частично имеет ряд вполне очевидных преимуществ:</p>
<ul>
  <li>
    <p align="justify">Программа не ограничена величиной физической памяти. Упрощается
  разработка программ, поскольку можно задействовать большие виртуальные пространства,
  не заботясь о размере используемой памяти.</li>
  <li>
    <p align="justify">Поскольку появляется возможность частичного помещения программы
  (процесса) в память и гибкого перераспределения памяти между программами, можно
  разместить в памяти больше программ, что увеличивает загрузку процессора и пропускную
  способность системы.</li>
  <li>
    <p align="justify">Объем ввода-вывода для  выгрузки части программы на диск может
  быть меньше, чем в варианте классического свопинга, в итоге, каждая программа
  будет работать быстрее.</li>
</ul>
<p style='text-align:justify'>Таким образом, возможность  обеспечения (при поддержке
  операционной системы) для программы видимости практически неограниченной (32-
  или 64-разрядной) адресуемой пользовательской памяти при наличии основной памяти
  существенно меньших размеров очень важный аспект. Но введение виртуальной памяти
  позволяет решать другую не менее важную задачу  обеспечение контроля доступа
  к отдельным сегментам памяти и в частности <i>защиту</i>  пользовательских программ
  друг от друга и защиту ОС от пользовательских программ.</p>
<p style='text-align:justify'>С целью защиты  виртуальная память поддерживалась 
  и на компьютерах с 16-разрядной адресацией, в которых объем основной памяти 
  зачастую существенно превышал 64 Кбайта (размер виртуальной памяти).  Например, 
  16-разрядный компьютер PDP-11/70 мог иметь до 2 Мбайт оперативной памяти. Операционная 
  система этого компьютера, тем не менее, поддерживала виртуальную память, основным 
  смыслом которой являлось <i>обеспечение защиты</i> и перераспределения  основной 
  памяти между  пользовательскими процессами. </p>
<p style='text-align:justify'>Напомним, что в системах с виртуальной памятью те 
  адреса, которые  генерирует программа,  - (логические адреса) -  называются виртуальными, 
  и они формируют виртуальное адресное пространство. В отсутствие механизма виртуальной 
  памяти  виртуальное адресное пространство непосредственно отображается в физическое 
  пространство. </p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono" size="3">Хотя известны и
  чисто программные реализации виртуальной памяти, это направление получило наиболее
  широкое развитие после получения соответствующей аппаратной поддержки. Идея
  аппаратной части механизма виртуальной памяти состоит в том, что адрес памяти,
  вырабатываемый командой, интерпретируется аппаратурой не как реальный адрес
  некоторого элемента основной памяти, а как некоторая структура, где адрес является
  лишь одним из компонентов наряду с атрибутами, характеризующими способ обращения
  по данному адресу. </font></p>
<p align="justify">Традиционно считается, что существует три модели виртуальной 
  памяти: <i>страничная,  сегментная и их комбинация - сегментно-страничная модель</i>. 
  По-видимому, более правильно считать, что существует (и поддерживается аппаратно 
  большинством платформ) страничная модель виртуальной памяти. Сегментно-страничная 
  модель является синтезом страничной модели и идеи сегментации, изложенной в 
  предыдущей главе. Причем для тех архитектур, в которых сегменты не поддерживаются 
  аппаратно их реализация задача  архитектурно-независимой компоненты менеджера 
  памяти.  Сегментная организация в чистом виде практически не встречается.</p>
<p align="justify"><a name="l0902"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono" size="3">9.2 Архитектурные средства поддержки виртуальной памяти.</font></b></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono" size="3">Очевидно, 
  что невозможно создать полностью машинно-независимый компонент управления виртуальной 
  памятью. С другой стороны, имеются существенные части программного обеспечения, 
  связанного с управлением виртуальной памятью, для которых детали аппаратной 
  реализации совершенно не важны. Одним из достижений современных ОС является 
  грамотное и эффективное разделение средств управления виртуальной памятью на 
  аппаратно-независимую и аппаратно-зависимую части. Коротко рассмотрим, что и 
  каким образом входит в аппаратно-зависимую часть подсистемы управления виртуальной 
  памятью. Компоненты аппаратно-независимой подсистемы рассмотрены в следующей 
  главе.</font></p>
<p style='text-align:justify'>Итак, мы имеем большое (для 32-разрядных архитектур
  это обычно 2**32 = 4 Гб) виртуальное адресное пространство и физическое пространство
  существенно меньшего размера. Пользовательский процесс или ОС  должны иметь
  возможность осуществить запись по виртуальному адресу, а задача ОС сделать так,
  чтобы  записанная информация оказалась в физической памяти (впоследствии при
  нехватке оперативной памяти она может быть вытеснена во внешнюю память).</p>
<p style='text-align:justify'>Таким образом, важный компонент менеджера виртуальной
  памяти  система  или функция отображения (трансляции) адресов. Механизм преобразования
  виртуальных адресов в физические должен предусматривать ведение таблиц, показывающих,
  какие области виртуальной памяти в текущий момент находятся в  физической памяти
  и где именно размещаются. Если бы такое отображение осуществлять побайтно, то
  информация об отображении была бы велика, и для ее хранения потребовалось бы
  больше реальной памяти, чем для процессов.  Необходим  способ, позволяющий существенно
  сократить объем информации отображения. Поэтому  обычно отображаемая  информация
  группируется в блоки (программа занимает целое количество блоков памяти).</p>
<p style='text-align:justify'><a name="l090201"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono" size="3">9.2.1 Страничная память</font></b></p>
<p style='text-align:justify'>В наиболее простом и наиболее часто используемом
  случае страничной виртуальной памяти виртуальная память  и физическая  представляются
  состоящими из наборов блоков или страниц одинакового размера. Виртуальные  адреса
  делятся на страницы (page), соответствующие единицы в физической  памяти образуют
  страничные кадры (page frames), а в целом система поддержки страничной виртуальной
  памяти называется пейджингом (<font face="Times New Roman,sans-serif,Courier,mono"size="3">paging</font>).  Передача информации
  между памятью и диском всегда осуществляется целыми страницами. Страницы, в
  отличие от сегментов, имеют фиксированную длину, обычно являющуюся степенью
  числа 2, и не могут перекрываться. </p>
<p style='text-align:justify'>Виртуальный адрес в страничной системе  упорядоченная
  пара (p,d), где p - номер страницы в виртуальной памяти, а d - смещение в рамках
  страницы p, где размещается  адресуемый  элемент.  Процесс может выполняться,
  если его текущая страница находится в  оперативной памяти.  Если текущей страницы
  в главной памяти нет, она должна быть переписана (подкачана)  из внешней памяти.
  Поступившая страница может быть размещена в любой свободный страничный  кадр.
  Система отображения виртуальных адресов в физические сводится к  системе отображения
  виртуальных страниц в физические и представляет собой <i>таблицу страниц</i>.
</p>
<p style='text-align:justify'>Для преобразования адресного пространства каждого
  процесса используется одна или несколько таблиц страниц, которые обычно хранятся
  в оперативной памяти. Для ссылки на таблицу страниц используется специальный
  регистр процессора. Особенности хранения  таблицы страниц описаны  ниже. Интерпретация
  виртуального (логического) адреса показана на рис. 9.1</p>
<p style='text-align:justify'><img border="0" src="images/image001.gif" width="480" height="452"></p>
<p style='text-align:justify'><font size="2">Рис. 9.1  Связь логического и физического адресов
  при страничной организации памяти.</font></p>
<p style='text-align:justify'>Динамическое  преобразование  адресов в системе
  осуществляется  следующим  образом. Выполняемый  процесс обращается   по виртуальному
  адресу v = (p,d). Механизм отображения ищет номер страницы p в таблице   отображения
  и определяет, что эта страница находится  в страничном  кадре p', формируя
  реальный адрес из p' и d.</p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono" size="3">Н</font>апример, 
  в машинной инструкции <font face="Times New Roman,sans-serif,Courier,mono"size="3">move 
  reg</font>,0, адрес 0  находится  на первой виртуальной  странице, которая может 
  быть локализована, во втором страничном кадре.  В реальных системах  функция 
  отображения хранит бит присутствия страницы в физической  памяти. При отсутствии 
  страницы в памяти возникает <i>исключительная ситуация</i>, называемая  <i>страничное 
  нарушение (page fault)</i>.  Обработка страничного нарушения приводит к тому,  
  затребованная страница  подкачивается из конкретного места вторичной памяти 
  в свободный страничный кадр физической памяти и продолжается прерванный код. 
  При отсутствии свободных страничных кадров на диск выгружается мало используемая 
  страница.</p>
<p style='text-align:justify'>Номер страницы, как индекс хранится в  таблице страниц 
  (page table),  которая адресуется при помощи специального регистра процессора, 
  и  позволяет  определить номер кадра по виртуальному  адресу. Помимо этой основной 
  задачи при помощи атрибутов, записанных в строке таблицы страниц, можно организовать 
  контроль доступа к конкретной странице и ее защиту.</p>
<p style='text-align:justify'>Используя схему  пэйджинга, мы не имеем внешней 
  фрагментации. Однако сталкиваемся с <i>внутренней фрагментацией</i>:   адресное 
  пространство процесса занимает целое число страниц, и в среднем половина страницы 
  на процесс пропадает.</p>
<p style='text-align:justify'>Важный аспект - различие точек зрения пользователя
  и системы на используемую память. С точки зрения пользователя его память - единое
  непрерывное пространство, содержащее, только одну программу.  Реальное отображение
  скрыто от пользователя и контролируется ОС.  Заметим, что процессу пользователя
  недоступна чужая память. Он не имеет возможности адресовать память за пределами
  своей таблицы страниц, которая включает только его собственные страницы.</p>
<p style='text-align:justify'>Для управления физической памятью ОС поддерживает
  структуру таблицы кадров. Она имеет одну   запись на каждый физический кадр,
  показывающий его состояние.  </p>
<p style='text-align:justify'>Отображение должно происходить корректно даже в
  сложных случаях.  ОС поддерживает одну или несколько (при наличии нескольких
  сегментов памяти)  таблиц  страниц  для каждого процесса,  для ссылки, на которую,
  как уже говорилось,  обычно используется специальный регистр. При переключении
  процессов диспетчер  должен найти его таблицу страниц,  указатель на которую,
  таким образом, входит в контекст процесса.</p>
<p style='text-align:justify'>В большинстве современных компьютеров со страничной
  организацией виртуальной памяти все таблицы страниц хранятся в основной памяти,
  а быстрота доступа к элементам таблицы текущей виртуальной памяти достигается,
  как будет показано ниже, за счет наличия сверхбыстродействующей буферной памяти
  (кэша).</p>
<p style='text-align:justify'><a name="l090202"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">9.2.2 Сегментная и сегментно-страничная организации памяти</font></b></p>
<p style='text-align:justify'>Существуют две другие схемы организации виртуальной
  памяти: сегментная и сегментно-страничная. Идеи сегментации изложены во введении
  к предыдущей главе. При сегментной организации виртуальный адрес по-прежнему
  является двумерным и состоит из двух полей - номера сегмента и смещения внутри
  сегмента.   Заметим, что с точки зрения ОС сегменты являются логическими сущностями
  и их главное назначение  хранение и защита однородной информации (кода, данных
  и т.д.).</p>
<p style='text-align:justify'>С точки зрения пользователя  процесс представляется 
  обычно не как линейный массив байтов, а как набор сегментов переменного размера 
  (данные, код, стек).  Сегментация - схема управления памятью, поддерживающая 
  этот взгляд пользователя.  Сегменты содержат процедуры, массивы, стек или скалярные 
  величины, но обычно не содержат информацию смешанного типа. </p>
<p style='text-align:justify'>Программисты, пишущие на языках низкого уровня должны 
  иметь представление о сегментной организации, явным образом меняя значения сегментных 
  регистров (это хорошо видно по текстам программ, написанных на Ассемблере). 
  Логическое адресное пространство - набор сегментов. Каждый сегмент имеет имя, 
  размер и другие параметры (уровень привилегий, разрешенные виды обращений, флаги 
  присутствия). Пользователь специфицирует каждый адрес двумя величинами: именем 
  сегмента и смещением. (В отличие от схемы пэйджинга, где пользователь задает 
  только один адрес, который разбивается <font face="Times New Roman,sans-serif,Courier,mono"size="3">hardware</font> 
  на номер страницы и смещение,  прозрачным для программиста образом.)</p>
<p align="justify">Каждый сегмент - линейная последовательность адресов от 0 до 
  максимума.  Различные сегменты могут иметь различные  длины, которые могут меняться 
  динамически (например, сегмент стека).  В элементе таблицы сегментов помимо 
  физического адреса начала сегмента (если виртуальный сегмент содержится в основной 
  памяти) содержится длина сегмента. Если размер смещения в виртуальном адресе 
  выходит за пределы размера сегмента, возникает прерывание. </p>
<p style='text-align:justify'>Логический адрес  - упорядоченная пара v=(s,d),
  номер сегмента и смещение внутри сегмента. </p>
<p style='text-align:justify;'>В системах, где сегменты  поддерживаются аппаратно,
  эти параметры обычно хранятся в таблице <i>дескрипторов</i> сегментов, а программа
  обращается к этим дескрипторам по номерам&#8209;<i>селекторам</i>. При этом
  в контекст каждого процесса входит набор <i>сегментных регистров</i>, содержащих
  селекторы текущих сегментов кода, стека, данных и др. и определяющих, какие
  сегменты будут использоваться при разных видах обращений к памяти. Это позволяет
  процессору уже на аппаратном уровне определять допустимость обращений к памяти,
  упрощая реализацию защиты информации от повреждения и несанкционированного доступа.</p>
<p style='text-align:justify;'><img border="0" src="images/image002.gif" width="528" height="348"></p>
<p style='text-align:justify;'><font size="2">Рис. 9.2  Преобразование  логического адреса при
  сегментной организации памяти.</font></p>
<p style='text-align:justify;'>Аппаратная поддержка сегментов относительно слабо 
  распространена (главным образом на процессорах архитектуры <font face="Times New Roman,sans-serif,Courier,mono"size="3">Intel</font>) 
  и характеризуется довольно медленной загрузкой селекторов в сегментные регистры, 
  выполняемая при каждом переключении контекста и при каждом переходе между разными 
  сегментами.  В системах с чисто страничной организацией памяти для  описания 
  типового адресного пространства процесса,  представляющего собой набор сегментов, 
  сегментация реализуется на уровне, независимом от аппаратуры. </p>
<p style='text-align:justify'>Хранение в памяти сегментов большого размера может 
  оказаться неудобным.  Возникает идея их пейджинга. При <i>сегментно-страничной 
  </i>организации виртуальной памяти происходит двухуровневая трансляция виртуального 
  адреса в физический. В этом случае виртуальный адрес состоит из трех полей: 
  номера сегмента виртуальной памяти, номера страницы внутри сегмента и смещения 
  внутри страницы. Соответственно, используются две таблицы отображения - таблица 
  сегментов, связывающая номер сегмента с таблицей страниц, и отдельная таблица 
  страниц для каждого сегмента. </p>
<p style='text-align:justify'><img border="0" src="images/image003.gif" width="600" height="307"> </p>
<p style='text-align:justify'><font size="2">Рис. 9.3  Формирование физического адреса при сегментно-страничной
  организации памяти.</font></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Сегментно-страничная
  организация виртуальной памяти позволяла совместно использовать одни и те же
  сегменты данных и программного кода в виртуальной памяти разных задач (для каждой
  виртуальной памяти существовала отдельная таблица сегментов, но для совместно
  используемых сегментов поддерживались общие таблицы страниц). </font></p>
<p style='text-align:justify'><a name="l090203"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">9.2.3 Таблица страниц</font></b></p>
<p style='text-align:justify'>Организация таблицы страниц  один из ключевых элементов
  механизмов страничного и сегментно-страничного преобразований. Рассмотрим структуру
  таблицы страниц более детально.</p>
<p style='text-align:justify'>Итак, виртуальный адрес состоит из виртуального 
  номера страницы (high-order bits) и смещения (low-order bits). Номер виртуальной 
  страницы используется как индекс в таблице страниц для нахождения  записи (<font face="Times New Roman,sans-serif,Courier,mono"size="3">entry</font>) 
  о виртуальной странице.  Из этой записи в таблице страниц находится  номер кадра 
  (page frame number), затем прибавляется  смещение и формируется  физический 
  адрес.  Помимо этого запись  в таблице страниц содержит информацию об атрибутах 
  страницы, в частности биты защиты.</p>
<p style='text-align:justify'>Основную проблему для эффективной реализации таблицы
  страниц создают большие размеры виртуальных адресных пространств современных
  компьютеров, которые обычно определяются разрядностью архитектуры процессора.
  Самыми распространенными на сегодняшний день являются 32-разрядные процессоры,
  позволяющие создавать виртуальные адресные пространства такого размером 4 Гб
  (для 64-разрядных компьютеров эта величина равна 2**64б).</p>
<p style='text-align:justify'>Подсчитаем примерный размер таблицы страниц. В 32-битном 
  адресном  пространстве при размере страницы 4К  (<font face="Times New Roman,sans-serif,Courier,mono"size="3">Intel</font>) 
  получаем  1М страниц, а в 64-битном и того более. Т.о. таблица должна иметь 
  1М строк (<font face="Times New Roman,sans-serif,Courier,mono"size="3">entry</font>), 
  причем  запись в строке состоит  из нескольких байт.  Заметим, что каждый процесс, 
  нуждается  в своей таблице страниц (а в случае сегментно-страничной схемы  по 
  одной на каждый сегмент). Итак,  в этом случае таблица страниц <i>может быть 
  слишком большой</i>.</p>
<p style='text-align:justify'>Кроме того, отображение  <i>должно быть быстрым</i>. 
  Отображение должно быть быстрым  т.к. оно делается при каждом обращении к памяти, 
  которое происходи практически в каждой машинной инструкции. Эта проблема решается 
  главным образом за счет реализации ассоциативной памяти (см. <a href="#l090204">следующий 
  раздел</a>).</p>
<p style='text-align:justify'>Для того чтобы избежать необходимости  иметь огромную 
  таблицу в памяти все время, а хранить лишь несколько ее фрагментов (это возможно 
  опять же на основании свойства локальности!), многие компьютеры  используют 
  <i>многоуровневую</i> таблицу страниц. </p>
<p style='text-align:justify'>Рассмотрим модельный пример (см. рис. 9.4). Предположим, 
  что  32-разрядный  адрес делится на 10-разрядное поле Р<font face="Times New Roman,sans-serif,Courier,mono"size="3">tr</font>1, 
  10-разрядное поле Рtr2 и 12-разрядное смещение <font face="Times New Roman,sans-serif,Courier,mono"size="3">Offset</font>. 
  12 разрядов смещения позволяют локализовать байт внутри страницы размером 4К 
  (2**12), а всего имеем 2**20 страниц.  Как видно из рис. 9.4  1024 строки в  
  таблице верхнего уровня при помощи поля <font face="Times New Roman,sans-serif,Courier,mono"size="3">Ptr</font>1 
  ссылаются на 1024  таблицы второго уровня, каждая из которых содержит  также 
  1024 строки. При помощи поля <font face="Times New Roman,sans-serif,Courier,mono"size="3">Ptr</font>2  
  каждая строка  таблицы второго уровня указывает на  конкретную страницу. Смысл 
  такой организации в том, чтобы  избежать поддержки всех таблиц второго уровня 
  (а их 1024) в памяти  постоянно.  Рассмотрим  пример с круглыми цифрами.  Допустим, 
  что процессу нужны 12М памяти: 4М в нижней части памяти для кода, 4М в нижней 
  части для данных и 4М в верхней части памяти для стека. Между дном стека и верхом 
  данных гигантское пространство  размером 4<font face="Times New Roman,sans-serif,Courier,mono"size="3">Gb</font>-12<font face="Times New Roman,sans-serif,Courier,mono"size="3">Mb</font>, 
  которое  не используется.  Для этого случая необходимы лишь 1 таблица верхнего 
  уровня и 3 таблицы второго уровня. </p>
<p style='text-align:justify'><img border="0" src="images/image004.gif" width="527" height="593"> </p>
<p style='text-align:justify'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font size="2">Рис. 9.4  Пример двухуровневой таблицы
  страниц.</font> </p>
<p style='text-align:justify'>Такой подход естественным  образом обобщается на
  три и более уровней таблицы.</p>
<p style='text-align:justify'>Рассмотрим  одну  из  записей  таблицы страниц.
  Ее размер колеблется от системы к системе, но 32 бита - наиболее общий случай.
  Самое важное поле - номер кадра.  Цель страничного отображения - локализовать
  эту величину.  Далее бит присутствия.  Далее биты защиты (например,  0 - read/write,
  1 - read only ...) Есть еще биты модификации (если на нее писали) и биты ссылки,
  которые  помогают выделить мало используемые страницы, биты разрешающие кэширование.
  Заметим, что адреса страниц на диске не являются частью таблицы страниц.</p>
<p style='text-align:justify'>Как наличие нескольких уровней сказывается на производительности
  менеджера памяти?  Если предположить, что каждый уровень - отдельная таблица
  в памяти, преобразование адреса может потребовать нескольких  обращений к памяти.
</p>
<p style='text-align:justify'>Количество уровней в таблице страниц зависит от 
  конкретных особенностей архитектуры. Можно привести примеры реализации одноуровневого 
  (<font face="Times New Roman,sans-serif,Courier,mono"size="3">DEC</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> 
  </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">PDP</font>-11), 
  двухуровневого (<font face="Times New Roman,sans-serif,Courier,mono"size="3">Intel</font>, 
  <font face="Times New Roman,sans-serif,Courier,mono"size="3">DEC</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> 
  </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">VAX</font>), 
  трехуровневого (<font face="Times New Roman,sans-serif,Courier,mono"size="3">Sun</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> 
  </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">SPARC</font>, 
  <font face="Times New Roman,sans-serif,Courier,mono"size="3">DEC</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> 
  </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">Alpha</font>) 
  <font face="Times New Roman,sans-serif,Courier,mono"size="3">paging</font>'а, 
  а также <font face="Times New Roman,sans-serif,Courier,mono"size="3">paging</font>'а 
  с задаваемым количеством уровней (<font face="Times New Roman,sans-serif,Courier,mono"size="3">Motorola</font>). 
  Функционирование <font face="Times New Roman,sans-serif,Courier,mono"size="3">RISC</font> 
  процессора <font face="Times New Roman,sans-serif,Courier,mono"size="3">MIPS</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> 
  </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">R</font>2000 
  осуществляется вообще без таблицы страниц. Здесь поиск нужной страницы, если  
  эта страница отсутствует в ассоциативной памяти, должна взять на себя ОС (так 
  называемый <font face="Times New Roman,sans-serif,Courier,mono"size="3">zero</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> 
  </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">level</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> 
  </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">paging</font>).</p>
<p style='text-align:justify'><a name="l090204"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">9.2.4 Ассоциативная память. </font></b></p>
<p style='text-align:justify'>Поиск нужной страницы в многоуровневой таблице страниц,
  требующий несколько обращений к основной памяти  на пути преобразования виртуального
  адреса к физическому занимает много времени. В ряде обстоятельств такая задержка
  недопустима.  Эта проблема также находит  решение на уровне архитектуры компьютера.</p>
<p style='text-align:justify'>В соответствии со свойством локальности большинство
  программ в течение некоторого промежутка времени делают ссылки к небольшому
  числу страниц, таким образом, только небольшая часть таблицы страниц работает
  напряженно.</p>
<p style='text-align:justify'>Естественное решение -  снабдить компьютер  аппаратным
  устройством для отображения виртуальных  страниц в физические без обращения
  к таблице страниц,  то есть иметь небольшую, быструю  кэш-память,  хранящую
  необходимую на данный момент часть таблицы страниц.  Это устройство называется
  ассоциативная память,  иногда также употребляют термин ассоциативные регистры
  (иногда translation lookaside buffer (<font face="Times New Roman,sans-serif,Courier,mono"size="3">TLB</font>)). </p>
<p style='text-align:justify'>Одна запись в  таблице в ассоциативной памяти содержит
  информацию про одну виртуальную страницу, ее атрибуты и кадр, в котором она
  находится. Эти поля в точности соответствуют  полям в таблице  страниц.</p>
<p style='text-align:justify'>Отображение виртуальных страниц, хранимых в ассоциативной
  памяти, осуществляется быстро, однако кэш память является дорогостоящей и имеет
  ограниченный размер. Число  записей в TLB от 8 до 2048</p>
<p style='text-align:justify'>Память называется ассоциативной, потому что в отличие 
  от таблицы страниц, которая проиндексирована по номерам виртуальных страниц, 
  здесь происходит одновременное сравнение номера виртуальной страницы с соответствующим 
  полем во всех  строках  этой небольшой  таблицы.  Поэтому эта память является 
  дорогостоящей.  В строке, поле виртуальной страницы которой совпало с искомым 
  значением, находится номер страничного кадра.</p>
<p style='text-align:justify'>Рассмотрим  функционирование менеджера памяти при
  наличии ассоциативной памяти. Вначале  он  ищет виртуальную  страницу в ассоциативной
  памяти. Если  страница найдена - все нормально  за исключением случаев нарушения
  привилегий, когда запрос на обращение к памяти отклоняется.</p>
<p style='text-align:justify'> </p>
<p style='text-align:justify'>Если страницы нет в ассоциативной памяти, то она
  ищется через таблицу страниц. Происходит замена одной из страниц в ассоциативной
  памяти найденной страницей.  В таблице такая загруженная  страница помечается
  битом модификации, что будет учтено при следующей  загрузке ассоциативной памяти
  из таблицы страниц.</p>
<p style='text-align:justify'>Процент раз, когда номер страницы находится в ассоциативной 
  памяти, называется hit (совпадение) ratio (пропорция, отношение). Таким образом, 
  hit ratio - часть ссылок, которая  может быть сделана с использованием  ассоциативной 
  памяти. Обращение к одним и тем же страницам повышает hit ratio.</p>
<p style='text-align:justify'>Например,  предположим, что для доступа к таблице 
  страниц необходимо 100 нс, а для доступа к ассоциативной  памяти 20 нс. С 90% 
  hit ratio среднее  время доступа - 0.9*20+0.1*100 = 28 нс. </p>
<p style='text-align:justify'>Вполне приемлемая производительность современных
  ОС доказывает эффективность использования ассоциативной памяти.  Высокое значение
  вероятности нахождения данных в ассоциативной памяти связано с наличием у данных
  объективных свойств: пространственной и временной локальности. <font face="Times New Roman,sans-serif,Courier,mono"size="3"></font></p>
<p style='text-align:justify'>Необходимо обратить внимание на следующий факт.
  При  переключении процессов  нужно добиться того, чтобы новый процесс не видел
  в ассоциативной памяти информацию, относящуюся к предыдущему процессу, например,
  очищать ее.  Т.о.  использование ассоциативной памяти увеличивает время переключения
  контекстов.</p>
<p style='text-align:justify'><a name="l090205"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">9.2.5 Иерархия памяти</font></b></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Все предыдущие рассуждения
  справедливы и для других пар запоминающих устройств, например, для оперативной
  памяти и внешней памяти. В этом случае уменьшается среднее время доступа к данным,
  расположенным на диске, и роль кэш-памяти выполняет буфер в оперативной памяти.
  </font></p>
<p style='text-align:justify'>Рассмотренная нами схема трехуровневой памяти (ассоциативная, 
  основная, вторичная) является частным случаем <i>многоуровневой памяти.</i> 
  Например, как показано на рис. 9.5, разновидности памяти могут быть организованы 
  в иерархию по убыванию скорости доступа и возрастанию цены.  </p>
<p style='text-align:justify'>.<img border="0" src="images/image005.gif" width="510" height="271"> </p>
<p style='text-align:justify'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font size="2">Рис. 9.5  Иерархия памяти компьютера</font> </p>
<p style='text-align:justify'>Считается, что затраты, связанные с переписью информации 
  из одной памяти в другую окажутся меньше выигрыша в быстродействии, который 
  получается за счет сокращения времени выборки из более быстрых слоев памяти. 
  Информация о странице, которая находится в памяти верхнего уровня, хранится 
  также на уровнях с большими номерами. Если процессор не обнаруживает нужную 
  страницу на <font face="Times New Roman,sans-serif,Courier,mono"size="3">i</font>-м 
  уровне, он начинает искать ее на  последующих уровнях. Когда нужная страница 
  найдена, она переносится в более быстрые уровни. При этом происходит вытеснение 
  какой-то старой страницы, обычно той, которая дольше всего не использовалась. 
  Идея состоит в том, чтобы те страницы, которые чаще всего нужны в настоящее 
  время, находились в более быстрых частях памяти. Эффективность такой схемы обусловлена 
  все тем же свойством локальности (подробнее о локальности и связанным с ним 
  понятием рабочего множества страниц будет рассказано в следующей главе). В результате 
  среднее время доступа для многоуровневой схемы памяти оказывается весьма близким 
  ко времени доступа первого уровня.</p>
<p style='text-align:justify'><a name="l090206"></a>
<b>9.2.6  Размер страницы</b></p>
<p style='text-align:justify'>Дизайнеры ОС для существующих машин редко имеют
  возможность влиять на размер страницы.  Однако для вновь создаваемых компьютеров
  решение относительно оптимального размера страницы является актуальным. Как
  и можно было ожидать нет одного наилучшего размера. Скорее есть набор факторов,
  влияющих на размер. Обычно размер страницы это степень двойки от 2**9 до 2**14
  байт.</p>
<p style='text-align:justify'>Чем больше размер страницы, тем меньше будет размер
  структур данных, обслуживающих преобразование адресов, но тем больше будут потери,
  связанные с тем, что память можно выделять только постранично. </p>
<p style='text-align:justify'>Как следует выбирать размер страницы?  Во-первых, 
  нужно учитывать размер таблицы страниц,  здесь желателен большой размер страницы 
  (страниц меньше, соответственно и таблица страниц меньше).  С другой стороны 
  память лучше утилизируется с маленьким размером страницы. В среднем половина 
  последней страницы процесса пропадает. Необходимо также учитывать объем ввода-вывода 
  для взаимодействия с внешней памятью и другие факторы. Проблема не имеет хорошего 
  ответа.  Историческая тенденция состоит в увеличении размера страницы. Как правило, 
  размер страниц задается аппаратно, например, на Intel - это 4096 байт (или 4 
  Кбайт), на DEC PDP-11 - 8 Кбайт, на DEC VAX - 512 байт, на других архитектурах, 
  таких как Motorola 68030, размер страниц может быть задан программно.</p>
<p style='text-align:justify'>Итак, нами рассмотрены аппаратные особенности поддержки
  виртуальной памяти. Перейдем к ее программной поддержке.</p>

<p align="center"><a href="../08/ch8.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../10/ch10.htm"> Следующая глава</a></p>

</body>
</html>
