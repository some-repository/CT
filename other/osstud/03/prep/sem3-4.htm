<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Семинары 3-4</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman" SIZE = 6>Семинары 3-4. Процессы 
  в операционной системе UNIX.</FONT></B></P>
<P ALIGN="CENTER">(Основываются на <a href="../../02/l2.htm">лекции 
  2</a>) </P>
  <P align="center"><a href="../../01/prep/sem1-2.htm"> Предыдущий семинар</a> | <a href="../../os.html">Программа курса</a> | 
 <a href="../../05/prep/sem5.htm"> Следующий семинар</a></P>
<P ALIGN="CENTER"><B><font face="Times New Roman, Times, serif" size="4">Программа 
  семинаров</font></B></P>
<ol>
  <li><font face="Times New Roman, Times, serif" size="3"><a href="#s0301">Понятие процесса в UNIX, 
    его контекст.</a></font></li>
  <li><font face="Times New Roman, Times, serif" size="3"><a href="#s0302">Идентификация процесса.</a></font></li>
  <li><font face="Times New Roman, Times, serif" size="3"><a href="#s0303">Состояния процесса. 
    Краткая диаграмма состояний.</a></font></li>
  <li><font face="Times New Roman, Times, serif" size="3"><a href="#s0304">Иерархия процессов.</a>
    </font></li>
	<li><font face="Times New Roman, Times, serif" size="3">
	<a href="#s0305"> 
    Системные вызовы getpid(), getppid().</a></font></li>
  <li><font face="Times New Roman, Times, serif" size="3"><a href="#s0307">Создание процесса в 
    UNIX. Системный вызов fork().&nbsp;</a></font></li>
  <li><font face="Times New Roman, Times, serif" size="3"> <a href="#s0310"> Завершение 
    процесса. Функция exit().</a></font></li>
  <li><font face="Times New Roman, Times, serif" size="3"><a href="#s0311">Параметры функции main() 
    в языке С. Переменные среды и аргументы командной строки.</a></font> </li>
  <li><font face="Times New Roman, Times, serif" size="3"><a href="#s0313">Изменение 
    пользовательского контекста процесса. Семейство функций для системного вызова 
    exec().</a></font></li>
</ol>
<P ALIGN="CENTER"><font face="Times New Roman, Times, serif" size="3"><B><font size="4">Цели 
  занятия</font></B></font></P>
<OL>
  <LI><font face="Times New Roman, Times, serif" size="3">Дать понятие об иерархии 
    процессов в UNIX.</font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3">Дать понятие о содержании 
    контекста процесса в UNIX.</font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3">Научить создавать новый 
    процесс.</font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3">Научить запускать новую 
    программу.</font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3">Дать понятие об использовании 
    переменных среды и аргументов командной строки.</font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3">Студент должен осознать 
    разницу между системными вызовами fork() и exec().</font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3">Студент должен понять, 
    как завершается программа, написанная на C, даже если она не вызывает явно 
    функцию exit()</font></LI>
</OL>
<P ALIGN="CENTER"><font face="Times New Roman, Times, serif" size="3"><B><font size="4">Практические 
  работы</font></B></font></P>
<OL>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0306">Написание, компиляция 
    и запуск программы с системными вызовами getpid() и getppid().</a> </font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0308">Прогон программы с использованием 
    вызова fork(), где порожденный процесс делает то же самое, что и родитель.</a></font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0309">Написание, компиляция 
    и запуск программы с использованием 
    вызова fork()</a></font><a href="#s0309"><font face="Times New Roman, Times, serif" size="3">
    с разным поведением процессов ребенка и
    родителя.</font></a></LI>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0312">Написание, компиляция 
    и запуск программы с распечаткой 
    значений переменных среды и аргументов командной строки</a>.</font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0314">Прогон программы с использованием 
    системного вызова exec().</a></font></LI>
  <LI><font face="Times New Roman, Times, serif" size="3"><a href="#s0315">Написание, компиляция 
    и запуск программы для изменения
    пользовательского контекста в
    порожденном процессе.</a></font></LI>
</OL>
<P ALIGN="CENTER"><B><font face="Times New Roman, Times, serif" size="4">План
занятия</font></B></P>
<ol>
  <LI> 
    <p align="JUSTIFY"><font color="#FF0000"><b><a name="s0301"></a>Понятие процесса 
      в UNIX. Его контекст.<br>
      </b></font> <br>
    <font face="Times New Roman, Times, serif" size="3"><a href="../../02/ch2.htm#l0201"> 
    <img border="0" src="../../images/bookopen.gif" align="right" vspace="5" alt="Понятие процесса в лекции" hspace="10"> 
    </a>Все построение операционной системы UNIX основано на использовании концепции 
    процессов, которая&nbsp; обсуждалась на лекции. Контекст процесса складывается 
    из пользовательского контекста и контекста ядра, как изображено на рисунке:<br>
    <P ALIGN="CENTER"><img border="0" src="../images/s3-1.gif" align="absmiddle"></P>
    <p align="JUSTIFY">Под пользовательским контекстом процесса понимают код и 
      данные, расположенные в адресном пространстве процесса. Все данные подразделяются 
      на инициализируемые неизменяемые данные (например, константы), инициализируемые 
      изменяемые данные (все переменные, начальные значения которых присваиваются 
      на этапе компиляции), неинициализируемые изменяемые данные (все статические 
      переменные, которым не присвоены начальные значения на этапе компиляции), 
      стек пользователя и данные, расположенные в динамически выделяемой памяти 
      (например, с помощью стандартных библиотечных C функций malloc, calloc и 
      realloc). Исполняемый код и инициализируемые данные составляют содержимое&nbsp; 
      файла программы, который исполняется в контексте процесса. Пользовательский 
      стек используется при работе процесса в пользовательском режиме (user-mode).<br>
      <br>
      <a href="../../02/ch2.htm#l020302"><img border="0" src="../../images/bookopen.gif" alt="Понятие контекста процесса и PCB в лекции" align="right" vspace="1" hspace="10"></a> 
      Под понятием контекст ядра объединяются системный контекст и регистровый 
      контекст, рассмотренные на лекции. Мы будем выделять в контексте ядра стек 
      ядра, который используется при работе процесса в режиме ядра &nbsp;(kernel 
      mode), и данные ядра, хранящиеся в структурах, являющихся аналогом блока 
      управления процессом - PCB. Состав данных ядра будет уточняться на последующих 
      семинарах. На этом занятии нам достаточно знать, что в данные ядра входят: 
      идентификатор пользователя - UID, групповой идентификатор пользователя - 
      GID, идентификатор процесса - PID, идентификатор родительского процесса 
      - PPID.<br>
      &nbsp; 
    </font></LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><font color="#FF0000"><b><a name="s0302"></a>Идентификация 
      процесса.</b></font><br>
      <br>
      </font><font face="Times New Roman" size="3"><a href="../../02/ch2.htm#l020303a"><img border="0" src="../../images/bookopen.gif" alt="PID в лекции" align="right" hspace="10" vspace="1"></a>Каждый</font><font face="Times New Roman" size="3"><font face="Times New Roman, Times, serif" size="3"> 
      процесс </font></font><font face="Times New Roman" size="3">в операционной 
      системе </font><font face="Times New Roman, Times, serif" size="3"><font face="Times New Roman" size="3">получает 
      свой собственный уникальный идентификационный номер</font></font><font face="Times New Roman, Times, serif" size="3"> 
      PID (Process IDentificator)</font><font face="Times New Roman, Times, serif" size="3"><font face="Times New Roman" size="3">.</font> 
      При создании нового процесса операционная система пытается присвоить ему&nbsp; 
      свободный номер больший, чем у процесса, созданного перед ним. Если таких 
      свободных номеров не оказывается (например, мы достигли максимально возможного 
      номера для процесса), то операционная система выбирает минимальный из всех 
      свободных номеров. В операционной системе Linux присвоение идентификационных 
      номеров процессов начинается с номера 0, который получает процесс <i>kernel 
      </i>при старте операционной системы. Максимально возможное значение для 
      номера процесса в Linux на базе процессоров Intel составляет 2<sup>31</sup>-1. 
      <br>
      &nbsp;</font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"><a name="s0303"></a><font color="#FF0000"><b>Состояния 
      процесса. Краткая диаграмма состояний.</b></font><br>
      <br>
      <a href="../../02/ch2.htm#l0202"><img border="0" src="../../images/bookopen.gif" alt="Состояния процессов в лекции" align="right" hspace="10" vspace="1"></a> 
      Модель&nbsp;состояний процессов в операционной системе UNIX представляет 
      собой детализацию <a href="../../02/images/sr2-3.gif"> модели состояний, 
      принятой в лекционном курсе</a>.</font> 
    <font face="Times New Roman, Times, serif" size="3">Краткая диаграмма состояний 
    процессов в операционной системе UNIX изображена на рисунке: 
    <P ALIGN="CENTER"><img border="0" src="../images/s3-2.gif"></P>
    <p align="JUSTIFY">Как видим, состояние процесса <b><i>исполнение </i></b>расщепилось 
      на 2 состояния: <b><i>исполнение в режиме ядра</i></b> и <b><i>исполнение 
      в режиме пользователя</i></b>. В состоянии <b><i> исполнение в режиме пользователя</i></b> 
      процесс выполняет прикладные инструкции пользователя. В состоянии&nbsp; 
      <b><i>исполнение в режиме ядра</i></b> выполняются инструкции ядра операционной 
      системы в контексте текущего процесса (например, при обработке системного 
      вызова или прерывания). Из состояния<b><i> исполнение в режиме пользователя 
      </i></b> процесс не может непосредственно перейти в состояния <b><i> ожидание</i></b>, 
      <b><i> готовность</i></b> и <b><i> закончил исполнение</i></b>. Такие переходы 
      возможны только через промежуточное состояние <b><i> исполняется в режиме 
      ядра</i></b>. Точно также запрещен прямой переход из состояния<b><i> готовность</i></b> 
      в состояние <b><i> исполнение в</i></b> <b><i> режиме пользователя</i></b>.<br>
      <br>
      Приведенная выше диаграмма состояний процессов в Linux не является полной. 
      Она показывает только состояния, для понимания которых достаточно уже полученных 
      знаний. Полную диаграмму состояний процессов в операционной системе UNIX 
      можно найти в книге Баха &quot;Архитектура операционной системы UNIX&quot; 
      (рисунок 6.1.).<br>
      &nbsp; 
    </font></LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a name="s0304"></a><font color="#FF0000"><b>Иерархия 
      процессов.</b></font><br>
      <br>
      <a href="../../02/ch2.htm#l020303"><img border="0" src="../../images/bookopen.gif" alt="Иерархия процессов в лекции" align="right" hspace="10" vspace="1"></a> 
      &nbsp;В операционной системе UNIX все процессы кроме одного, создающегося 
      при старте операционной системы, могут быть порождены только какими-либо 
      другими процессами.&nbsp;В качестве&nbsp; процесса прародителя всех остальных 
      процессов в разных UNIX-ообразных системах могут выступать процессы с номерами 
      1 или 0.&nbsp; В операционной системе Linux таким родоначальником, существующим 
      только при загрузке,&nbsp; является процесс <i>kernel </i>с идентификатором 
      0.&nbsp;<br>
      <br>
      Таким образом, все процессы в UNIX связаны отношениями процесс-родитель 
      - процесс-ребенок, образуя генеалогическое дерево процессов. <a href="../../02/ch2.htm#l020303c"><img border="0" src="../../images/bookopen.gif" alt="Завершение процессов в лекции" align="right" hspace="10" vspace="1"></a>Для 
      сохранения целостности генеалогического дерева в ситуациях, когда процесс-родитель 
      завершает свою работу до завершения выполнения процесса-ребенка, идентификатор 
      родительского процесса в данных ядра процесса-ребенка (PPID - Parent Process 
      IDentificator) изменяет свое значение на значение 1, соответствующее идентификатору 
      процесса <i>init</i>, время жизни которого определяет время функционирования 
      операционной системы. Тем самым процесс init как бы усыновляет осиротевшие 
      процессы. Наверное, логичнее было бы изменять PPID не на значение 1, а на 
      значение идентификатора ближайшего существующего процесса-прародителя умершего 
      процесса-родителя, но в UNIX почему-то такая схема реализована не была.<br>
      &nbsp; </font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a name="s0305"></a><font color="#FF0000"><b>Системные 
      вызовы getppid() и getpid().</b></font><br>
      <br>
      Данные ядра, находящиеся в контексте ядра процесса, не могут быть прочитаны 
      процессом непосредственно. Для получения информации о них процесс должен 
      совершить соответствующий системный вызов. Значение идентификатора текущего 
      процесса может быть получено с помощью системного вызова <a href="../../man/getpid.htm">getpid()</a>, 
      а значение идентификатора родительского процесса для текущего процесса - 
      с помощью системного вызова <a href="../../man/getpid.htm">getppid()</a>.&nbsp;<br>
      &nbsp;</font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a name="s0306"></a><font color="#FF0000"><b>Написание 
      программы с использованием getpid() и getppid().</b></font> <br>
      <br>
      В качестве примера на использование системных вызовов <a href="../../man/getpid.htm">getpid() 
      и getppid()</a> студентам предлагается самостоятельно написать программу, 
      печатающую значения PID и PPID для текущего процесса.&nbsp;<br>
      &nbsp;</font> 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><font color="#FF0000"><a name="s0307"></a><b>Создание 
      процесса в UNIX. Системный вызов fork().</b> <br>
      </font> <br>
      <a href="../../02/ch2.htm#l020303a"><img border="0" src="../../images/bookopen.gif" alt="Создание процесса в лекции" align="right" hspace="10" vspace="1"></a>В 
      операционной системе UNIX новый процесс может быть порожден единственным 
      способом - с помощью системного вызова <a href="../../man/fork.htm">fork()</a>. 
      При этом вновь созданный процесс будет являться практически полной копией 
      родительского процесса.&nbsp;</font> <FONT FACE="Times New Roman"> У порожденного 
      процесса по сравнению с родительским процессом (на уровне уже полученных 
      знаний) изменяются значения следующих параметров:<br>
      &nbsp; </font> 
    <ul type="disc">
      <dir> 
        <li><font face="Times New Roman, Times, serif">идентификатор процесса 
          - PID;</font></li>
        <li><font face="Times New Roman, Times, serif">идентификатор родительского 
          процесса - PPID;</font></li>
      </dir>
    </ul>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"><br>
      Дополнительно к ним может измениться поведение порожденного процесса по 
      отношению к некоторым сигналам, о чем подробнее будет рассказано на <a href="../../13/prep/sem13-14.htm">семинарах 
      13-14</a>, когда мы будем говорить о сигналах в операционной системе UNIX.</font> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">В процессе 
      выполнения системного вызова <a href="../../man/fork.htm"> fork()</a> порождается 
      копия родительского процесса и возвращение из системного вызова будет происходить 
      уже как в родительском, так и в порожденном процессах. Этот системный вызов 
      является единственным, который вызывается один раз, а при успешной работе 
      возвращается два раза (один раз в процессе-родителе и один раз в процессе-ребенке)! 
      После выхода из системного вызова оба процесса продолжают выполнение регулярного 
      пользовательского кода, следующего за системным вызовом.</font><br>
      &nbsp; 
  </LI>
  <LI> <font color="#FF0000" size="3" face="Times New Roman, Times, serif"><b><a name="s0308"></a>Прогон 
    программы с fork() с одинаковой работой родителя и ребенка. <br>
    </b></font> <br>
    <font face="Times New Roman, Times, serif" size="3">Для иллюстрации вышесказанного 
    давайте рассмотрим <a href="../stud/03-1c.htm"> программу</a>, находящуюся 
    в файле /ftp/pub/sem3-4/stud/03-1.c, откомпилируем ее и запустим на исполнение.&nbsp;<br>
    &nbsp;</font></LI>
  <LI> 
    <p align="JUSTIFY"><b> <font face="Times New Roman, Times, serif" size="3" color="#FF0000">Системный 
      вызов fork() (продолжение).<br>
      <br>
      </font></b><font face="Times New Roman, Times, serif" size="3">Для того, 
      чтобы после возвращения из системного вызова <a href="../../man/fork.htm">fork()</a> 
      процессы могли определить, кто из них является ребенком, а кто родителем, 
      и, соответственно, по-разному организовать свое поведение, он возвращает 
      в них разные значения. При успешном создании нового процесса в процесс-родитель 
      возвращается положительное значение равное идентификатору процесса-ребенка. 
      В процесс-ребенок же возвращается значение 0. Если по какой-либо причине 
      создать новый процесс не удалось, то системный вызов вернет в инициировавший 
      его процесс значение -1. Таким образом, общая схема организации различной 
      работы процесса-ребенка и процесса-родителя выглядит так:<br>
      <br>
      </font> 
    <font face="Times New Roman, Times, serif" size="3"> 
    <dir><i><font color="#008000"><b>pid = <a href="../../man/fork.htm">fork()</a>;<br>
      if(pid == -1){<br>
      </b></font></i> 
      <dir><i><font color="#008000"><b>...<br>
        /* ошибка */<br>
        ...<br>
        </b></font></i> </dir>
      <i><font color="#008000"><b>} else if (pid == 0){<br>
      </b></font></i> 
      <dir><i><font color="#008000"><b>...<br>
        /* ребенок */<br>
        ...<br>
        </b></font></i> </dir>
      <i><font color="#008000"><b>} else {<br>
      </b></font></i> 
      <dir><i><font color="#008000"><b>...<br>
        /* родитель */<br>
        ...<br>
        </b></font></i> </dir>
      <i><font color="#008000"><b>}</b></font></i></dir>
    </font><br>
    &nbsp; </LI>
  <LI> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0309"></a>Написание, 
    компиляция и запуск программы с использованием вызова fork() с разным поведением 
    процессов ребенка и родителя.</b></font><font face="Times New Roman, Times, serif" size="3"><br>
    <br>
    </font> <font face="Times New Roman, Times, serif" size="3">Изменить предыдущую 
    <a href="../stud/03-1c.htm"> программу</a> с <a href="../../man/fork.htm">fork()</a> 
    так, чтобы родитель и ребенок совершали разные действия (какие не важно).<br>
    &nbsp; </font></LI>
  <LI> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0310"></a>Завершение 
    процесса. Функция exit(). </b></font> 
    <p align="JUSTIFY"><font face="Times New Roman"> Существует два способа корректного 
      завершения процесса в программах, написанных на языке C. Первый способ мы 
      использовали до сих пор: процесс корректно завершался по достижении конца 
      функции <b><font color="#008000">main() </font></b>или при выполнении оператора 
      <b><font color="#008000">return </font></b>в функции <font color="#008000"><b>main()</b></font>, 
      второй способ применяется при необходимости завершить процесс в каком-либо 
      другом месте программы. Для этого применяется функция <a href="../../man/exit.htm">exit()</a> 
      из стандартной библиотеки функций для языка C. При выполнении этой функции 
      происходит сброс всех частично заполненных буферов ввода-вывода с закрытием 
      соответствующих потоков, после чего инициируется системный вызов прекращения 
      работы процесса и перевода его в состояние <i><b>закончил исполнение</b></i>.</font> 
    <p align="JUSTIFY"><font face="Times New Roman">Возврата из функции в текущий 
      процесс не происходит и функция ничего не возвращает. </font> 
    <p align="JUSTIFY"><font face="Times New Roman">Значение параметра функции 
      <a href="../../man/exit.htm"> exit()</a> &#150; кода завершения процесса 
      &#150; передается ядру операционной системы и может быть затем получено 
      процессом, породившим завершившийся процесс.</font> <font face="Times New Roman, Times, serif" size="3">На 
      самом деле при достижении конца функции main() также неявно вызывается эта 
      функция со значением параметра 0.</font> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"><a href="../../02/ch2.htm#l020303c"><img border="0" src="../../images/bookopen.gif" alt="Завершение процессов в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a>Если 
      процесс завершает свою работу раньше, чем его родитель, и родитель явно 
      не указал, что он не хочет получать информацию о статусе завершения порожденного 
      процесса (об этом подробнее на <a href="../../13/prep/sem13-14.htm#s1317">семинарах 
      13-14</a> при изучении сигналов), то завершившийся процесс не исчезает из 
      системы окончательно, а остается в состоянии <i><b>закончил исполнение</b></i> 
      либо до завершения процесса-родителя, либо до того момента, когда родитель 
      соблаговолит получить эту информацию. Процессы, находящиеся в состоянии 
      <i> <b>закончил исполнение</b></i>, в операционной системе принято называть 
      процессами-зомби (zombie, defunct). <br>
      &nbsp;<br>
      </font> 
  </LI>
  <LI><font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0311"></a> 
    Параметры функции main() в языке C. Переменные среды и аргументы командной 
    строки.</b></font><br>
    <p align="JUSTIFY"> 
    <font face="Times New Roman, Times, serif" size="3"> У функции <font color="#008000"><b><i> 
    main()</i></b></font> в языке программирования C существует три параметра, 
    которые могут быть переданы ей операционной системой. Полный прототип функции 
    <font color="#008000"><b><i> main()</i></b></font> выглядит следующим образом:<br>
    &nbsp; <br>
    <dir><i><b><font color="#008000"> int main(int argc, char *argv[], char *envp[]); 
      </font></b></i> </dir>
    <br>
    Первые два параметра при запуске программы на исполнение командной строкой 
    позволяют узнать полное содержание командной строки. Вся командная строка 
    рассматривается как набор слов, разделенных пробелами. Через параметр <font color="#008000"><b><i> 
    argc</i></b></font> передается количество слов в командной строке, которой 
    была запущена программа. Параметр <font color="#008000"><b><i> argv</i></b></font> 
    является массивом указателей на отдельные слова. Так, например, если программа 
    была запущена командой&nbsp;<br>
    <br>
    <dir><b><font color="#008000">a.out 12 abcd<br>
      &nbsp;<br>
      </font></b></dir>
    то значение параметра <font color="#008000"><b><i>argc</i></b></font> будет 
    равно 3, <font color="#008000"><b><i>argv[0] </i></b></font>будет указывать 
    на имя программы - первое слово - &quot;<font color="#008000"><b>a.out</b></font>&quot;, 
    <font color="#008000"><b><i>argv[1] </i></b></font>- на слово &quot;<font color="#008000"><b>12</b></font>&quot;,&nbsp; 
    <font color="#008000"><b><i>argv[2]</i></b></font> - на слово &quot;<font color="#008000"><b>abcd</b></font>&quot;. 
    Заметим, что, так как имя программы всегда присутствует на первом месте в 
    командной строке, то <font color="#008000"><b><i>argc</i></b></font> всегда 
    больше 0, а <font color="#008000"><b><i>argv[0]</i></b></font> всегда указывает 
    на имя запущенной программы.<br>
    <font color="#008000"><b><br>
    </b></font> </font><font face="Times New Roman, Times, serif" size="3"> Анализируя 
    в программе содержимое командной строки, мы можем предусмотреть ее различное 
    поведение в зависимости от слов следующих за именем программы. Таким образом, 
    не внося изменений в текст программы, мы можем заставить ее работать по-разному 
    от запуска к запуску. Например компилятор <font color="#008000"><b>gcc</b></font>, 
    вызванный командой <font color="#008000"><b>gcc 1.c</b></font> будет генерировать 
    исполняемый файл с именем <font color="#008000"><b>a.out</b></font>, а при 
    вызове командой <font color="#008000"><b>gcc 1.c -o 1.exe</b></font> - файл 
    с именем <font color="#008000"><b>1.exe</b></font>.<br>
    <br>
    Третий параметр - <font color="#008000"><b>envp</b></font> - является массивом 
    указателей на&nbsp; параметры окружающей среды процесса.&nbsp; Начальные параметры 
    окружающей среды процесса задаются в специальных конфигурационных файлах для 
    каждого пользователя и устанавливаются при входе пользователя в систему. В 
    последующем они могут быть изменены с помощью специальных команд операционной 
    системы UNIX. Каждый параметр имеет вид: <b><i>переменная=строка</i></b>. 
    Такие переменные используются для изменения долгосрочного поведения процессов, 
    в отличие от аргументов командной строки. Например, задание параметра<font color="#008000"><b> 
    TERM=vt100</b></font> может говорить процессам, осуществляющим вывод на экран 
    дисплея, что работать им придется с терминалом vt100. Меняя значение переменной 
    среды <font color="#008000"><b>TERM</b></font>, например на <font color="#008000"><b>TERM=console</b></font>, 
    мы говорим таким процессам, что они должны изменить свое поведение на вывод 
    для системной консоли.<font face="Times New Roman, Times, serif" size="3"><b><font color="#008000"><br>
    <br>
    </font> </b>Размер массива аргументов командной строки в функции <b><i><font color="#008000">main()</font></i></b> 
    мы получали в качестве ее параметра. Так как для массива ссылок на параметры 
    окружающей среды такого параметра нет, то его размер определяется другим способом. 
    Последний элемент этого массива содержит указатель <b><i><font color="#008000">NULL</font></i></b>. 
    <br>
    &nbsp; <br>
    </font></font> </LI>
  <LI> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0312"></a>Написание, 
    компиляция и запуск программы, распечатывающей аргументы командной строки 
    и параметры среды.</b></font><font face="Times New Roman, Times, serif" size="3"><br>
    <br>
    </font><font face="Times New Roman, Times, serif" size="3">В качестве примера 
    студентам предлагается самостоятельно написать программу, распечатывающую 
    значения аргументов командной строки и параметров окружающей среды для текущего 
    процесса.<br>
    &nbsp;<br>
    </font></LI>
  <LI> 
    <p align="JUSTIFY"> <a href="03-3pc.htm"> <font face="Times New Roman, Times, serif" size="3"><font color="#FF0000"><b><a name="s0313"></a>Изменение 
      пользовательского контекста процесса. Семейство функций для системного вызова 
      exec().<br>
      </b></font><br>
      </font></a>
    <font face="Times New Roman, Times, serif" size="3"><a href="../../02/ch2.htm#l020303b"><img border="0" src="../../images/bookopen.gif" alt="Создание процесса в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a>Для 
    изменения пользовательского контекста процесса используется системный вызов 
    <a href="../../man/exec.htm">exec()</a>, который пользователь не может вызвать 
    непосредственно. Вызов <a href="../../man/exec.htm">exec()</a> заменяет&nbsp; 
    пользовательский контекст текущего процесса на содержимое некоторого исполняемого 
    файла и&nbsp; устанавливает начальные значения регистров процессора (в том 
    числе устанавливает программный счетчик на начало загружаемой программы). 
    Этот вызов требует для своей работы задания имени исполняемого файла, аргументов 
    командной строки и параметров окружающей среды. Для осуществления вызова программист 
    может воспользоваться одной из 6 функций: <a href="../../man/exec.htm">execlp(), 
    execvp(), execl(), execv(), execle(), execve()</a>, отличающихся друг от друга 
    представлением параметров, необходимых для работы системного вызова <a href="../../man/exec.htm"> 
    exec()</a>. Взаимосвязь указанных выше функций изображена на рисунке. <br>
    <p align="center"> <img border="0" src="../images/s3-3.gif" width="670" height="245"> 
      <br>
    <p align="JUSTIFY">Поскольку системный контекст процесса при вызове <a href="../../man/exec.htm">exec()</a> 
      остается практически неизменным, то большинство атрибутов процесса, доступных 
      пользователю через системные вызовы (PID, UID, GID, PPID и другие, смысл 
      которых будет становиться понятным по мере углубления наших знаний на дальнейших 
      занятиях), также не изменяется после запуска новой программы<br>
      <br>
      <img border="0" src="../../images/znak.gif" align="left" vspace="8" alt="Nota bene" hspace="10">Важно 
      понимать разницу между системными вызовами <a href="../../man/fork.htm">fork()</a> 
      и <a href="../../man/exec.htm">exec()</a> Системный вызов <a href="../../man/fork.htm">fork()</a> 
      создает новый процесс, у которого пользовательский контекст совпадает с 
      пользовательским контекстом процесса-родителя. Системный вызов <a href="../../man/exec.htm">exec()</a> 
      изменяет&nbsp; пользовательский контекст текущего процесса, не создавая 
      новый процесс.&nbsp;<br>
      <br>
    </font></LI>
  <LI><b><font face="Times New Roman, Times, serif" size="3" color="#FF0000"><a name="s0314"></a>Прогон 
    программы с использованием системного вызова exec().<br>
    <br>
    </font></b> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Для 
      иллюстрации использования системного вызова <a href="../../man/exec.htm">exec()</a> 
      давайте рассмотрим <a href="../stud/03-2c.htm"> программу</a> в файле /ftp/pub/sem3-4/stud/03-2.c, 
      откомпилируем ее и запустим на исполнение.&nbsp;Поскольку в результате должно 
      распечататься содержимое файла с именем 03-2.c, такой файл при запуске должен 
      присутствовать в текущей директории.<br>
      &nbsp;<br>
      </font> 
  </LI>
  <LI> <font face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0315"></a>Написание, 
    компиляция и запуск программы для изменения пользовательского контекста в 
    порожденном процессе.<br>
    <br>
    </b></font><font face="Times New Roman, Times, serif" size="3">Для закрепления 
    полученных знаний модифицируйте программу из <a href="#s0309">пункта 10</a> 
    так, чтобы порожденный процесс запускал на исполнение новую программу. <br>
    </font></LI>
</ol>
  
  <P align="center"><a href="../../01/prep/sem1-2.htm"> Предыдущий семинар</a> | <a href="../../os.html">Программа курса</a> | 
 <a href="../../05/prep/sem5.htm"> Следующий семинар</a></P>
</BODY>
</HTML>
