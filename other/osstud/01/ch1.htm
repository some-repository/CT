<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Глава 1</TITLE>
</HEAD>

<body lang=RU class="Normal" bgcolor="#FFFFFF">
<basefont face="Times New Roman, sans-serif, Courier, mono" size="3">
<p style='text-align:center'><font face="Times New Roman,sans-serif,Courier,mono" size="4"><b>
Глава 1. Введение</b></font></p>

<p align="center"><a href="../os.html">Программа курса</a> | 
<a href="../02/ch2.htm"> Следующая глава</a></P>


<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Операционная система (ОС)  - это  программа, которая
  обеспечивает возможность рационального использования оборудования  компьютера
  удобным для  пользователя образом. Цель вводной главы рассказать о предмете
  изучения настоящего курса. Вначале мы попытаемся ответить на вопрос, что такое
  ОС. Затем будет дан анализ эволюции ОС и объяснено возникновение основных концепций
  и компонентов современных ОС.  В заключение будет рассказано о классификации
  ОС с точки зрения особенностей архитектуры и  особенностей использования ресурсов
  компьютера.</font></p>
<p  align="center"><a name="l0101"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">1.1 Что такое операционная система.</font></b><b><font face="Times New Roman,sans-serif,Courier,mono"size="3"></font></b></p>
<p align="center"><a name="l010101"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">1.1.1 Структура вычислительной системы</font></b></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3"><i>Из чего состоит</i> любая вычислительная система?
  В первую очередь, это то, что в англоязычных странах принято называть словом
  <i>hardware</i>, или техническое обеспечение: процессор, память, монитор, дисковые
  устройства и т.д., обычно объединенные магистральным соединением, которое называется
  шиной </font></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Во вторую  очередь это <i>программное обеспечение</i>.
  Все программное обеспечение принято делить на две части: <i>прикладное и системное</i>.
  К прикладному программному обеспечению, как правило, относятся разнообразные
  банковские и прочие business программы, игры, текстовые процессоры, и т.п. Под
  системным программным обеспечением обычно понимают программы, способствующие
  функционированию и разработке прикладных программ. Надо сказать, что деление
  на прикладное и системное программное обеспечение является отчасти условным
  и зависит от того,  кто осуществляет такое деление. Так, обычный пользователь,
  неискушённый в программировании, может считать Microsoft Word системной программой,
  а с точки зрения программиста  это приложение. Компилятор  языка Си для обычного
  программиста  это системная программа, а для системного  прикладная. Несмотря
  на эту нечеткую грань, эту ситуацию можно отобразить в виде <i>последовательности
  слоев</i>:</font></p>
<p align="center"><img border="0" src="images/image001.gif" width="289" height="246"></p>
<p align="center"><font size="2">Рис. 1.1. Слои программного обеспечения компьютерной
  системы.</font></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Операционная система является фундаментальным компонентом
  системного программного обеспечения. Слой  ОС  основной предмет настоящего
  курса лекций.</font></p>
<p  align="center"><a name="l010102"></a><b> <font face="Times New Roman,sans-serif,Courier,mono"size="3">1.1.2 
  Что такое ОС</font></b></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Большинство пользователей имеет свой опыт эксплуатации
  операционных систем, но, тем не менее, затруднятся дать точное определение.
  Давайте кратко рассмотрим основные точки зрения.</font></p>
<p align="center"><font face="Times New Roman,sans-serif,Courier,mono"size="3"><font face="Times New Roman,sans-serif,Courier,mono"size="3"><font face="Times New Roman,sans-serif,Courier,mono"size="3"><i>Операционная система как виртуальная
  машина</i></font></font></font></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Архитектура большинства компьютеров на уровне машинных
  команд очень неудобна для ее использования прикладными программами. Например,
  работа с диском предполагает знакомство с внутренним устройством его электронного
  компонента - контроллера для ввода команд вращения диска, поиска и форматирования
  дорожек, чтения и записи секторов и т.д. Ясно, что средний программист не в
  состоянии учитывать все особенности работы оборудования (в современной терминологии
   заниматься разработкой драйверов устройств), а должен иметь простую высокоуровневую
  абстракцию, скажем, представляя информационное пространство диска как набор
  файлов Файл можно открывать для чтения или записи, использовать для получения
  или сброса информации, а потом закрывать. Это концептуально проще, чем заботиться
  о деталях перемещения головок дисков или организации работы мотора. Аналогичным
  образом, с помощью простых и ясных абстракций, скрываются от программиста все
  ненужные ему подробности организации прерываний, работы таймера, управления
  памятью и т.д. Более того,  на современных вычислительных комплексах может быть
  создана иллюзия неограниченного размера операционной памяти и числа процессоров.
  Всем этим занимается операционная система. Таким образом, операционная система
  представляется пользователю виртуальной машиной, с которой проще иметь дело,
  чем непосредственно с оборудованием компьютера.</font></p>
<font face="Times New Roman,sans-serif,Courier,mono"size="3"><p align="center"><i>Операционная система как
менеджер ресурсов</i></p>
<p style='text-align:justify'>Операционная система предназначена для управления
  всеми частями весьма сложной архитектуры компьютера. Представим для примера,
  что случится, если несколько программ, работающих на одном компьютере, будут
  пытаться одновременно осуществлять вывод на принтер. Мы получили бы неупорядоченную
  смесь строчек и страниц, выведенных различными программами. Операционная система
  предотвращает хаос такого рода за счет буферизации информации, предназначенной
  для печати, на диске и организации очереди на печать. Для многопользовательских
  компьютеров, необходимость управления ресурсами и их защиты еще более очевидна.
  Следовательно, операционная система как менеджер ресурсов, осуществляет упорядоченное
  и контролируемое распределение процессоров, памяти и других ресурсов между различными
  программами,  их использующими.</p>
<p align="center"><i>Операционная система как
защитник пользователей и программ</i></p>
<p align="justify">Если вычислительная система допускает
  совместную работу нескольких пользователей, то возникает проблема организации
  их безопасной деятельности. Необходимо обеспечить сохранность информации на
  диске, чтобы никто не мог удалить или повредить чужие файлы. Нельзя разрешить
  программам одних пользователей произвольно вмешиваться в работу программ других
  пользователей. Нужно пресекать попытки несанкционированного использования вычислительной
  системы. Всю эту деятельность осуществляет операционная система как организатор
  безопасной работы пользователей и их программ. С такой точки зрения  операционная
  система выглядит системой безопасности в государстве, на которую возложены полицейские
  и контрразведывательные функции.</p></font>
<p align="center"><font face="Times New Roman,sans-serif,Courier,mono" size="3"><i>Операционная 
  система как постоянно функционирующее ядро</i></font></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Наконец, можно дать и такое определение: операционная
  система  это программа, постоянно работающая на компьютере и взаимодействующая
  со всеми прикладными программами. Казалось бы, это абсолютно правильное определение,
  но, как мы увидим дальше, во многих  современных операционных системах постоянно
  работает на компьютере лишь часть операционной системы, которую принято называть
  ее ядром. </font></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" size="3">Как
  видим, существует много точек зрения на то, что такое операционная система.
  Не существует ее адекватного строгого определения. Нам проще сказать, не что
  есть операционная система, а для чего она нужна, и что она делает. Для выяснения
  этого вопроса кратко рассмотрим историю развития вычислительных систем.</font></p>
<p align="center"> <a name="l0102"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">1.2&nbsp; </font></b><b><font face="Times New Roman,sans-serif,Courier,mono" size="3">Краткая история эволюции
  вычислительных систем</font></b></p>
<font face="Times New Roman,sans-serif,Courier,mono"size="3"><p style='text-align:justify'>Мы будем рассматривать историю развития именно вычислительных,
  а не операционных систем, потому что hardware и программное обеспечение эволюционировали
  совместно, оказывая взаимное влияние друг на друга. Появление новых технических
  возможностей приводило к прорыву в области создания удобных, эффективных и безопасных
  программ, а новые идеи в программной области стимулировали поиски новых технических
  решений. Именно эти критерии  удобство, эффективность и безопасность играли
  роль факторов естественного отбора при эволюции вычислительных систем.</p>
<p align="center"><i>Первый период  (1945-1955).  Ламповые машины.&nbsp;
Операционные систем отсутствовали.</i></p>
<p style='text-align:justify'>Мы начнем исследование развития компьютерных комплексов
  с появления электронных вычислительных систем (опуская историю механических
  и электромеханических устройств).</p>
<p style='text-align:justify'>Первые шаги по созданию электронных вычислительных
  машин были предприняты в конце второй мировой войны. В середине 40-х были созданы
  первые ламповые вычислительные устройства, и появился принцип программы, хранимой
  в памяти машины (John Von Neumann, июнь 1945г). В то время одна и та же группа
  людей участвовала и в проектировании, и в эксплуатации, и в программировании
  вычислительной машины. Это была скорее научно-исследовательская работа в области
  вычислительной техники, а не регулярное использование компьютеров в качестве
  инструмента решения каких-либо практических задач из других прикладных областей.
  Программирование осуществлялось исключительно на машинном языке. Об операционных
  системах не было и речи, все задачи организации вычислительного процесса решались
  вручную каждым программистом с пульта управления. За пультом мог находиться
  только один пользователь. Программа загружалась в память машины в лучшем случае
  с колоды перфокарт, а обычно с помощью панели переключателей. Вычислительная
  система выполняла одновременно только одну операцию (ввод-вывод, собственно
  вычисления, размышления программиста). Отладка программ велась с пульта управления
  с помощью изучения состояния памяти и регистров машины. В конце этого периода
  появляется первое системное программное обеспечение: в 1951-52 гг. возникают
  прообразы первых компиляторов с символических языков (<font face="Times New Roman,sans-serif,Courier,mono"size="3">Fortran</font>
  и др.), а в 1954 г. Nat Rochester разрабатывает ассемблер для IBM-701. В целом
  первый период характеризуется крайне высокой стоимостью вычислительных систем,
  их малым количеством и низкой эффективностью использования.</p>
<p align="center"><i>Второй период  (1955-Начало
  60-х). Компьютеры на основе транзисторов.  Пакетные операционные системы</i></p>
<p style='text-align:justify'>С середины 50-х годов начался новый период в эволюции
  вычислительной техники, связанный с появлением новой технической базы - полупроводниковых
  элементов. Применение транзисторов вместо часто перегоравших электронных ламп
  привело к повышению надежности компьютеров. Теперь они смогли непрерывно работать
  настолько долго, чтобы на них можно было возложить выполнение действительно
  практически важных задач. Снизилось потребление вычислительными машинами электроэнергии.
  Проще стали системы охлаждения. Размеры компьютеров уменьшились. Эксплуатация
  и обслуживание вычислительной техники подешевели. Началось использование ЭВМ
  коммерческими фирмами. Одновременно наблюдается бурное развитие алгоритмических
  языков (ALGOL-58, LISP, COBOL, ALGOL-60, PL-1 и т.д.). Появляются первые настоящие
  компиляторы, редакторы связей, библиотеки математических и служебных подпрограмм.
  Упрощается процесс программирования. Пропадает необходимости взваливать на одних
  и тех же людей весь процесс разработки и использования компьютеров. Именно в
  этот период происходит разделение персонала на программистов и операторов, специалистов
  по эксплуатации и разработчиков вычислительных машин. </p>
<p style='text-align:justify'>Изменяется сам процесс прогона программ. Теперь
  пользователь приносит программу с входными данными в виде колоды перфокарт и
  указывает требуемые для нее ресурсы.  Такая колода получает название <i>задания</i>.
  Оператор загружает задание в память машины и запускает его на исполнение. Полученные
  выходные данные  печатаются на принтере, и  пользователь получает их обратно
  через некоторое (довольно большое) время.  </p>
<p style='text-align:justify'>Смена запрошенных ресурсов вызывает приостановку
  выполнения программ. В результате процессор часто простаивает. Для повышения
  эффективности использования компьютера задания с похожими требуемыми ресурсами
  начинают собирать вместе, создавая <i>пакет заданий</i>.</p>
<p style='text-align:justify'>Появляются первые системы пакетной обработки, которые
  просто автоматизируют запуск одной программы из пакета за другой и, тем самым,
  увеличивают коэффициент загрузки процессора. При реализации систем пакетной
  обработки был разработан формализованный язык управления заданиями, с помощью
  которого программист сообщал системе и оператору, какую работу он хочет выполнить
  на вычислительной машине. Системы пакетной обработки явились прообразом современных
  операционных систем, они стали первыми системными программами, предназначенными
  для управления вычислительным процессом. </p>
<p align="center"><i>Третий период (Начало 60-х -
  1980).  Компьютеры на основе интегральных микросхем. Первые многозадачные ОС.</i></p>
<p style='text-align:justify'>Следующий важный период развития вычислительных
  машин относится к началу 60-х - 1980 годам. В это время в технической базе произошел
  переход от отдельных полупроводниковых элементов типа транзисторов к интегральным
  микросхемам. Вычислительная техника становится более надежной и дешевой. Растет
  сложность и количество задач, решаемых компьютерами. Повышается производительность
  процессоров. </p>
<p style='text-align:justify'>Повышению эффективности использования процессорного
  времени мешает низкая скорость  механических устройств ввода-вывода (быстрый
  считыватель перфокарт мог обработать 1200 перфокарт в минуту, принтеры печатали
  до 600 строк в минуту). Вместо непосредственного чтения пакета заданий с перфокарт
  в память начинают использовать его предварительную запись сначала на магнитную
  ленту, а затем и на диск. Когда в процессе выполнения заданию требуется ввод
  данных, они читаются с диска. Точно так же выходная информация сначала копируется
  в системный буфер и записывается на ленту или диск, а реально печатается только
  после завершения задания. Вначале действительные операции ввода-вывода осуществлялись
  в режиме off-line, то есть с использованием других, более простых, отдельно
  стоящих компьютеров. В дальнейшем они начинают выполняться на том же компьютере,
  который производит вычисления, то есть в режиме on-line. Такой прием получает
  название <i>spooling</i> (сокращение от Simultaneous Peripheral Operation On
  Line) или <i>подкачки-откачки данных</i>. Введение техники подкачки-откачки
  в пакетные системы позволило совместить реальные операции ввода-вывода одного
  задания с выполнением другого задания, но потребовало появления аппарата прерываний
  для извещения процессора об окончании этих операций.</p>
<p style='text-align:justify'>Магнитные ленты были устройствами последовательного
  доступа, то есть информация считывалась с них в том порядке, в каком была записана.
  Появление магнитного диска, для которого не важен порядок чтения информации,
  то есть устройства прямого доступа, привело к дальнейшему развитию вычислительных
  систем. При обработке пакета заданий на магнитной ленте очередность запуска
  заданий определялась порядком их ввода. При обработке пакета заданий на магнитном
  диске появляется возможность выбора очередного выполняемого задания. Пакетные
  системы начинают заниматься <i>планированием заданий</i>: в зависимости от наличия
  запрошенных ресурсов, срочности вычислений и т.д. на счет выбирается то или
  иное задание.</p>
<p style='text-align:justify'>Дальнейшее повышение эффективности использования
  процессора было достигнуто с помощью  <i>мультипрограммирования</i>. Идея мультипрограммирования
  заключается в следующем: пока одна программа выполняет операцию ввода-вывода,
  процессор не простаивает, как это происходило при однопрограммном режиме, а
  выполняет другую программу.  Когда операция ввода-вывода заканчивается, процессор
  возвращается к выполнению первой программы. Эта идея напоминает поведение преподавателя
  и студентов на экзамене. Пока один студент (программа) обдумывает ответ на поставленный
  вопрос (операция ввода-вывода), преподаватель (процессор) выслушивает ответ
  другого студента (вычисления). Естественно, что такая ситуация требует наличия
  в комнате нескольких студентов. Точно также мультипрограммирование требует наличия
  в памяти нескольких программ одновременно. При этом каждая программа загружается
  в свой участок оперативной памяти, называемый разделом, и не должна влиять на
  выполнение другой программы.  (Студенты сидят за отдельными столами и не подсказывают
  друг другу.)</p>
<p style='text-align:justify'>Появление мультипрограммирования требует целой революции
  в строении вычислительной системы.  Большую роль, здесь играет аппаратная поддержка,
  наиболее существенные особенности которой:</p>
<ul type=disc>
  <li style='text-align:justify;     '>Реализация защитных механизмов.  Программы
    не должны иметь самостоятельного доступа к распределению ресурсов, что приводит
    к появлению <i>привилегированных и непривилегированных команд</i>. Привилегированные
    команды, например команды ввода-вывода, могут исполняться только операционной
    системой. Говорят, что она работает в привилегированном режиме. Переход управления
    от прикладной программы к ОС сопровождается контролируемой сменой режима.
    Во-вторых, это защита памяти,  позволяющая изолировать конкурирующие пользовательские
    программы друг от друга, а ОС от программ пользователей. </li>
  <li style='text-align:justify;     '>Наличие прерываний.  Внешние прерывания
    оповещают  ОС о  том, что произошло асинхронное событие, например, завершилась
    операция ввода-вывода. Внутренние прерывания (сейчас их принято называть исключительными
    ситуациями)  возникают, когда выполнение программы привело к ситуации, требующей
    вмешательства ОС, например, деление на ноль или попытка нарушения  защиты.</li>
</ul>
<p style='text-align:justify'>Не менее важна в организации мультипрограммирования
  роль операционной системы. Наиболее
существенные изменения состояли в
следующем:</p></font>
<ul>
  <li>
    <p style="text-align:justify"><span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;</span><span style="font-family:&quot;Times New Roman&quot;">Интерфейс
    между прикладной программой и ОС был
    организован при помощи<span style="mso-spacerun: yes">&nbsp;
    </span>набора <i style="mso-bidi-font-style:normal">системных
    вызовов</i>.<o:p>
    </o:p>
    </span></li>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">  <li>
    <p style="text-align:justify">Организация очереди из
    заданий в памяти и<span style="mso-spacerun: yes">&nbsp; </span>выделение
    процессора одному из заданий потребовали<b style="mso-bidi-font-weight:normal">
    </b><i><span style="mso-bidi-font-weight:bold">планирования</span></i><span style="mso-bidi-font-weight:bold">
    </span>заданий.</li>
  <li>
    <p style="text-align:justify">Для переключения
    процессора&nbsp; с одного задания на другое
    возникла потребность в&nbsp; сохранении
    содержимого регистров и структур данных,
    необходимых для выполнения задания,
    иначе говоря, <i>контекста</i>, для
    обеспечения правильного продолжения
    вычислений.</li>
  <li>Поскольку память является ограниченным
    ресурсом, оказались нужны <i>стратегии<span style="mso-spacerun: yes">&nbsp;
    </span>управления памятью</i>, то есть
    потребовалось упорядочить процессы
    размещения, замещения и выборки<span style="mso-spacerun: yes">&nbsp;
    </span>информации из памяти.</li>
  <li>Так как программы могут пожелать
    произвести санкционированный обмен
    данными, стало необходимо их обеспечить <i>средствами
    коммуникации</i>. И, наконец,</li>
  <li>Для корректного обмена данными
    необходимо предусмотреть координацию
    программами своих действий, т.е. <i>средства
    синхронизации</i>.</li></font>
</ul>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">
<p style='text-align:justify'>Мультипрограммные пакетные системы дают окружение,
в котором&nbsp; различные системные ресурсы (например, процессор, память, периферийные
  устройства) используются эффективно. И все же пользователь не мог непосредственно
  взаимодействовать с заданием и должен был предусмотреть с помощью управляющих
  карт все возможные ситуации. Отладка программ по-прежнему занимала много времени
  и требовала изучения многостраничных распечаток содержимого памяти и регистров
  или использования отладочной печати.</p>
<p style='text-align:justify'>Появление электроннолучевых дисплеев и переосмысление
  возможностей применения клавиатур поставили на очередь решение этой проблемы.
  Логическим расширением систем мультипрограммирования стали <i>time-sharing системы</i>
  или <i>системы разделения времени **</i>. В них процессор переключается между
  задачами не только на время операций ввода-вывода, но и просто по прошествии
  определенного интервала времени. Эти переключения происходят столь часто, что
  пользователи могут взаимодействовать со своими программами во время их выполнения,
  то есть интерактивно. В результате появляется возможность одновременной работы
  многих пользователей на одной компьютерной системе. У каждого пользователя для
  этого должна быть хотя бы одна программа в памяти. Чтобы уменьшить ограничения
  на количество работающих пользователей, была внедрена идея неполного нахождения
  исполняемой программы в оперативной памяти. Основная часть программы находится
  на диске и необходимый для ее дальнейшего выполнения  кусок может быть легко
  загружен в оперативную память, а ненужный   выкачан обратно на диск. Это реализуется
  с помощью механизма <i>виртуальной памяти</i>. Основным достоинством такого
  механизма является создание иллюзии неограниченной оперативной памяти ЭВМ.</p>
<p style='text-align:justify'>В системах разделения времени пользователь получил
  возможность легко и эффективно вести отладку своей программы в интерактивном
  режиме, записывать информацию на диск, не используя перфокарты, а непосредственно
  с клавиатуры. Появление on-line файлов привело к необходимости разработки развитых
  <i>файловых систем</i>. </p>
<p style='text-align:justify'>Параллельно внутренней эволюции вычислительных систем
  в этот период наблюдается и внешняя их эволюция. До начала этого периода вычислительные
  комплексы были, как правило, несовместимы. Каждый имела свою собственную специальную
  операционную систему, свою систему команд и т.д. В результате программу, успешно
  работающую на одном типе машин, необходимо было полностью переписать и заново
  отладить для другого типа компьютеров. В начале третьего периода появилась идея
  создания семейств программно-совместимых машин, работающих под управлением одной
  и той же операционной системы. Первым семейством программно-совместимых машин,
  построенных на интегральных микросхемах, явилась серия машин IBM/360. Построенное
  в начале 60-х годов это семейство значительно превосходило машины второго поколения
  по критерию цена/производительность. За ней последовала линия компьютеров PDP,
  несовместимых с линией IBM, кульминацией которой  стала PDP-11.</p></font>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3"> Сила одной семьи была одновременно
  и ее слабостью. Широкие возможности этой концепции (наличие всех моделей: от
  миникомпьютеров до гигантских машин; обилие разнообразной периферии; различное
  окружение; различные пользователи) порождали сложную и огромную операционную
  систему. Миллионы строчек ассемблера, написанные тысячами программистов, содержали
  множество ошибок, что вызывало непрерывный поток публикаций о них и попыток
  их исправления. Только в операционной системе OS/360 содержалось более 1000
  известных ошибок. Тем не менее, идея стандартизации операционных систем была
  широко внедрена в сознание пользователей и в дальнейшем получила активное развитие.</font></p>
<p align="center"><i><font face="Times New Roman,sans-serif,Courier,mono"size="3">Четвертый период (1980-настоящее время).
  Персональные компьютеры. Классические, сетевые и распределенные системы.</font></i></p>
<font face="Times New Roman,sans-serif,Courier,mono"size="3"><p style='text-align:justify'>Следующий период в эволюции вычислительных систем
  связан с появлением больших интегральных схем (БИС). В эти годы произошло резкое
  возрастание степени интеграции и удешевление микросхем. Компьютер, не отличающийся
  по архитектуре от PDP-11, по цене и простоте эксплуатации стал доступен отдельному
  человеку, а не отделу предприятия или университета. Наступила эра персональных
  компьютеров. Первоначально персональные компьютеры предназначались для использования
  одним пользователем в однопрограммном режиме, что повлекло за собой деградацию
  архитектуры этих ЭВМ и их операционных систем (в частности, пропала необходимость
  защиты файлов и памяти, планирования заданий и т.п.).</p>
<p style='text-align:justify'>Компьютеры стали широко использоваться неспециалистами,
  что потребовало разработки &quot;дружественного&quot; программного обеспечения,
  это положило конец кастовости программистов. </p>
<p style='text-align:justify'>Однако рост сложности и разнообразия задач, решаемых
  на персональных компьютерах, необходимость повышения надежности их работы привели
  к возрождению практически всех черт, характерных для архитектуры больших вычислительных
  систем.</p>
<p style='text-align:justify'>В середине 80-х стали бурно развиваться сети компьютеров,
  в том числе персональных, работающих под управлением <i>сетевых</i> или <i>распределенных</i>
  операционных систем. </p>
<p style='text-align:justify'>В сетевых операционных системах пользователи, при
  необходимости воспользоваться ресурсами другого сетевого компьютера, должны
  знать о его наличии и уметь это сделать. Каждая машина в сети работает под управлением
  своей локальной операционной системы, отличающейся от операционной системы автономного
  компьютера наличием дополнительных средств (программной поддержкой для сетевых
  интерфейсных устройств  и  доступа к удаленным ресурсам), но эти дополнения
  существенно не меняют структуру операционной системы. </p>
<p style='text-align:justify'>Распределенная система, напротив, внешне выглядит
  как обычная автономная система. Пользователь не знает и не должен знать, где
  его файлы хранятся  на локальной или удаленной машине, и где его программы
  выполняются. Он может вообще не знать, подключен ли его компьютер к сети. Внутреннее
  строение распределенной операционной системы имеет существенные отличия от автономных
  систем.</p>
<p style='text-align:justify'>В дальнейшем автономные операционные системы мы
  будем называть <i>классическими </i>операционными системами.</p>
<p style='text-align:center'><i><font face="Times New Roman,sans-serif,Courier,mono"size="3">Что мы вынесли из истории развития
  вычислительных систем?</font></i></p>
<p style='text-align:justify'>Просмотрев этапы развития вычислительных систем,
  мы можем выделить пять основных функций, которые выполняли классические операционные
  системы в процессе своей эволюции:</p>
<ol>
  <li>
    <p style="text-align:justify;">Планирование заданий и использования процессора.</li>
  <li>
    <p style="text-align:justify;">Обеспечение программ средствами коммуникации и синхронизации.</li>
  <li>
    <p style="text-align:justify;">Управление памятью.</li>
  <li>
    <p style="text-align:justify;">Управление файловой системой.</li>
  <li>
    <p style="text-align:justify;">Управление вводом-выводом.</li>
  <li>
    <p style="text-align:justify;">Обеспечение безопасности</li>
</ol>
<p style='text-align:justify'>Каждая из приведенных функций обычно реализована
  в виде подсистемы, являющейся структурным компонентом ОС. В каждой конкретной
  операционной системе эти функции, конечно, реализовывались по-своему, в различном
  объеме. Они не были придуманы как составные части деятельности операционных
  систем изначально, а появились в процессе развития, по мере того, как вычислительные
  системы становились удобнее, эффективнее и безопаснее. Эволюция вычислительных
  систем, созданных человеком пошла по такому пути, но никто еще не доказал, что
  это единственно возможный путь их развития. Операционные системы существуют
  потому, что на настоящий момент их существование - это разумный способ использования
  вычислительных систем. Рассмотрение общих принципов и алгоритмов реализации
  их функций и будет составлять содержание большей части нашего курса. </p>
<p align="center"><a name="l0103"></a>
<b>1.3&nbsp; Основные понятия, концепции ОС.</b></p>
<p style='text-align:justify'>В процессе эволюции возникло несколько важных концепций,
  которые стали неотъемлемой частью теории и практики ОС. Рассматриваемые в данном
  разделе понятия будут встречаться и разъясняться на протяжении всего настоящего
  курса. Здесь дается их краткое описание.</p>
<p style='text-align:center'><i>Системные вызовы</i></p>
<p style='text-align:justify'>В любой операционной системе поддерживается некоторый
  механизм, который позволяет пользовательским программам обращаться за услугами
  ядра ОС. В операционных системах наиболее известной советской вычислительной
  машины БЭСМ-6 соответствующие средства общения с ядром назывались экстракодами,
  в операционных системах IBM они назывались системными макрокомандами и т.д.
  В ОС UNIX такие средства называются <i>системными вызовами</i>. </p>
<p style='text-align:justify'><i>Системные вызовы (system calls)</i>&nbsp; интерфейс
  между операционной системой и пользовательской программой. Они создают, удаляют
  и используют различные объекты, главные из которых&nbsp; <i>процессы</i> и
  <i>файлы</i>. Пользовательская программа запрашивает сервис у операционной системы,
  осуществляя системный вызов. Имеются библиотеки процедур, которые загружают
  машинные регистры определенными параметрами и осуществляют прерывание процессора,
  после чего управление передается обработчику данного вызова, входящему в ядро
  операционной системы. Цель таких библиотек&nbsp; сделать системный вызов похожим
  на обычный вызов подпрограммы.</p>
<p style='text-align:justify'>Основное отличие состоит в том, что при системном
  вызове задача переходит в привилегированный режим или  <i>режим ядра (kernel
  mode)</i>. Поэтому  системные вызовы иногда еще называют программными прерываниями
  в отличие от аппаратных прерываний, которые чаще называют просто прерываниями.</p>
<p style='text-align:justify'> В этом режиме работает код ядра операционной системы,
  причем он исполняется в адресном пространстве и в контексте вызвавшей его задачи.
  Таким образом, ядро операционной системы имеет полный доступ к памяти пользовательской
  программы, и при системном вызове достаточно передать адреса одной или нескольких
  областей памяти с параметрами вызова и адреса одной или нескольких областей
  памяти для результатов вызова.</p>
<p style='text-align:justify'>В большинстве операционных систем системный вызов
  осуществляется командой программного прерывания (INT).  Таким образом, программное
  прерывание&nbsp; это <i>синхронное</i> событие.</p>
<p style='text-align:center'><i>Прерывания</i></p>
<p style='text-align:justify'><i>Прерывание (hardware interrupt)</i>&nbsp; событие,
  генерируемое внешним (по отношению к процессору) устройством. Посредством аппаратных
  прерываний аппаратура либо информирует центральный процессор о том, что возникло
  какое&#8209;либо событие, требующее немедленной реакции (например, пользователь
  нажал клавишу), либо сообщает о завершении асинхронной операции ввода&#8209;вывода
  (например, закончено чтение данных с диска в основную память). Важный тип аппаратных
  прерываний&nbsp; прерывания таймера, которые генерируются периодически через
  фиксированный промежуток времени. Прерывания таймера используются операционной
  системой при планировании процессов. Каждый тип аппаратных прерываний имеет
  собственный номер, однозначно определяющий источник прерывания. Аппаратное прерывание&nbsp;
  это <i>асинхронное</i> событие, то есть оно возникает вне зависимости от того,
  какой код исполняется процессором в данный момент. Обработка аппаратного прерывания
  не должна учитывать, какой процесс является текущим.</p>
<address style='text-align:center'>Исключительные
  ситуации</address>
<p style='text-align:justify'><i>Исключительная ситуация (exception)</i>&nbsp;
  событие, возникающее в результате попытки выполнения программой недопустимой
  команды, доступа к ресурсу при отсутствии достаточных привилегий или обращения
  к отсутствующей странице памяти. Исключительные ситуации так же, как и системные
  вызовы, являются синхронными событиями, возникающими в контексте текущей задачи.
  Исключительные ситуации можно разделить на исправимые и неисправимые. К исправимым
  относятся такие исключительные ситуации, как отсутствие нужной информации в
  оперативной памяти. После устранения причины исправимой исключительной ситуации
  программа может продолжить выполнение. Возникновение в процессе работы операционной
  системы исправимых исключительных ситуаций является нормальным явлением. Неисправимые
  исключительные ситуации обычно возникают в результате ошибок в программах. Обычно
  операционная система реагирует на такие ситуации завершением программы, вызвавшей
  исключительную ситуацию.</p>
<p style='text-align:center'><font face="Times New Roman,sans-serif,Courier,mono"size="3"><i>Файлы</i></font></p>
<p style='text-align:justify'>Файлы предназначены для хранения информации на внешних 
  носителях, то есть, принято, что информация, лежащая, например, на диске, должна 
  находиться внутри файла. Обычно под файлом понимают часть пространства на носителе 
  информации, имеющую имя.</p>
</font>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Главная задача <i>файловой системы (file system)</i>&nbsp;
  скрыть особенности ввода-вывода и дать программисту простую абстрактную модель
  файлов, независимых от устройств. Для чтения, создания, удаления, записи, открытия
  и закрытия файлов также имеется обширная категория системных вызовов (create</font>, <font face="Times New Roman,sans-serif,Courier,mono"size="3">delete</font>, <font face="Times New Roman,sans-serif,Courier,mono"size="3">open</font>,
  <font face="Times New Roman,sans-serif,Courier,mono"size="3">close</font>, <font face="Times New Roman,sans-serif,Courier,mono"size="3">read</font>, <font face="Times New Roman,sans-serif,Courier,mono"size="3">write
  ).. Пользователям хорошо знакомы такие понятия, связанные с организацией файловой
  системы, как каталог, текущий каталог, корневой каталог, путь, для манипулирования
  которыми в операционной системе имеются системные вызовы. Файловая система ОС
  описана в главах 11-12.</font></p>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">
<p style="text-align: center"><i><font face="Times New Roman,sans-serif,Courier,mono" size="3">Процессы,
нити</font></i></p>
<p style='text-align:justify'>Концепция процесса в ОС одна из наиболее фундаментальных. 
  Процессы подробно рассмотрены в главах 2-7. Там же описаны нити или легковесные 
  процессы.</p>
<p style='text-align:center'><a name="l0104"></a>
<b>1.4  Архитектурные особенности ОС.</b> </p>
<p style='text-align:justify'>Мы с вами до сих пор говорили о взгляде на операционные
  системы извне, о том, что делают операционные системы. Дальнейший наш курс будет
  посвящен тому, как они это делают. Но мы пока ничего не сказали о том, что они
  представляют внутри себя, какие подходы существуют к их построению.</p>
<p style='text-align:center'><a name="l010401"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">1.4.1</font></b><b><font face="Times New Roman,sans-serif,Courier,mono" size="3">  </font>Монолитное ядро</b></p>
<p style='text-align:justify'>По сути дела, операционная система  это обычная
  программа, поэтому было бы логичным и организовать его так же, как устроено
  большинство программ, то есть составить из процедур и функций. В этом случае
  компоненты операционной системы являются не самостоятельными модулями, а составными
  частями одной большой программы. Такая структура операционной системы называется
  <i>монолитным ядром (monolithic kernel)</i>. Монолитное ядро представляет собой
  набор процедур, каждая из которых  может вызвать каждую. Все процедуры работают
  в привилегированном режиме. Таким образом, монолитное ядро  это такая схема
  операционной системы, при которой все ее компоненты являются составными частями
  одной программы, используют общие структуры данных и взаимодействуют друг с
  другом путем непосредственного вызова процедур. Для монолитной операционной
  системы ядро совпадает со всей системой. </p>
<p style='text-align:justify'>Во многих операционных системах с монолитным ядром
  сборка ядра, то есть его компиляция, осуществляется отдельно для каждого компьютера,
  на который устанавливается операционная система. При этом можно выбрать список
  оборудования и программных протоколов, поддержка которых будет включена в ядро.
  Так как ядро является единой программой, перекомпиляция  это единственный способ
  добавить в него новые компоненты или исключить неиспользуемые. Следует отметить,
  что присутствие в ядре лишних компонентов крайне нежелательно, так как ядро
  всегда полностью располагается в оперативной памяти. Кроме того, исключение
  ненужных компонент повышает надежность операционной системы в целом. </p>
<p style='text-align:justify'>Монолитное ядро  старейший способ организации операционных
  систем. Примером систем с монолитным ядром является большинство Unix-систем.</p>
<p style='text-align:justify'>Даже в монолитных системах можно выделить некоторую
  структуру. Как в бетонной глыбе можно различить вкрапления щебенки, так и в
  монолитном ядре выделяются вкрапления сервисных процедур, соответствующих системным
  вызовам. Сервисные процедуры выполняются в привилегированном режиме, тогда как
  пользовательские программы в непривилегированном режиме. Для перехода с одного
  уровня привилегий на другой иногда может использоваться главная сервисная программа,
  определяющая, какой именно системный вызов был сделан, корректность входных
  данных для этого вызова, и передающая управление соответствующей сервисной процедуре
  с переходом в привилегированный режим работы. Иногда выделяют также набор программных
  утилит, которые  помогают выполнению сервисных  процедур.</p>
<p style='text-align:center'><a name="l010402"></a>
<b>1.4.2  </b><b><font face="Times New Roman,sans-serif,Courier,mono"size="3">Слоеные</font></b><b><font face="Times New Roman,sans-serif,Courier,mono"size="3"> </font></b><b><font face="Times New Roman,sans-serif,Courier,mono"size="3">системы</font></b><b><font face="Times New Roman,sans-serif,Courier,mono"size="3"> (Layered systems)</font></b></p>
<p style='text-align:justify'>Продолжая структуризацию, можно разбить всю вычислительную
  систему на ряд более мелких уровней с хорошо определенными связями между ними,
  так чтобы объекты уровня  N могли вызывать только объекты из уровня N-1. Нижним
  уровнем в таких системах обычно является hardware, верхним уровнем  интерфейс
  пользователя. Чем ниже уровень, тем более привилегированные команды и действия
  может  выполнять модуль, находящийся на этом уровне. Впервые такой подход был
  применен при создании системы THE (Technishe Hogeschool Eindhoven) Дейкстрой
  и его студентами в 1968 г. Эта система имела следующие уровни:</p>
<p align=center style='text-align:center'><img border="0" src="images/image002.gif" width="411" height="133"></p>
<p align=center style='text-align:center'><font size="2">Рис. 1.2
Структура слоеной системы <font face="Times New Roman,sans-serif,Courier,mono"size="3">THE</font>.</font></p>
<p style='text-align:justify'>Слоеные системы хорошо реализуются. При использовании 
  операций нижнего слоя не нужно знать, как они реализованы, нужно знать лишь, 
  что они делают. Слоеные системы хорошо тестируются. Отладка начинается с нижнего 
  слоя и проводится послойно. При возникновении ошибки мы можем быть уверены, 
  что она находится в тестируемом слое. Слоеные системы хорошо модифицируются. 
  При необходимости можно заменить лишь один слой, не трогая остальные. Но слоеные 
  системы сложны для разработки: тяжело правильно определить порядок слоев, и 
  что, к какому слою относится.  Слоеные системы менее эффективны, чем монолитные. 
  Так, например, для выполнения операций ввода-вывода программе пользователя придется 
  последовательно проходить все слои - от верхнего до нижнего.</p>
<p style='text-align:center'><a name="l010403"></a>
<b>1.4.3  Виртуальные машины</b></p>
<p style='text-align:justify'>В начале лекции мы говорили о взгляде на операционную
  систему как на виртуальную машину, когда пользователю нет необходимости знать
  детали внутреннего устройства компьютера. Он работает с файлами, а не с магнитными
  головками и двигателем; он работает с огромной виртуальной, а не ограниченной
  реальной оперативной памятью; его мало волнует, единственный он на машине пользователь
  или нет. Рассмотрим несколько другой подход. Пусть операционная система реализует
  виртуальную машину для каждого пользователя, но, не упрощая ему жизнь, а, наоборот,
  усложняя. Каждая такая виртуальная машина предстает перед пользователем как
  абсолютно голое железо  копия всего hardware в вычислительной системе, включая
  процессор, привилегированные и непривилегированные команды, устройства ввода-вывода,
  прерывания и т.д. И он один на один с этим железом. При попытке обратиться к
  этому виртуальному железу на уровне привилегированных команд, в действительности
  происходит системный вызов реальной операционной системы, которая и производит
  все необходимые действия. Такой подход позволяет каждому пользователю загрузить
  свою собственную операционную систему на виртуальную машину и делать с ней все,
  что душа пожелает.</p>
<p style='text-align:center'><img border="0" src="images/image003.gif" width="597" height="113"></p>
<p style='text-align:center'><font size="2">
Рис. 1.3 Вариант виртуальной машины.</font></p>
<p style='text-align:justify'>Первой реальной системой такого рода была система
  CP/CMS  или VM/370, как ее называют сейчас, для семейства машин IBM/370.</p>
<p style='text-align:justify'>Недостатком таких операционных систем является снижение
  эффективности виртуальных машин по сравнению с реальной машиной, и, как правило,
  они очень громоздки. Преимуществом - использование на одной вычислительной системе
  программ, написанных для разных операционных систем.</p>
<p style='text-align:center'><a name="l010404"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">1.4.4 Микроядерная архитектура.</font></b></p>
<p style='text-align:justify'>Современная тенденция в разработке операционных
  систем  это перенесение значительной части системного кода на  уровень  пользователя
  и одновременной минимизации ядра. Речь идет о  подходе к построению ядра, называемом
  микроядерной архитектурой (microkernel architecture) операционной системы, когда
  большинство ее составляющих являются самостоятельными программами. В этом случае
  взаимодействие между ними обеспечивает специальный модуль ядра, называемый микроядром.
  Микроядро работает в привилегированном режиме и  обеспечивает взаимодействие
  между программами, планирование использования процессора, первичную обработку
  прерываний, операции ввода-вывода и базовое управление памятью.</p>
<p align=center style='text-align:center'><img border="0" src="images/image004.gif" width="563" height="402"></p>
<p align=center style='text-align:center'><font size="2">Рис. 1.4  Микроядерная  архитектура
  операционной системы</font></p>
<p style='text-align:justify'>Остальные компоненты системы взаимодействуют друг
  с другом путем передачи сообщений через микроядро.</p>
<p style='text-align:justify'>Основное достоинство микроядерной архитектуры 
  высокая степень модульности ядра операционной системы. Это существенно упрощает
  добавление в него новых компонент. В микроядерной операционной системе можно,
  не прерывая ее работы, загружать и выгружать новые драйверы, файловые системы
  и т. д. Существенно упрощается процесс отладки компонент ядра, так как новая
  версия драйвера может загружаться без перезапуска всей операционной системы.
  Компоненты ядра операционной системы ничем принципиально не отличаются от пользовательских
  программ, поэтому для их отладки можно применять обычные средства. В то же время,
  микроядерная архитектура операционной системы вносит дополнительные накладные
  расходы, связанные с передачей сообщений, что существенно влияет на производительность.
  Для того чтобы микроядерная операционная система по скорости не уступала операционным
  системам на базе монолитного ядра, требуется очень аккуратно проектировать разбиение
  системы на компоненты, стараясь минимизировать взаимодействие между ними. Таким
  образом, основная сложность при создании микроядерных операционных систем 
  необходимость очень аккуратного проектирования.</p>
<p style='text-align:center'><a name="l010405"></a><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">1.4.5 Смешанные системы</font></b></p>
<p style='text-align:justify'>Все рассмотренные подходы к построению операционных 
  систем имеют свои преимущества и недостатки. В большинстве случаев современные 
  операционные системы используют различные комбинации этих подходов. </p>
<p style='text-align:justify'>Примером смешанного подхода может служить возможность 
  запуска операционной системы с монолитным ядром под управлением микроядра. Так 
  устроены 4.4BSD и MkLinux, основанные на микроядре Mach. Микроядро обеспечивает 
  управление виртуальной памятью и работу низкоуровневых драйверов. Все остальные 
  функции, в том числе взаимодействие с прикладными программами, осуществляется 
  монолитным ядром. Данный подход возник в результате попыток использовать преимущества 
  микроядерной архитектуры, сохраняя по возможности хорошо отлаженный код монолитного 
  ядра.</p>
<p style='text-align:justify'> Наиболее тесно элементы микроядерной архитектуры
  и элементы монолитного ядра переплетены в ядре Windows&nbsp;NT. Хотя Windows&nbsp;NT
  часто называют микроядерной операционной системой, это не совсем так. Микроядро
  NT слишком сложно и велико (более 1&nbsp;Мб), чтобы носить приставку микро.
  Компоненты ядра Windows&nbsp;NT располагаются в вытесняемой памяти и взаимодействуют
  друг с другом путем передачи сообщений, как и положено в микроядерных операционных
  системах. В тоже время все компоненты ядра работают в одном адресном пространстве
  и активно используют общие структуры данных, что свойственно операционным системам
  с монолитным ядром. Кроме того, в Windows&nbsp;NT существует разделение между
  режимом ядра и режимом пользователя&nbsp; еще одна черта монолитного ядра.
  Причина всего этого проста. По мнению <font face="Times New Roman,sans-serif,Courier,mono"size="3">Microsoft</font>, причина
  проста: чисто микроядерный дизайн коммерчески непрактичен, так как слишком неэффективен.</p>
<p style='text-align:justify'>Таким образом, Windows&nbsp;NT можно с полным правом
  назвать гибридной операционной системой.</p>
<p style='text-align:center'> <a name="l0105"><b>
<font face="Times New Roman,sans-serif,Courier,mono"size="3">1.5&nbsp;</font></b><b><font face="Times New Roman,sans-serif,Courier,mono"size="3">Классификация ОС</font></b></a><b><font face="Times New Roman,sans-serif,Courier,mono"size="3"></font></b></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">Существует
  несколько схем классификации операционных систем. Ниже приведена классификация
  по некоторым признакам с точки зрения пользователя.</font></p>
<p align="center"><i><font face="Times New Roman,sans-serif,Courier,mono"size="3">Реализация многозадачности</font></i></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono"size="3">По числу
  одновременно выполняемых задач операционные системы могут быть разделены на
  два класса: </font></p>
<ul type=disc>
  <li style='text-align:justify;     '>многозадачные (<font face="Times New Roman,sans-serif,Courier,mono"size="3">Unix</font>,
    OS/2, Windows). </li>
  <li style='text-align:justify;     '>однозадачные (например, MS-DOS) и </li>
</ul>
<p style='text-align:justify'>Многозадачная ОС, решая проблемы распределения ресурсов
  и конкуренции, полностью  реализует  мультипрограммный режим в соответствии
  с требованиями раздела 1.3. </p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono"size="3">Приблизительность классификации очевидна из приведенных примеров. Так в ОС </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">MS</font><font face="Times New Roman,sans-serif,Courier,mono"size="3">-</font><font face="Times New Roman,sans-serif,Courier,mono"size="3">DOS</font><font face="Times New Roman,sans-serif,Courier,mono"size="3">  </font>можно организовать запуск дочерней
  задачи и одновременное сосуществование в памяти  двух и более задач. Однако
  эта ОС традиционно считается однозадачной, главным образом из-за отсутствия
  защитных механизмов и коммуникационных возможностей. </p>
<p style='text-align:center'><i><font face="Times New Roman,sans-serif,Courier,mono"size="3">Поддержка многопользовательского режима.</font></i><i><font face="Times New Roman,sans-serif,Courier,mono"size="3"> </font></i></p>
<p style='text-align:justify'>По числу одновременно работающих пользователей ОС
  можно разделить на: </p>
<ul type=disc>
  <li style='text-align:justify;     '>однопользовательские (MS-DOS, Windows 3.x);
  </li>
  <li style='text-align:justify;     '>многопользовательские (Windows NT, <font face="Times New Roman,sans-serif,Courier,mono"size="3">Unix</font>). </li>
</ul>
<p style='text-align:justify'>Наиболее существенно отличие заключается в наличии
  у многопользовательских систем  механизмов защиты персональных данных каждого
  пользователя.</p>
<p style='text-align:center'><i>Многопроцессорная
обработка</i></p>
<p style='text-align:justify'>Многопроцессорные системы состоят из двух или более 
  центральных процессоров, осуществляющих параллельное выполнение команд. Поддержка 
  мультипроцессирования является важным свойством ОС и приводит к усложнению всех 
  алгоритмов управления ресурсами. Многопроцессорная обработка реализована в таких 
  ОС, как <font face="Times New Roman,sans-serif,Courier,mono"size="3">Linux</font>, 
  <font face="Times New Roman,sans-serif,Courier,mono"size="3">Solaris</font>, 
  <font face="Times New Roman,sans-serif,Courier,mono"size="3">Windows</font><font face="Times New Roman,sans-serif,Courier,mono"size="3"> 
  </font><font face="Times New Roman,sans-serif,Courier,mono"size="3">NT</font> 
  и в ряде других.</p>
<p style='text-align:justify'>Многопроцессорные ОС разделяют на симметричные и
  асимметричные.  В симметричных ОС на каждом процессоре функционирует одно и
  то же ядро и задача может быть выполнена на любом процессоре, то есть обработка
  полностью децентрализована. В асимметричных ОС процессоры неравноправны. Обычно
  существует главный процессор (<font face="Times New Roman,sans-serif,Courier,mono"size="3">master</font>) и подчиненные
  (<font face="Times New Roman,sans-serif,Courier,mono"size="3">slave</font>), загрузку и характер работы которых определяет
  главный процессор.</p>
<p style='text-align:center'><i><font face="Times New Roman,sans-serif,Courier,mono"size="3">Системы реального времени.</font></i></p>
<p style='text-align:justify'>В разряд многозадачных ОС, наряду с пакетными системами
  и системами разделения времени, включаются также системы <i>реального времени,
  </i>не упоминавшиеся до сих пор.</p>
<p style='text-align:justify'>Они  используются для управления различными техническими
  объектами или технологическими процессами. Такие системы характеризуются предельно
  допустимым временем реакции на внешнее событие, в течение которого должна быть
  выполнена программа, управляющая объектом.  Система должна обрабатывать поступающие
  данные быстрее, чем те могут поступать, причем от нескольких источников одновременно.</p>
<p style='text-align:justify'>Столь жесткие ограничения сказываются на архитектуре
  систем реального времени, например,  в них может отсутствовать виртуальная память,
  поддержка которой дает непредсказуемые задержки в выполнении программ.  (См.
  также разделы, связанные с планированием процессов и реализацией виртуальной
  памяти).</p>
<p style='text-align:justify'>Приведенная классификация ОС не является исчерпывающей. 
  Более подробно особенности применения современных ОС рассмотрены в <a href="../literature/literature.htm">[30]</a>. 
</p>
<p style='text-align:center'><a name="l0106"></a> <b>1.6  Резюме</b></p>
<p style='text-align:justify'>Мы с вами рассмотрели различные взгляды на то, что
  такое операционная система; изучили историю развития операционных систем; выяснили,
  какие функции обычно выполняют операционные системы; наконец, разобрались в
  том, какие существуют подходы к построению операционных систем. Следующую лекцию
  мы посвятим выяснению понятия процесс и вопросам планирования процессов.</p>
<p style='text-align:justify'>**  Реальная эволюция операционных систем происходила
  не так гладко и планомерно, как это представлено в данном историческом обзоре.
  Так, первая система с разделением времени <font face="Times New Roman,sans-serif,Courier,mono"size="3">Joss</font> была
  реализована  еще на ламповой машине <font face="Times New Roman,sans-serif,Courier,mono"size="3">Joniac</font> без всякой
  аппаратной поддержки.</p>

<p align="center"><a href="../os.html">Программа курса</a> | 
<a href="../02/ch2.htm"> Следующая глава</a></P>
</font>
</body>
</html>
